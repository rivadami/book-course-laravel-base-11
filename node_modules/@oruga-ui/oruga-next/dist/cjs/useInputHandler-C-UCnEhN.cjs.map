{"version":3,"file":"useInputHandler-C-UCnEhN.cjs","sources":["../../src/composables/useInputHandler.ts"],"sourcesContent":["import {\n    nextTick,\n    ref,\n    computed,\n    type ExtractPropTypes,\n    type MaybeRefOrGetter,\n    type Component,\n    watch,\n} from \"vue\";\nimport { injectField } from \"@/components/field/fieldInjection\";\nimport { unrefElement } from \"./unrefElement\";\nimport { getOption } from \"@/utils/config\";\nimport { isSSR } from \"@/utils/ssr\";\nimport { isDefined } from \"@/utils/helpers\";\n\n// This should cover all types of HTML elements that have properties related to\n// HTML constraint validation, e.g. .form and .validity.\nconst validatableFormElementTypes = isSSR\n    ? []\n    : [\n          HTMLButtonElement,\n          HTMLFieldSetElement,\n          HTMLInputElement,\n          HTMLObjectElement,\n          HTMLOutputElement,\n          HTMLSelectElement,\n          HTMLTextAreaElement,\n      ];\n\nexport type ValidatableFormElement = InstanceType<\n    (typeof validatableFormElementTypes)[number]\n>;\n\nfunction asValidatableFormElement(el: unknown): ValidatableFormElement | null {\n    return validatableFormElementTypes.some((t) => el instanceof t)\n        ? (el as ValidatableFormElement)\n        : null;\n}\n\nconst constraintValidationAttributes = [\n    \"disabled\",\n    \"required\",\n    \"pattern\",\n    \"maxlength\",\n    \"minlength\",\n    \"max\",\n    \"min\",\n    \"step\",\n];\n\n/**\n * Form input handler functionalities\n */\nexport function useInputHandler<T extends ValidatableFormElement>(\n    /** input ref element - can be a html element or a vue component*/\n    inputRef: MaybeRefOrGetter<T | Component>,\n    /** emitted input events */\n    emits: {\n        /** on input focus event */\n        (e: \"focus\", value: Event): void;\n        /** on input blur event */\n        (e: \"blur\", value: Event): void;\n        /** on input invalid event */\n        (e: \"invalid\", value: Event): void;\n    },\n    /** validation configuration props */\n    props: Readonly<\n        ExtractPropTypes<{\n            useHtml5Validation?: boolean;\n            validationMessage?: string;\n        }>\n    >,\n) {\n    // inject parent field component if used inside one\n    const { parentField } = injectField();\n\n    /// Allows access to the native element in cases where it might be missing,\n    /// e.g. because the component hasn't been mounted yet or has been suspended\n    /// by a <KeepAlive>\n    const maybeElement = computed<T | undefined>(() => {\n        const el = unrefElement<Component | HTMLElement>(inputRef);\n        if (!el) {\n            return undefined;\n        }\n        if (el.getAttribute(\"data-oruga-input\"))\n            // if element is the input element\n            return el as T;\n\n        const inputs = el.querySelector(\"[data-oruga-input]\");\n\n        if (!inputs) {\n            console.warn(\n                \"useInputHandler: Underlaying Oruga input component not found\",\n            );\n            return undefined;\n        }\n        // return underlaying the input element\n        return inputs as T;\n    });\n\n    /// Should be used for most accesses to the native element; we generally\n    /// expect it to be present, especially in event handlers.\n    const element = computed(() => {\n        const el = maybeElement.value;\n        if (!el) {\n            console.warn(\"useInputHandler: inputRef contains no element\");\n        }\n        return el;\n    });\n\n    // --- Input Focus Feature ---\n\n    const isFocused = ref(false);\n\n    /** Focus the underlaying input element. */\n    function setFocus(): void {\n        nextTick(() => {\n            if (element.value) element.value.focus();\n        });\n    }\n\n    /** Click the underlaying input element. */\n    function doClick(): void {\n        nextTick(() => {\n            if (element.value) element.value.click();\n        });\n    }\n\n    /** Unset focused and emit blur event. */\n    function onBlur(event?: Event): void {\n        isFocused.value = false;\n        if (parentField?.value) parentField.value.setFocus(false);\n        emits(\"blur\", event);\n        checkHtml5Validity();\n    }\n\n    /** Set focused and emit focus event. */\n    function onFocus(event?: Event): void {\n        isFocused.value = true;\n        if (parentField?.value) parentField.value.setFocus(true);\n        emits(\"focus\", event);\n    }\n\n    // --- Validation Feature ---\n\n    const isValid = ref(true);\n\n    function setFieldValidity(variant, message): void {\n        nextTick(() => {\n            if (parentField?.value) {\n                // Set type only if not defined\n                if (!parentField.value.props.variant) {\n                    parentField.value.setVariant(variant);\n                }\n                // Set message only if not defined\n                if (!parentField.value.props.message) {\n                    parentField.value.setMessage(message);\n                }\n            }\n        });\n    }\n\n    /**\n     * Check HTML5 validation, set isValid property.\n     * If validation fail, send 'danger' type,\n     * and error message to parent if it's a Field.\n     */\n    function checkHtml5Validity(): void {\n        if (!props.useHtml5Validation) return;\n\n        if (!element.value) return;\n        if (element.value.validity.valid) {\n            setFieldValidity(null, null);\n            isValid.value = true;\n        } else {\n            setInvalid();\n            isValid.value = false;\n        }\n    }\n\n    function setInvalid(): void {\n        const variant = \"danger\";\n        const message =\n            props.validationMessage || element.value.validationMessage;\n        setFieldValidity(variant, message);\n    }\n\n    function onInvalid(event: Event): void {\n        checkHtml5Validity();\n        const validatable = asValidatableFormElement(event.target);\n        if (validatable && parentField?.value && props.useHtml5Validation) {\n            // We provide our own error message on the field, so we should suppress the browser's default tooltip.\n            // We still want to focus the form's first invalid input, though.\n            event.preventDefault();\n            let isFirstInvalid = false;\n            if (validatable.form != null) {\n                const formElements = validatable.form.elements;\n                for (let i = 0; i < formElements.length; ++i) {\n                    const element = asValidatableFormElement(\n                        formElements.item(i),\n                    );\n                    if (element?.willValidate && !element.validity.valid) {\n                        isFirstInvalid = validatable === element;\n                        break;\n                    }\n                }\n            }\n            if (isFirstInvalid) {\n                const fieldElement = parentField.value.$el;\n                const invalidHandler = getOption(\"invalidHandler\");\n                if (invalidHandler instanceof Function) {\n                    invalidHandler(validatable, fieldElement);\n                } else {\n                    // We'll scroll to put the whole field in view, not just the element that triggered the event,\n                    // which should mean that the message will be visible onscreen.\n                    // scrollIntoViewIfNeeded() is a non-standard method (but a very common extension).\n                    // If we can't use it, we'll just fall back to focusing the field.\n                    const canScrollToField = fieldElement\n                        ? fieldElement.scrollIntoView != undefined\n                        : false;\n                    validatable.focus({ preventScroll: canScrollToField });\n                    if (canScrollToField) {\n                        fieldElement.scrollIntoView({ block: \"nearest\" });\n                    }\n                }\n            }\n        }\n        emits(\"invalid\", event);\n    }\n\n    if (!isSSR) {\n        // Respond to attribute changes that might clear constraint validation errors.\n        // For instance, removing the `required` attribute on an empty field means that it's no\n        // longer invalid, so we might as well clear the validation message.\n        // In order to follow our usual convention, we won't add new validation messages\n        // until the next time the user interacts with the control.\n\n        // Technically, having the `required` attribute on one element in a radio button\n        // group affects the validity of the entire group.\n        // See https://html.spec.whatwg.org/multipage/input.html#radio-button-group.\n        // We're not checking for that here because it would require more expensive logic.\n        // Because of that, this will only work properly if the `required` attributes of all radio\n        // buttons in the group are synchronized with each other, which is likely anyway.\n        // (We're also expecting the use of radio buttons with our default validation message handling\n        // to be fairly uncommon because the overall visual experience is clunky with such a configuration.)\n        const onAttributeChange = (): void => {\n            if (!isValid.value) checkHtml5Validity();\n        };\n        let validationAttributeObserver: MutationObserver | null = null;\n        watch(\n            [maybeElement, isValid, () => props.useHtml5Validation],\n            (data) => {\n                // Not using destructuring assignment because browser support is just a little too weak at the moment\n                const el = data[0];\n                const valid = data[1];\n                const useValidation = data[2];\n\n                // Clean up previous state.\n                if (validationAttributeObserver != null) {\n                    // Process any pending events.\n                    if (validationAttributeObserver.takeRecords().length > 0) {\n                        onAttributeChange();\n                    }\n                    validationAttributeObserver.disconnect();\n                }\n\n                if (!isDefined(el) || valid || !useValidation) {\n                    return;\n                }\n\n                if (validationAttributeObserver == null) {\n                    validationAttributeObserver = new MutationObserver(\n                        onAttributeChange,\n                    );\n                }\n                validationAttributeObserver.observe(el, {\n                    attributeFilter: constraintValidationAttributes,\n                });\n\n                // Note that this doesn't react to changes in the list of ancestors.\n                // Based on testing, Vue seems to rarely, if ever, re-parent DOM nodes;\n                // it generally prefers to create new ones under the new parent.\n                // That means this simpler solution is likely good enough for now.\n                let ancestor: Node | null = el;\n                while ((ancestor = ancestor.parentNode)) {\n                    // Form controls can be disabled by their ancestor fieldsets.\n                    if (ancestor instanceof HTMLFieldSetElement) {\n                        validationAttributeObserver.observe(ancestor, {\n                            attributeFilter: [\"disabled\"],\n                        });\n                    }\n                }\n            },\n            { immediate: true },\n        );\n    }\n\n    return {\n        input: element,\n        isFocused,\n        isValid,\n        setFocus,\n        doClick,\n        onFocus,\n        onBlur,\n        checkHtml5Validity,\n        onInvalid,\n    };\n}\n"],"names":["isSSR","injectField","computed","unrefElement","ref","nextTick","element","getOption","watch","isDefined"],"mappings":";;;;;;;;AAiBA,MAAM,8BAA8BA,IAC9B,QAAA,KACA;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAMN,SAAS,yBAAyB,IAA4C;AAC1E,SAAO,4BAA4B,KAAK,CAAC,MAAM,cAAc,CAAC,IACvD,KACD;AACV;AAEA,MAAM,iCAAiC;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAKgB,SAAA,gBAEZ,UAEA,OASA,OAMF;AAEQ,QAAA,EAAE,gBAAgBC,eAAAA;AAKlB,QAAA,eAAeC,IAAAA,SAAwB,MAAM;AACzC,UAAA,KAAKC,0BAAsC,QAAQ;AACzD,QAAI,CAAC,IAAI;AACE,aAAA;AAAA,IACX;AACI,QAAA,GAAG,aAAa,kBAAkB;AAE3B,aAAA;AAEL,UAAA,SAAS,GAAG,cAAc,oBAAoB;AAEpD,QAAI,CAAC,QAAQ;AACD,cAAA;AAAA,QACJ;AAAA,MAAA;AAEG,aAAA;AAAA,IACX;AAEO,WAAA;AAAA,EAAA,CACV;AAIK,QAAA,UAAUD,IAAAA,SAAS,MAAM;AAC3B,UAAM,KAAK,aAAa;AACxB,QAAI,CAAC,IAAI;AACL,cAAQ,KAAK,+CAA+C;AAAA,IAChE;AACO,WAAA;AAAA,EAAA,CACV;AAIK,QAAA,YAAYE,QAAI,KAAK;AAG3B,WAAS,WAAiB;AACtBC,QAAAA,SAAS,MAAM;AACX,UAAI,QAAQ;AAAO,gBAAQ,MAAM;IAAM,CAC1C;AAAA,EACL;AAGA,WAAS,UAAgB;AACrBA,QAAAA,SAAS,MAAM;AACX,UAAI,QAAQ;AAAO,gBAAQ,MAAM;IAAM,CAC1C;AAAA,EACL;AAGA,WAAS,OAAO,OAAqB;AACjC,cAAU,QAAQ;AAClB,QAAI,2CAAa;AAAmB,kBAAA,MAAM,SAAS,KAAK;AACxD,UAAM,QAAQ,KAAK;AACA;EACvB;AAGA,WAAS,QAAQ,OAAqB;AAClC,cAAU,QAAQ;AAClB,QAAI,2CAAa;AAAmB,kBAAA,MAAM,SAAS,IAAI;AACvD,UAAM,SAAS,KAAK;AAAA,EACxB;AAIM,QAAA,UAAUD,QAAI,IAAI;AAEf,WAAA,iBAAiB,SAAS,SAAe;AAC9CC,QAAAA,SAAS,MAAM;AACX,UAAI,2CAAa,OAAO;AAEpB,YAAI,CAAC,YAAY,MAAM,MAAM,SAAS;AACtB,sBAAA,MAAM,WAAW,OAAO;AAAA,QACxC;AAEA,YAAI,CAAC,YAAY,MAAM,MAAM,SAAS;AACtB,sBAAA,MAAM,WAAW,OAAO;AAAA,QACxC;AAAA,MACJ;AAAA,IAAA,CACH;AAAA,EACL;AAOA,WAAS,qBAA2B;AAChC,QAAI,CAAC,MAAM;AAAoB;AAE/B,QAAI,CAAC,QAAQ;AAAO;AAChB,QAAA,QAAQ,MAAM,SAAS,OAAO;AAC9B,uBAAiB,MAAM,IAAI;AAC3B,cAAQ,QAAQ;AAAA,IAAA,OACb;AACQ;AACX,cAAQ,QAAQ;AAAA,IACpB;AAAA,EACJ;AAEA,WAAS,aAAmB;AACxB,UAAM,UAAU;AAChB,UAAM,UACF,MAAM,qBAAqB,QAAQ,MAAM;AAC7C,qBAAiB,SAAS,OAAO;AAAA,EACrC;AAEA,WAAS,UAAU,OAAoB;AAChB;AACb,UAAA,cAAc,yBAAyB,MAAM,MAAM;AACzD,QAAI,gBAAe,2CAAa,UAAS,MAAM,oBAAoB;AAG/D,YAAM,eAAe;AACrB,UAAI,iBAAiB;AACjB,UAAA,YAAY,QAAQ,MAAM;AACpB,cAAA,eAAe,YAAY,KAAK;AACtC,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,EAAE,GAAG;AAC1C,gBAAMC,WAAU;AAAA,YACZ,aAAa,KAAK,CAAC;AAAA,UAAA;AAEvB,eAAIA,qCAAS,iBAAgB,CAACA,SAAQ,SAAS,OAAO;AAClD,6BAAiB,gBAAgBA;AACjC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,gBAAgB;AACV,cAAA,eAAe,YAAY,MAAM;AACjC,cAAA,iBAAiBC,iBAAU,gBAAgB;AACjD,YAAI,0BAA0B,UAAU;AACpC,yBAAe,aAAa,YAAY;AAAA,QAAA,OACrC;AAKH,gBAAM,mBAAmB,eACnB,aAAa,kBAAkB,SAC/B;AACN,sBAAY,MAAM,EAAE,eAAe,iBAAkB,CAAA;AACrD,cAAI,kBAAkB;AAClB,yBAAa,eAAe,EAAE,OAAO,UAAW,CAAA;AAAA,UACpD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,WAAW,KAAK;AAAA,EAC1B;AAEA,MAAI,CAACP,IAAAA,OAAO;AAeR,UAAM,oBAAoB,MAAY;AAClC,UAAI,CAAC,QAAQ;AAA0B;IAAA;AAE3C,QAAI,8BAAuD;AAC3DQ,QAAA;AAAA,MACI,CAAC,cAAc,SAAS,MAAM,MAAM,kBAAkB;AAAA,MACtD,CAAC,SAAS;AAEA,cAAA,KAAK,KAAK,CAAC;AACX,cAAA,QAAQ,KAAK,CAAC;AACd,cAAA,gBAAgB,KAAK,CAAC;AAG5B,YAAI,+BAA+B,MAAM;AAErC,cAAI,4BAA4B,cAAc,SAAS,GAAG;AACpC;UACtB;AACA,sCAA4B,WAAW;AAAA,QAC3C;AAEA,YAAI,CAACC,QAAAA,UAAU,EAAE,KAAK,SAAS,CAAC,eAAe;AAC3C;AAAA,QACJ;AAEA,YAAI,+BAA+B,MAAM;AACrC,wCAA8B,IAAI;AAAA,YAC9B;AAAA,UAAA;AAAA,QAER;AACA,oCAA4B,QAAQ,IAAI;AAAA,UACpC,iBAAiB;AAAA,QAAA,CACpB;AAMD,YAAI,WAAwB;AACpB,eAAA,WAAW,SAAS,YAAa;AAErC,cAAI,oBAAoB,qBAAqB;AACzC,wCAA4B,QAAQ,UAAU;AAAA,cAC1C,iBAAiB,CAAC,UAAU;AAAA,YAAA,CAC/B;AAAA,UACL;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,EAAE,WAAW,KAAK;AAAA,IAAA;AAAA,EAE1B;AAEO,SAAA;AAAA,IACH,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAER;;"}