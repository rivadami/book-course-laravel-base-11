{"version":3,"file":"useProgrammatic-XPP_bK8m.cjs","sources":["../../src/composables/useProgrammatic.ts"],"sourcesContent":["import { computed, getCurrentInstance, onMounted, type Ref } from \"vue\";\nimport type { ProgrammaticInstance } from \"..\";\nimport { isClient, HTMLElement } from \"@/utils/ssr\";\nimport { usePropBinding } from \"./usePropValue\";\nimport { useEventListener } from \"./useEventListener\";\nimport { removeElement } from \"@/utils/helpers\";\n\ntype ProgrammaticProps = {\n    active: boolean;\n    /** Define if the component is cancelable at all or by specific events. */\n    cancelable?: boolean | string[];\n    /** Callback function to call after user canceled (pressed escape / clicked outside). */\n    onCancel: (...args: any[]) => void;\n    /** Callback function to call after close (programmatically close or user canceled). */\n    onClose: (...args: any[]) => void;\n    /** DOM element where the programmatic component will be mounted on. */\n    container?: string | HTMLElement;\n    /** This defines the programmatic usage. */\n    programmatic?: ProgrammaticInstance;\n};\n\nexport interface ProgrammaticOptions {\n    /** Method options that allow the component to be cancelled. */\n    cancelOptions?: string[];\n    /** Destroy the component on hide. Default is `true`. */\n    destroyOnHide?: boolean;\n}\n\n/**\n * This provides functionalities for programmatic usage.\n * The component get appended to the container.\n * This defines a cancel and close handler, as well as escape handler.\n * The component will be distroyed on close.\n * @param elementRef HTMLElement which should injected\n * @param props ProgrammaticProps\n * @param emits [\"update:active\", \"close\"]\n * @param options\n */\nexport function useProgrammaticComponent(\n    elementRef: Ref<HTMLElement> | (() => HTMLElement),\n    props: ProgrammaticProps,\n    emits: {\n        (e: \"update:active\", value: boolean): void;\n        (e: \"close\", ...args: any[]): void;\n    },\n    options: ProgrammaticOptions = { cancelOptions: [\"escape\", \"outside\"] },\n) {\n    // getting a hold of the internal instance in setup()\n    const vm = getCurrentInstance();\n    if (!vm)\n        throw new Error(\n            \"useProgrammaticComponent must be called within a component setup function.\",\n        );\n\n    const isActive = usePropBinding(\"active\", props, emits);\n\n    const cancelOptions = computed(() =>\n        typeof props.cancelable === \"boolean\"\n            ? props.cancelable\n                ? options.cancelOptions\n                : []\n            : props.cancelable,\n    );\n\n    function getElement(): HTMLElement {\n        return typeof elementRef === \"function\"\n            ? elementRef()\n            : elementRef.value;\n    }\n\n    const container = computed(\n        (): HTMLElement =>\n            typeof props.container === \"string\"\n                ? document.querySelector<HTMLElement>(props.container)\n                : (props.container as HTMLElement) || document.body,\n    );\n\n    onMounted(() => {\n        if (props.programmatic) {\n            if (props.programmatic.instances) {\n                props.programmatic.instances.add(vm);\n            }\n            // Insert the component in the container or the body tag\n            // only if it's programmatic\n            const el = getElement();\n            container.value.appendChild(el);\n\n            isActive.value = true;\n        }\n    });\n\n    if (isClient) useEventListener(\"keyup\", onKeyPress, container.value);\n\n    /** Keypress event that is bound to the document. */\n    function onKeyPress(event: KeyboardEvent): void {\n        if (isActive.value && (event.key === \"Escape\" || event.key === \"Esc\")) {\n            cancel(\"escape\");\n        }\n    }\n\n    /**\n     * Close the component if cancelable.\n     * @param method Cancel method\n     */\n    function cancel(method: string): void {\n        if (!props.cancelable || !isActive.value) return;\n        // check if method is in options\n        if (cancelOptions.value.indexOf(method) < 0) return;\n        props.onCancel.apply(null);\n        close({ action: \"cancel\", method });\n    }\n\n    /**\n     * Emit events, and destroy the component if it's programmatic.\n     * Can get called outside of a setup scope.\n     */\n    function close(...args: any[]): void {\n        vm.emit(\"close\");\n        props.onClose.apply(null, args);\n\n        if (props.programmatic) {\n            if (props.programmatic.instances)\n                props.programmatic.instances.remove(vm);\n\n            if (props.programmatic.resolve)\n                props.programmatic.resolve.apply(null, args);\n\n            // Timeout for the animation complete before destroying\n            setTimeout(() => {\n                // set active state of current instance\n                vm.props.active = false;\n                vm.emit(\"update:active\", false);\n                if (\n                    typeof options.destroyOnHide === \"undefined\" ||\n                    options.destroyOnHide\n                )\n                    if (isClient)\n                        window.requestAnimationFrame(() => {\n                            // remove the component from the container or the body tag\n                            const el = getElement();\n                            if (el) removeElement(el);\n                        });\n                    else {\n                        const el = getElement();\n                        if (el) removeElement(el);\n                    }\n            });\n        } else {\n            // set active state of current instance\n            vm.props.active = false;\n            vm.emit(\"update:active\", false);\n        }\n    }\n\n    return { close, cancel, isActive, container };\n}\n"],"names":["getCurrentInstance","usePropBinding","computed","onMounted","isClient","useEventListener","removeElement"],"mappings":";;;;;;;AAsCgB,SAAA,yBACZ,YACA,OACA,OAIA,UAA+B,EAAE,eAAe,CAAC,UAAU,SAAS,KACtE;AAEE,QAAM,KAAKA,IAAAA;AACX,MAAI,CAAC;AACD,UAAM,IAAI;AAAA,MACN;AAAA,IAAA;AAGR,QAAM,WAAWC,aAAA,eAAe,UAAU,OAAO,KAAK;AAEtD,QAAM,gBAAgBC,IAAA;AAAA,IAAS,MAC3B,OAAO,MAAM,eAAe,YACtB,MAAM,aACF,QAAQ,gBACR,KACJ,MAAM;AAAA,EAAA;AAGhB,WAAS,aAA0B;AAC/B,WAAO,OAAO,eAAe,aACvB,WAAA,IACA,WAAW;AAAA,EACrB;AAEA,QAAM,YAAYA,IAAA;AAAA,IACd,MACI,OAAO,MAAM,cAAc,WACrB,SAAS,cAA2B,MAAM,SAAS,IAClD,MAAM,aAA6B,SAAS;AAAA,EAAA;AAG3DC,MAAAA,UAAU,MAAM;AACZ,QAAI,MAAM,cAAc;AAChB,UAAA,MAAM,aAAa,WAAW;AACxB,cAAA,aAAa,UAAU,IAAI,EAAE;AAAA,MACvC;AAGA,YAAM,KAAK;AACD,gBAAA,MAAM,YAAY,EAAE;AAE9B,eAAS,QAAQ;AAAA,IACrB;AAAA,EAAA,CACH;AAEG,MAAAC,IAAA;AAA2BC,qBAAAA,iBAAA,SAAS,YAAY,UAAU,KAAK;AAGnE,WAAS,WAAW,OAA4B;AAC5C,QAAI,SAAS,UAAU,MAAM,QAAQ,YAAY,MAAM,QAAQ,QAAQ;AACnE,aAAO,QAAQ;AAAA,IACnB;AAAA,EACJ;AAMA,WAAS,OAAO,QAAsB;AAClC,QAAI,CAAC,MAAM,cAAc,CAAC,SAAS;AAAO;AAE1C,QAAI,cAAc,MAAM,QAAQ,MAAM,IAAI;AAAG;AACvC,UAAA,SAAS,MAAM,IAAI;AACzB,UAAM,EAAE,QAAQ,UAAU,OAAQ,CAAA;AAAA,EACtC;AAMA,WAAS,SAAS,MAAmB;AACjC,OAAG,KAAK,OAAO;AACT,UAAA,QAAQ,MAAM,MAAM,IAAI;AAE9B,QAAI,MAAM,cAAc;AACpB,UAAI,MAAM,aAAa;AACb,cAAA,aAAa,UAAU,OAAO,EAAE;AAE1C,UAAI,MAAM,aAAa;AACnB,cAAM,aAAa,QAAQ,MAAM,MAAM,IAAI;AAG/C,iBAAW,MAAM;AAEb,WAAG,MAAM,SAAS;AACf,WAAA,KAAK,iBAAiB,KAAK;AAC9B,YACI,OAAO,QAAQ,kBAAkB,eACjC,QAAQ;AAEJ,cAAAD,IAAA;AACA,mBAAO,sBAAsB,MAAM;AAE/B,oBAAM,KAAK;AACP,kBAAA;AAAIE,wBAAA,cAAc,EAAE;AAAA,YAAA,CAC3B;AAAA,eACA;AACD,kBAAM,KAAK;AACP,gBAAA;AAAIA,sBAAA,cAAc,EAAE;AAAA,UAC5B;AAAA,MAAA,CACP;AAAA,IAAA,OACE;AAEH,SAAG,MAAM,SAAS;AACf,SAAA,KAAK,iBAAiB,KAAK;AAAA,IAClC;AAAA,EACJ;AAEA,SAAO,EAAE,OAAO,QAAQ,UAAU,UAAU;AAChD;;"}