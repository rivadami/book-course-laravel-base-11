{"version":3,"file":"usePropValue-Bx9vNp-l.cjs","sources":["../../src/composables/usePropValue.ts"],"sourcesContent":["import {\n    computed,\n    ref,\n    watch,\n    nextTick,\n    type ExtractPropTypes,\n    type WritableComputedRef,\n    type Ref,\n    type UnwrapRef,\n    type ComponentObjectPropsOptions,\n} from \"vue\";\n\n/**\n * Adaption of {@link https://vueuse.org/core/useVModel/} options.\n */\nexport interface PropBindingOptions<Passive extends boolean = false> {\n    /**\n     * When passive is set to `true`, it will use `watch` to sync with props and ref.\n     * Instead of relying on the `v-model` or `.sync` to work.\n     *\n     * @default false\n     */\n    passive?: Passive;\n    /**\n     * When eventName is set, it's value will be used to overwrite the emit event name.\n     *\n     * @default undefined\n     */\n    eventName?: string;\n    /**\n     * Attempting to check for changes of properties in a deeply nested object or array.\n     * Apply only when `passive` option is set to `true`\n     *\n     * @default false\n     */\n    deep?: boolean;\n}\n\nexport function usePropBinding<T>(\n    name: string,\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions<any>>>,\n    emit: (event: any, value: T) => void,\n    options?: PropBindingOptions<false>,\n): WritableComputedRef<T>;\n\nexport function usePropBinding<T>(\n    name: string,\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions<any>>>,\n    emit: (event: any, value: T) => void,\n    options?: PropBindingOptions<true>,\n): Ref<UnwrapRef<T>>;\n\n/**\n * Use two-way model binding in script setup syntax.\n * Adaption of {@link https://vueuse.org/core/useVModel/}.\n * @param name Property name\n * @param props Readonly<ExtractPropTypes<ComponentObjectPropsOptions>>\n * @param emit EmitFn\n * @param options Extened usage options\n * @returns Ref<T>\n */\nexport function usePropBinding<T, Passive extends boolean>(\n    name: string,\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions<any>>>,\n    emit: (event: any, value: T) => void,\n    options?: PropBindingOptions<Passive>,\n): Ref<UnwrapRef<T>> | WritableComputedRef<T> {\n    const event = options?.eventName || `update:${name!.toString()}`;\n\n    if (options?.passive) {\n        const proxy = ref<T>(props[name!]);\n        let isUpdating = false;\n\n        watch(\n            () => props[name!],\n            (value) => {\n                if (!isUpdating) {\n                    isUpdating = true;\n                    proxy.value = value;\n                    nextTick(() => (isUpdating = false));\n                }\n            },\n        );\n\n        watch(\n            proxy,\n            (value) => {\n                if ((!isUpdating && value !== props[name!]) || options.deep)\n                    emit(event, value as T);\n            },\n            { deep: options.deep },\n        );\n\n        return proxy;\n    } else {\n        return computed<T>({\n            get() {\n                return props[name!] as T;\n            },\n            set(value) {\n                emit(event, value);\n            },\n        });\n    }\n}\n\nexport function useVModelBinding<T>(\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions>>,\n    emit: {\n        /** on input focus event */\n        (e: \"update:modelValue\", value: T): void;\n    },\n    options?: PropBindingOptions<false>,\n): WritableComputedRef<T>;\n\nexport function useVModelBinding<T>(\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions>>,\n    emit: {\n        /** on input focus event */\n        (e: \"update:modelValue\", value: T): void;\n    },\n    options?: PropBindingOptions<true>,\n): Ref<UnwrapRef<T>>;\n\n/**\n * Use two-way binded modelValue property in script setup syntax.\n * Adaption of {@link https://vueuse.org/core/useVModel/}.\n * @param props Readonly<ExtractPropTypes<ComponentObjectPropsOptions>>\n * @param emit EmitFn\n * @param options Extened usage options\n * @returns Ref<T>\n */\nexport function useVModelBinding<T, Options extends PropBindingOptions>(\n    props: Readonly<ExtractPropTypes<ComponentObjectPropsOptions>>,\n    emit: {\n        /** on input focus event */\n        (e: \"update:modelValue\", value: T): void;\n    },\n    options?: Options,\n): WritableComputedRef<T> | Ref<UnwrapRef<T>> {\n    return usePropBinding(\"modelValue\", props, emit, options);\n}\n"],"names":["ref","watch","nextTick","computed"],"mappings":";;;AA6DO,SAAS,eACZ,MACA,OACA,MACA,SAC0C;AAC1C,QAAM,SAAQ,mCAAS,cAAa,UAAU,KAAM,SAAU,CAAA;AAE9D,MAAI,mCAAS,SAAS;AAClB,UAAM,QAAQA,IAAA,IAAO,MAAM,IAAK,CAAC;AACjC,QAAI,aAAa;AAEjBC,QAAA;AAAA,MACI,MAAM,MAAM,IAAK;AAAA,MACjB,CAAC,UAAU;AACP,YAAI,CAAC,YAAY;AACA,uBAAA;AACb,gBAAM,QAAQ;AACLC,uBAAA,MAAO,aAAa,KAAM;AAAA,QACvC;AAAA,MACJ;AAAA,IAAA;AAGJD,QAAA;AAAA,MACI;AAAA,MACA,CAAC,UAAU;AACP,YAAK,CAAC,cAAc,UAAU,MAAM,IAAK,KAAM,QAAQ;AACnD,eAAK,OAAO,KAAU;AAAA,MAC9B;AAAA,MACA,EAAE,MAAM,QAAQ,KAAK;AAAA,IAAA;AAGlB,WAAA;AAAA,EAAA,OACJ;AACH,WAAOE,aAAY;AAAA,MACf,MAAM;AACF,eAAO,MAAM,IAAK;AAAA,MACtB;AAAA,MACA,IAAI,OAAO;AACP,aAAK,OAAO,KAAK;AAAA,MACrB;AAAA,IAAA,CACH;AAAA,EACL;AACJ;AA4BgB,SAAA,iBACZ,OACA,MAIA,SAC0C;AAC1C,SAAO,eAAe,cAAc,OAAO,MAAM,OAAO;AAC5D;;;"}