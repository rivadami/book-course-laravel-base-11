{"version":3,"file":"useParentProvider-CVABNV-7.mjs","sources":["../../src/composables/useParentProvider.ts"],"sourcesContent":["import {\n    computed,\n    getCurrentInstance,\n    inject,\n    nextTick,\n    onUnmounted,\n    provide,\n    ref,\n    type Component,\n    type ComputedRef,\n    type Ref,\n    type UnwrapNestedRefs,\n} from \"vue\";\nimport { unrefElement } from \"./unrefElement\";\n\nexport type ProviderItem<T = unknown> = {\n    index: number;\n    data: ComputedRef<T>;\n    identifier: string;\n};\n\ntype PovidedData<P, I = unknown> = {\n    registerItem: (data: ComputedRef<I>) => ProviderItem<I>;\n    unregisterItem: (item: ProviderItem<I>) => void;\n    data?: ComputedRef<P>;\n};\n\ntype ProviderParentOptions<T = unknown> = {\n    /**\n     * Override the provide/inject key.\n     * Default is the component configField attribute\n     */\n    key?: string;\n    /**\n     * Additional data provided for the child to the item\n     */\n    data?: ComputedRef<T>;\n};\n\n/**\n * Provide functionalities and data to child components\n * @param rootRef Root element of the provider component\n * @param data Additional data to provide\n * @param options additional options\n */\nexport function useProviderParent<ItemData = unknown, ParentData = unknown>(\n    rootRef?: Ref<HTMLElement | Component>,\n    options?: ProviderParentOptions<ParentData>,\n): {\n    childItems: Ref<UnwrapNestedRefs<ProviderItem<ItemData>[]>>;\n    sortedItems: ComputedRef<UnwrapNestedRefs<ProviderItem<ItemData>[]>>;\n} {\n    // getting a hold of the internal instance in setup()\n    const vm = getCurrentInstance();\n    if (!vm)\n        throw new Error(\n            \"useProviderChild must be called within a component setup function.\",\n        );\n\n    const configField = vm.proxy?.$options.configField;\n    const key = options?.key || configField;\n\n    const childItems = ref<ProviderItem<ItemData>[]>([]);\n    const sequence = ref(1);\n\n    /**\n     * When items are added/removed sort them according to their position\n     */\n    const sortedItems = computed(() =>\n        childItems.value.slice().sort((a, b) => a.index - b.index),\n    );\n\n    function registerItem(\n        data?: ComputedRef<ItemData>,\n    ): ProviderItem<ItemData> {\n        const index = childItems.value.length;\n        const identifier = nextSequence();\n        const item = { index, data, identifier };\n        childItems.value.push(item as UnwrapNestedRefs<typeof item>);\n        if (rootRef?.value) {\n            nextTick(() => {\n                const ids = childItems.value\n                    .map((item) => `[data-id=\"${key}-${item.identifier}\"]`)\n                    .join(\",\");\n                const parent = unrefElement(rootRef);\n                const children = parent.querySelectorAll(ids);\n                const sortedIds = Array.from(children).map((el) =>\n                    el.getAttribute(\"data-id\").replace(`${key}-`, \"\"),\n                );\n\n                childItems.value.forEach(\n                    (item) =>\n                        (item.index = sortedIds.indexOf(`${item.identifier}`)),\n                );\n            });\n        }\n        return item;\n    }\n\n    function unregisterItem(item: ProviderItem): void {\n        childItems.value = childItems.value.filter((i) => i !== item);\n    }\n\n    function nextSequence(): string {\n        return String(sequence.value++);\n    }\n\n    /** Provide functionality for child components via dependency injection. */\n    provide<PovidedData<ParentData, ItemData>>(\"$o-\" + key, {\n        registerItem,\n        unregisterItem,\n        data: options?.data,\n    });\n\n    return {\n        childItems,\n        sortedItems,\n    };\n}\n\ntype ProviderChildOptions<T = unknown> = {\n    /**\n     * Override the provide/inject key.\n     * Default is the component configField attribute\n     */\n    key?: string;\n    /**\n     * Does the child need the be below the parent?\n     * @default true\n     */\n    needParent?: boolean;\n    /**\n     * Additional data appended to the item\n     */\n    data?: ComputedRef<T>;\n    /**\n     * Register child on parent\n     * @default true\n     */\n    register?: boolean;\n};\n\n/**\n * Inject functionalities and data from parent components\n * @param options additional options\n */\nexport function useProviderChild<ParentData, ItemData = unknown>(\n    options: ProviderChildOptions<ItemData> = { needParent: true },\n): { parent: ComputedRef<ParentData>; item: Ref<ProviderItem<ItemData>> } {\n    // getting a hold of the internal instance in setup()\n    const vm = getCurrentInstance();\n    if (!vm)\n        throw new Error(\n            \"useProviderChild must be called within a component setup function.\",\n        );\n\n    const configField = vm.proxy?.$options.configField;\n    const key = options?.key || configField;\n\n    /** Inject parent component functionality if used inside one **/\n    const parent = inject<PovidedData<ParentData, ItemData>>(\n        \"$o-\" + key,\n        undefined,\n    );\n\n    const needParent = options.needParent !== false;\n\n    const register = options.register !== false;\n\n    if (needParent && !parent) {\n        throw new Error(\n            `You should wrap ${vm.proxy.$options.name} in a ${key} component`,\n        );\n    }\n\n    const item = ref<ProviderItem<ItemData>>();\n\n    if (parent && register) item.value = parent.registerItem(options.data);\n\n    onUnmounted(() => {\n        if (parent && item.value) parent.unregisterItem(item.value);\n    });\n\n    return { parent: parent?.data, item: item };\n}\n"],"names":["item"],"mappings":";;;AA6CgB,SAAA,kBACZ,SACA,SAIF;;AAEE,QAAM,KAAK;AACX,MAAI,CAAC;AACD,UAAM,IAAI;AAAA,MACN;AAAA,IAAA;AAGF,QAAA,eAAc,QAAG,UAAH,mBAAU,SAAS;AACjC,QAAA,OAAM,mCAAS,QAAO;AAEtB,QAAA,aAAa,IAA8B,CAAA,CAAE;AAC7C,QAAA,WAAW,IAAI,CAAC;AAKtB,QAAM,cAAc;AAAA,IAAS,MACzB,WAAW,MAAM,MAAA,EAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AAAA,EAAA;AAG7D,WAAS,aACL,MACsB;AAChB,UAAA,QAAQ,WAAW,MAAM;AAC/B,UAAM,aAAa;AACnB,UAAM,OAAO,EAAE,OAAO,MAAM,WAAW;AAC5B,eAAA,MAAM,KAAK,IAAqC;AAC3D,QAAI,mCAAS,OAAO;AAChB,eAAS,MAAM;AACX,cAAM,MAAM,WAAW,MAClB,IAAI,CAACA,UAAS,aAAa,GAAG,IAAIA,MAAK,UAAU,IAAI,EACrD,KAAK,GAAG;AACP,cAAA,SAAS,aAAa,OAAO;AAC7B,cAAA,WAAW,OAAO,iBAAiB,GAAG;AAC5C,cAAM,YAAY,MAAM,KAAK,QAAQ,EAAE;AAAA,UAAI,CAAC,OACxC,GAAG,aAAa,SAAS,EAAE,QAAQ,GAAG,GAAG,KAAK,EAAE;AAAA,QAAA;AAGpD,mBAAW,MAAM;AAAA,UACb,CAACA,UACIA,MAAK,QAAQ,UAAU,QAAQ,GAAGA,MAAK,UAAU,EAAE;AAAA,QAAA;AAAA,MAC5D,CACH;AAAA,IACL;AACO,WAAA;AAAA,EACX;AAEA,WAAS,eAAe,MAA0B;AAC9C,eAAW,QAAQ,WAAW,MAAM,OAAO,CAAC,MAAM,MAAM,IAAI;AAAA,EAChE;AAEA,WAAS,eAAuB;AACrB,WAAA,OAAO,SAAS,OAAO;AAAA,EAClC;AAGA,UAA2C,QAAQ,KAAK;AAAA,IACpD;AAAA,IACA;AAAA,IACA,MAAM,mCAAS;AAAA,EAAA,CAClB;AAEM,SAAA;AAAA,IACH;AAAA,IACA;AAAA,EAAA;AAER;AA4BO,SAAS,iBACZ,UAA0C,EAAE,YAAY,QACc;;AAEtE,QAAM,KAAK;AACX,MAAI,CAAC;AACD,UAAM,IAAI;AAAA,MACN;AAAA,IAAA;AAGF,QAAA,eAAc,QAAG,UAAH,mBAAU,SAAS;AACjC,QAAA,OAAM,mCAAS,QAAO;AAG5B,QAAM,SAAS;AAAA,IACX,QAAQ;AAAA,IACR;AAAA,EAAA;AAGE,QAAA,aAAa,QAAQ,eAAe;AAEpC,QAAA,WAAW,QAAQ,aAAa;AAElC,MAAA,cAAc,CAAC,QAAQ;AACvB,UAAM,IAAI;AAAA,MACN,mBAAmB,GAAG,MAAM,SAAS,IAAI,SAAS,GAAG;AAAA,IAAA;AAAA,EAE7D;AAEA,QAAM,OAAO;AAEb,MAAI,UAAU;AAAU,SAAK,QAAQ,OAAO,aAAa,QAAQ,IAAI;AAErE,cAAY,MAAM;AACd,QAAI,UAAU,KAAK;AAAc,aAAA,eAAe,KAAK,KAAK;AAAA,EAAA,CAC7D;AAED,SAAO,EAAE,QAAQ,iCAAQ,MAAM,KAAW;AAC9C;"}