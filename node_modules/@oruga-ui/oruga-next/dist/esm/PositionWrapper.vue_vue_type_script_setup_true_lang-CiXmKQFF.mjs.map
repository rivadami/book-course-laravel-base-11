{"version":3,"file":"PositionWrapper.vue_vue_type_script_setup_true_lang-CiXmKQFF.mjs","sources":["../../src/composables/useScrollingParent.ts","../../src/components/utils/PositionWrapper.vue"],"sourcesContent":["import { isDefined } from \"@/utils/helpers\";\n\n/**\n * Given an element, returns the element who scrolls it.\n */\nexport function getScrollingParent(target: HTMLElement): HTMLElement {\n    if (target.style.position === \"fixed\" || !target)\n        return document.documentElement;\n\n    let isScrollingParent = false;\n    let nextParent = target.parentElement;\n\n    while (!isScrollingParent && isDefined(nextParent)) {\n        if (nextParent === document.documentElement) break;\n\n        const { overflow, overflowY } = getComputedStyle(nextParent);\n        const { scrollHeight, clientHeight } = nextParent; // Both rounded by nature\n\n        isScrollingParent =\n            /(auto|scroll)/.test(`${overflow}${overflowY}`) &&\n            scrollHeight > clientHeight;\n\n        /* ...found it, this one is returned */\n        if (isScrollingParent) break;\n\n        /* ...if not check the next one */\n        nextParent = nextParent.parentElement;\n    }\n\n    return nextParent;\n}\n","<script setup lang=\"ts\">\nimport {\n    watch,\n    computed,\n    nextTick,\n    onBeforeUnmount,\n    ref,\n    type Component,\n    type PropType,\n} from \"vue\";\nimport { isClient } from \"@/utils/ssr\";\nimport { getScrollingParent, unrefElement } from \"@/composables\";\n\ntype Position = \"top\" | \"bottom\" | \"left\" | \"right\";\n\nconst opposites: Record<Position, Position> = {\n    top: \"bottom\",\n    bottom: \"top\",\n    right: \"left\",\n    left: \"right\",\n};\n\ntype Point = { x: number; y: number };\n\ndefineOptions({ inheritAttrs: false });\n\nconst props = defineProps({\n    teleport: {\n        type: [Boolean, String, Object],\n        required: true,\n    },\n    trigger: {\n        type: Object as PropType<HTMLElement | Component>,\n        default: undefined,\n    },\n    /**\n     * Position of the component relative to the trigger\n     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right\n     */\n    position: {\n        type: String,\n        validator: (value: string) =>\n            [\n                \"auto\",\n                \"top\",\n                \"bottom\",\n                \"left\",\n                \"right\",\n                \"top-right\",\n                \"top-left\",\n                \"bottom-left\",\n                \"bottom-right\",\n            ].indexOf(value) > -1,\n        default: undefined,\n    },\n    /** Used for calculation position auto */\n    defaultPosition: {\n        type: String as PropType<Position>,\n        validator: (value: string) =>\n            [\"top\", \"bottom\", \"left\", \"right\"].indexOf(value) > -1,\n        default: \"top\",\n    },\n    /** disable the position calculation */\n    disabled: { type: Boolean, default: false },\n    /** update positioning on teleport */\n    disablePositioning: { type: Boolean, default: true },\n});\n\nconst emits = defineEmits<{\n    (e: \"update:position\", value: string);\n}>();\n\nconst teleportTo = computed(() =>\n    typeof props.teleport === \"boolean\" ? \"body\" : props.teleport,\n);\n\nconst teleportDisabled = computed(() =>\n    typeof props.teleport === \"boolean\" || !props.teleport\n        ? !props.teleport\n        : false,\n);\n\nconst contentRef = ref<HTMLElement | Component>();\n\nfunction setContent<T extends typeof contentRef.value>(el: T): typeof el {\n    contentRef.value = el;\n\n    nextTick(() => {\n        // update positioning\n        updatePositioning();\n        // add handler\n        addHandler();\n    });\n    return el;\n}\n\n// --- Dynamic Positioning Handling Feature ---\n\nconst initialPosition = props.position;\n\nconst scrollingParent = ref(undefined);\nconst resizeObserver = ref(null);\n\nif (isClient && window.ResizeObserver) {\n    resizeObserver.value = new window.ResizeObserver(updatePositioning);\n}\n\n// on content or disable state change update event listener\nwatch(\n    () => props.disabled,\n    () => {\n        if (!props.disabled) addHandler();\n        else removeHandler();\n    },\n    { immediate: true },\n);\n\n// update positioning if props change\nwatch(\n    [\n        () => !!props.trigger,\n        () => props.disablePositioning,\n        () => props.disabled,\n    ],\n    () => {\n        nextTick(() => updatePositioning());\n    },\n    { immediate: true },\n);\n\n// remove any event listener on unmount\nonBeforeUnmount(() => removeHandler());\n\n/** add event listener */\nfunction addHandler(): void {\n    if (isClient && !scrollingParent.value && contentRef.value) {\n        // get parent container\n        scrollingParent.value = getScrollingParent(unrefElement(contentRef));\n        // set event listener\n        if (\n            scrollingParent.value &&\n            scrollingParent.value !== document.documentElement\n        ) {\n            scrollingParent.value.addEventListener(\n                \"scroll\",\n                updatePositioning,\n                { passive: true },\n            );\n            if (window.ResizeObserver)\n                resizeObserver.value.observe(scrollingParent.value);\n        } else {\n            document.addEventListener(\"scroll\", updatePositioning, {\n                passive: true,\n            });\n            window.addEventListener(\"resize\", updatePositioning);\n        }\n    }\n}\n\n/** remove event listener */\nfunction removeHandler(): void {\n    if (isClient) {\n        if (window.ResizeObserver) resizeObserver.value?.disconnect();\n        window.removeEventListener(\"resize\", updatePositioning);\n        document.removeEventListener(\"scroll\", updatePositioning);\n        scrollingParent.value = undefined;\n    }\n}\n\n/** Update the best position set teleport positioning */\nfunction updatePositioning(): void {\n    if (props.disabled) return;\n    let position = props.position;\n    // update position if auto position is enabled\n    if (initialPosition === \"auto\") {\n        // calculate best position\n        position = getAutoPosition();\n        if (position != props.position)\n            // two-way bind updated position\n            emits(\"update:position\", position);\n    }\n    // do not set content position if not teleport enabled\n    if (!props.teleport) return;\n\n    const content = unrefElement(contentRef);\n    const trigger = unrefElement(props.trigger);\n\n    // set content position\n    if (content && trigger) {\n        const rect = trigger.getBoundingClientRect();\n        let top = rect.top + window.scrollY;\n        let left = rect.left + window.scrollX;\n        // define vertical positioning\n        if (position.includes(\"bottom\")) {\n            top += trigger.clientHeight;\n        } else if (position.includes(\"top\")) {\n            top -= content.clientHeight;\n        }\n        // define horizontal positioning\n        if (position === \"left\") {\n            left -= content.clientWidth;\n        } else if (position === \"right\") {\n            left += trigger.clientWidth;\n        } else if (position.includes(\"-right\")) {\n            left += trigger.clientWidth - content.clientWidth;\n        }\n\n        // adjust exact vertical positioning\n        if (position === \"top\" || position === \"bottom\") {\n            left += trigger.clientWidth / 2; //- content.clientWidth / 2;\n        }\n        // adjust exact horizontal positioning\n        if (position === \"left\" || position === \"right\") {\n            top += trigger.clientHeight / 2; // - content.clientHeight / 2;\n        }\n\n        // set style properties\n        if (props.disablePositioning) {\n            content.style.position = \"relative\";\n            content.style.top = `${top}px`;\n            content.style.left = `${left}px`;\n        } else {\n            content.style.position = \"\";\n            content.style.top = \"\";\n            content.style.left = \"\";\n        }\n    }\n}\n\n/** calculate best position if auto */\nfunction getAutoPosition(): string {\n    let bestPosition = props.defaultPosition;\n    if (!props.trigger || !contentRef.value) return bestPosition;\n    if (!scrollingParent.value) return bestPosition;\n\n    // get viewport from container\n    const viewRect = new DOMRect(\n        scrollingParent.value.offsetLeft,\n        scrollingParent.value.offsetTop,\n        scrollingParent.value.clientWidth,\n        scrollingParent.value.clientHeight,\n    );\n\n    const contentRect = unrefElement(contentRef).getBoundingClientRect();\n    const triggerRect = unrefElement(props.trigger).getBoundingClientRect();\n\n    // detect auto position\n    const triggerAnchors = anchors(triggerRect);\n    const contentAnchors = anchors(contentRect);\n    const contentRectAtAnchor = (pos: Position) => {\n        const triggerAnchor = triggerAnchors[pos];\n        const contentAnchor = contentAnchors[opposites[pos]];\n        // Translates contentRect so contentAnchor is on top of triggerAnchor\n        // NOTE: this doesn't account for the extra offset that the tooltip arrow provides.\n        // That offset should be small, and it's tricky to get it from the CSS.\n        return new DOMRect(\n            contentRect.x + (triggerAnchor.x - contentAnchor.x),\n            contentRect.y + (triggerAnchor.y - contentAnchor.y),\n            contentRect.width,\n            contentRect.height,\n        );\n    };\n\n    const defaultOpposite = opposites[props.defaultPosition];\n    const crossPosition =\n        props.defaultPosition === \"top\" || props.defaultPosition === \"bottom\"\n            ? \"left\"\n            : \"top\";\n    const crossOpposite = opposites[crossPosition];\n    // In descending order of priority\n    const positions: Position[] = [\n        props.defaultPosition,\n        defaultOpposite,\n        crossPosition,\n        crossOpposite,\n    ];\n    let maxOverlap = 0;\n    for (const position of positions) {\n        const overlap = intersectionArea(\n            viewRect,\n            contentRectAtAnchor(position),\n        );\n        if (overlap > maxOverlap) {\n            maxOverlap = overlap;\n            bestPosition = position;\n        }\n    }\n    return bestPosition;\n}\n\n// --- Helper Functions ---\n\nfunction intersectionArea(a: DOMRect, b: DOMRect): number {\n    const left = Math.max(a.left, b.left);\n    const right = Math.min(a.right, b.right);\n    const top = Math.max(a.top, b.top);\n    const bottom = Math.min(a.bottom, b.bottom);\n    return Math.max(right - left, 0) * Math.max(bottom - top, 0);\n}\n\n/**\n * @param rect the bounding rectangle of the trigger element\n * @return the \"anchor points\" (points where the arrow attaches) for each side of the tooltip\n */\nconst anchors = (rect: DOMRect): Record<Position, Point> => ({\n    top: { x: (rect.left + rect.right) * 0.5, y: rect.top },\n    bottom: { x: (rect.left + rect.right) * 0.5, y: rect.bottom },\n    left: { x: rect.left, y: (rect.top + rect.bottom) * 0.5 },\n    right: { x: rect.right, y: (rect.top + rect.bottom) * 0.5 },\n});\n</script>\n\n<template>\n    <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabled\">\n        <template v-if=\"teleportDisabled\">\n            <slot :set-content=\"setContent\" />\n        </template>\n        <template v-else>\n            <div\n                v-bind=\"$attrs\"\n                :style=\"{ position: 'absolute', left: '0px', top: '0px' }\">\n                <slot :set-content=\"setContent\" />\n            </div>\n        </template>\n    </Teleport>\n</template>\n"],"names":[],"mappings":"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"}