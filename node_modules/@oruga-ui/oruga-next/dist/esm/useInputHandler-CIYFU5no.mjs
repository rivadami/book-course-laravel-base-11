/*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga */
import { computed, ref, watch, nextTick } from "vue";
import { i as injectField } from "./fieldInjection-B9PE5wx6.mjs";
import { u as unrefElement } from "./unrefElement-DtCqBtLW.mjs";
import { g as getOption } from "./config-C1k5NuG7.mjs";
import { a as isSSR } from "./ssr-BtcosYqY.mjs";
import { isDefined } from "./helpers.mjs";
const validatableFormElementTypes = isSSR ? [] : [
  HTMLButtonElement,
  HTMLFieldSetElement,
  HTMLInputElement,
  HTMLObjectElement,
  HTMLOutputElement,
  HTMLSelectElement,
  HTMLTextAreaElement
];
function asValidatableFormElement(el) {
  return validatableFormElementTypes.some((t) => el instanceof t) ? el : null;
}
const constraintValidationAttributes = [
  "disabled",
  "required",
  "pattern",
  "maxlength",
  "minlength",
  "max",
  "min",
  "step"
];
function useInputHandler(inputRef, emits, props) {
  const { parentField } = injectField();
  const maybeElement = computed(() => {
    const el = unrefElement(inputRef);
    if (!el) {
      return void 0;
    }
    if (el.getAttribute("data-oruga-input"))
      return el;
    const inputs = el.querySelector("[data-oruga-input]");
    if (!inputs) {
      console.warn(
        "useInputHandler: Underlaying Oruga input component not found"
      );
      return void 0;
    }
    return inputs;
  });
  const element = computed(() => {
    const el = maybeElement.value;
    if (!el) {
      console.warn("useInputHandler: inputRef contains no element");
    }
    return el;
  });
  const isFocused = ref(false);
  function setFocus() {
    nextTick(() => {
      if (element.value)
        element.value.focus();
    });
  }
  function doClick() {
    nextTick(() => {
      if (element.value)
        element.value.click();
    });
  }
  function onBlur(event) {
    isFocused.value = false;
    if (parentField == null ? void 0 : parentField.value)
      parentField.value.setFocus(false);
    emits("blur", event);
    checkHtml5Validity();
  }
  function onFocus(event) {
    isFocused.value = true;
    if (parentField == null ? void 0 : parentField.value)
      parentField.value.setFocus(true);
    emits("focus", event);
  }
  const isValid = ref(true);
  function setFieldValidity(variant, message) {
    nextTick(() => {
      if (parentField == null ? void 0 : parentField.value) {
        if (!parentField.value.props.variant) {
          parentField.value.setVariant(variant);
        }
        if (!parentField.value.props.message) {
          parentField.value.setMessage(message);
        }
      }
    });
  }
  function checkHtml5Validity() {
    if (!props.useHtml5Validation)
      return;
    if (!element.value)
      return;
    if (element.value.validity.valid) {
      setFieldValidity(null, null);
      isValid.value = true;
    } else {
      setInvalid();
      isValid.value = false;
    }
  }
  function setInvalid() {
    const variant = "danger";
    const message = props.validationMessage || element.value.validationMessage;
    setFieldValidity(variant, message);
  }
  function onInvalid(event) {
    checkHtml5Validity();
    const validatable = asValidatableFormElement(event.target);
    if (validatable && (parentField == null ? void 0 : parentField.value) && props.useHtml5Validation) {
      event.preventDefault();
      let isFirstInvalid = false;
      if (validatable.form != null) {
        const formElements = validatable.form.elements;
        for (let i = 0; i < formElements.length; ++i) {
          const element2 = asValidatableFormElement(
            formElements.item(i)
          );
          if ((element2 == null ? void 0 : element2.willValidate) && !element2.validity.valid) {
            isFirstInvalid = validatable === element2;
            break;
          }
        }
      }
      if (isFirstInvalid) {
        const fieldElement = parentField.value.$el;
        const invalidHandler = getOption("invalidHandler");
        if (invalidHandler instanceof Function) {
          invalidHandler(validatable, fieldElement);
        } else {
          const canScrollToField = fieldElement ? fieldElement.scrollIntoView != void 0 : false;
          validatable.focus({ preventScroll: canScrollToField });
          if (canScrollToField) {
            fieldElement.scrollIntoView({ block: "nearest" });
          }
        }
      }
    }
    emits("invalid", event);
  }
  if (!isSSR) {
    const onAttributeChange = () => {
      if (!isValid.value)
        checkHtml5Validity();
    };
    let validationAttributeObserver = null;
    watch(
      [maybeElement, isValid, () => props.useHtml5Validation],
      (data) => {
        const el = data[0];
        const valid = data[1];
        const useValidation = data[2];
        if (validationAttributeObserver != null) {
          if (validationAttributeObserver.takeRecords().length > 0) {
            onAttributeChange();
          }
          validationAttributeObserver.disconnect();
        }
        if (!isDefined(el) || valid || !useValidation) {
          return;
        }
        if (validationAttributeObserver == null) {
          validationAttributeObserver = new MutationObserver(
            onAttributeChange
          );
        }
        validationAttributeObserver.observe(el, {
          attributeFilter: constraintValidationAttributes
        });
        let ancestor = el;
        while (ancestor = ancestor.parentNode) {
          if (ancestor instanceof HTMLFieldSetElement) {
            validationAttributeObserver.observe(ancestor, {
              attributeFilter: ["disabled"]
            });
          }
        }
      },
      { immediate: true }
    );
  }
  return {
    input: element,
    isFocused,
    isValid,
    setFocus,
    doClick,
    onFocus,
    onBlur,
    checkHtml5Validity,
    onInvalid
  };
}
export {
  useInputHandler as u
};
//# sourceMappingURL=useInputHandler-CIYFU5no.mjs.map
