{"version":3,"file":"defineClasses-D0J9_rOy.mjs","sources":["../../src/composables/defineClasses.ts"],"sourcesContent":["import {\n    ref,\n    watch,\n    isRef,\n    toValue,\n    getCurrentInstance,\n    effectScope,\n    onScopeDispose,\n    getCurrentScope,\n    type MaybeRefOrGetter,\n    type Ref,\n    type ComponentInternalInstance,\n} from \"vue\";\n\nimport { getOptions } from \"@/utils/config\";\nimport { isDefined, blankIfUndefined, getValueByPath } from \"@/utils/helpers\";\n\nimport type {\n    ClassBind,\n    ClassDefinition,\n    ComponentProps,\n    TransformFunction,\n} from \"@/types\";\n\n// named tuple as prop definition\ntype ComputedClass = readonly [\n    className: string,\n    defaultClass: string,\n    suffix?: MaybeRefOrGetter<string>,\n    apply?: MaybeRefOrGetter<boolean>,\n];\n\n/** Helperfunction to get all active classes from a class binding list */\nexport const getActiveClasses = (classes: ClassBind[]): string[] => {\n    if (!classes) return [];\n    return classes.flatMap((bind) =>\n        Object.keys(bind).filter((key) => key && bind[key]),\n    );\n};\n\n/**\n * Calculate dynamic classes based on class definitions\n */\nexport function defineClasses(\n    ...classDefinitions: ComputedClass[]\n): Ref<ClassBind[]> {\n    // getting a hold of the internal instance of the component in setup()\n    const vm = getCurrentInstance();\n    if (!vm)\n        throw new Error(\n            \"defineClasses must be called within a component setup function.\",\n        );\n\n    // create an effect scope object to capture reactive effects\n    const scope = effectScope();\n\n    // reactive classes container\n    const classes = ref<ClassBind[]>([]);\n\n    classes.value = classDefinitions.map((defintion, index) => {\n        const className = defintion[0];\n        const defaultClass = defintion[1];\n        const suffix = defintion[2];\n        const apply = defintion[3];\n\n        function getClassBind(): ClassBind {\n            // compute class based on definition parameter\n            const computedClass = computeClass(\n                vm,\n                className,\n                defaultClass,\n                toValue(suffix),\n            );\n\n            // if apply is not defined or true\n            const applied = !isDefined(apply) || toValue(apply);\n\n            // return class bind property\n            return { [computedClass]: applied };\n        }\n\n        // if suffix is defined, watch suffix changed and recalculate class\n        if (isDefined(suffix) && isRef(suffix)) {\n            scope.run(() => {\n                watch(\n                    () => toValue(suffix),\n                    (value, oldValue) => {\n                        // only recompute when value has really changed\n                        if (value === oldValue) return;\n                        // recompute the class bind property\n                        const classBind = getClassBind();\n                        // update class binding property by class index\n                        classes.value[index] = classBind;\n                    },\n                );\n            });\n        }\n\n        // if apply is defined, watch apply changed and update apply state (no need of recalculation here)\n        if (isDefined(apply) && isRef(apply)) {\n            scope.run(() => {\n                watch(\n                    () => toValue(apply),\n                    (applied, oldValue) => {\n                        // only change apply when value has really changed\n                        if (applied === oldValue) return;\n\n                        // get class binding property by class index\n                        const classBind = classes.value[index];\n\n                        // update the apply class binding state\n                        Object.keys(classBind).forEach(\n                            (key) => (classBind[key] = applied),\n                        );\n\n                        // update the class binding property by class index\n                        classes.value[index] = classBind;\n                    },\n                );\n            });\n        }\n\n        // return computed class based on parameter\n        return getClassBind();\n    });\n\n    // check if there is a current active effect scope\n    if (getCurrentScope())\n        // Registers a dispose callback on the current active effect scope.\n        // The callback will be invoked when the associated effect scope is stopped.\n        onScopeDispose(() => {\n            // stop all effects when appropriate\n            if (scope) scope.stop();\n        });\n\n    // return reactive classes\n    return classes;\n}\n\n/**\n * Compute a class by a field name\n */\nfunction computeClass(\n    vm: ComponentInternalInstance,\n    field: string,\n    defaultValue?: string,\n    suffix = \"\",\n): string {\n    // get component props\n    const props = getProps(vm).props; // TODO: remove `.props` when object escape get reverted\n\n    const configField = vm.proxy?.$options.configField;\n    if (!configField)\n        throw new Error(\"component must define the 'configField' option.\");\n\n    // get component instance override property\n    const config = props.override === true ? {} : getOptions();\n\n    // get global config override property\n    const globalOverride =\n        props.override || getValueByPath(config, \"override\", false);\n    // get component config override property\n    const localOverride = getValueByPath(\n        config,\n        `${configField}.override`,\n        globalOverride,\n    );\n    // get field specific config override property\n    const overrideClass = getValueByPath(\n        config,\n        `${configField}.${field}.override`,\n        localOverride,\n    );\n\n    // get global tranform class\n    const globalTransformClasses = getValueByPath<TransformFunction>(\n        config,\n        \"transformClasses\",\n        undefined,\n    );\n    // get field specific tranform class\n    const localTransformClasses = getValueByPath<TransformFunction>(\n        config,\n        `${configField}.transformClasses`,\n        undefined,\n    );\n\n    // get config class definition\n    let globalClass =\n        getValueByPath<ClassDefinition>(\n            config,\n            `${configField}.${field}.class`,\n            \"\",\n        ) ||\n        getValueByPath<ClassDefinition>(config, `${configField}.${field}`, \"\");\n    // get instance class override\n    let currentClass = getValueByPath<ClassDefinition>(props, field, \"\");\n\n    // procsess instance class\n    if (Array.isArray(currentClass)) {\n        currentClass = currentClass.join(\" \");\n    }\n    if (typeof currentClass === \"function\") {\n        const props = getProps(vm);\n        currentClass = currentClass(suffix, props);\n    } else {\n        currentClass = suffixProcessor(currentClass as string, suffix);\n    }\n\n    // process confic class\n    if (Array.isArray(globalClass)) {\n        globalClass = globalClass.join(\" \");\n    }\n    if (typeof globalClass === \"function\") {\n        const props = getProps(vm);\n        globalClass = globalClass(suffix, props);\n    } else {\n        globalClass = suffixProcessor(globalClass as string, suffix);\n    }\n\n    // process default value\n    if (defaultValue.includes(\"{*}\")) {\n        defaultValue = defaultValue.replace(\n            /\\{\\*\\}/g,\n            blankIfUndefined(suffix),\n        );\n    } else {\n        defaultValue = defaultValue + blankIfUndefined(suffix);\n    }\n\n    // if override is false add default value\n    // add global config classes\n    // add instance classes\n    let appliedClasses = (\n        `${!overrideClass ? defaultValue : \"\"} ` +\n        `${blankIfUndefined(globalClass)} ` +\n        `${blankIfUndefined(currentClass)}`\n    )\n        .trim()\n        .replace(/\\s\\s+/g, \" \");\n\n    // apply component local transformclass if available\n    if (localTransformClasses) {\n        appliedClasses = localTransformClasses(appliedClasses);\n    }\n    // else apply global transformclass if available\n    else if (globalTransformClasses) {\n        appliedClasses = globalTransformClasses(appliedClasses);\n    }\n\n    return appliedClasses;\n}\n\nfunction suffixProcessor(input: string, suffix: string): string {\n    return blankIfUndefined(input)\n        .split(\" \")\n        .filter((cls) => cls.length > 0)\n        .map((cls) => cls + blankIfUndefined(suffix))\n        .join(\" \");\n}\n\nconst getProps = (vm: ComponentInternalInstance): ComponentProps => {\n    let props = vm.proxy.$props;\n\n    // get all props which ends with \"Props\", these are compressed parent props\n    // append these parent props as root level prop\n    props = Object.keys(props)\n        .filter((key) => key.endsWith(\"Props\"))\n        .map((key) => props[key])\n        .reduce((a, b) => ({ ...a, ...b }), props);\n\n    // TODO: revert object escape\n    return { props };\n};\n"],"names":["props"],"mappings":"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"}