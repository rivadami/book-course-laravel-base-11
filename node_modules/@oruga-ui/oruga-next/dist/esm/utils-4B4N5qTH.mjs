/*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, mergeModels, computed, ref, watch, useModel, nextTick, useAttrs, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, createSlots, withCtx, createVNode, renderSlot, withKeys, unref } from "vue";
import { _ as _sfc_main$1, a as _sfc_main$2 } from "./DropdownItem.vue_vue_type_script_setup_true_lang-Dpj7m-LI.mjs";
import { _ as _sfc_main$3 } from "./Input.vue_vue_type_script_setup_true_lang-Bvc5alcQ.mjs";
import { isMobileAgent } from "./helpers.mjs";
import { i as isClient } from "./ssr-BtcosYqY.mjs";
import { g as getActiveClasses } from "./defineClasses-D0J9_rOy.mjs";
import { u as useEventListener } from "./useEventListener-DXZDse6S.mjs";
import { u as useInputHandler } from "./useInputHandler-CIYFU5no.mjs";
const _hoisted_1 = ["data-oruga"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    name: "OPickerWrapper"
  },
  __name: "PickerWrapper",
  props: /* @__PURE__ */ mergeModels({
    /** parent picker component props  */
    picker: { type: Object, required: true },
    /** data-oruga attribute value */
    dataOruga: { type: String, required: true },
    /** the internal input value */
    value: { type: [Date, Array], default: void 0 },
    /** the active state of the dropdown */
    active: { type: Boolean, default: false },
    /** formatted display value to show when client is desktop */
    formattedValue: { type: String, default: void 0 },
    /** native value when client is mobile native */
    nativeValue: { type: [String, Number], default: void 0 },
    nativeType: { type: String, required: true },
    nativeStep: { type: String, default: void 0 },
    nativeMin: { type: [String, Number], default: void 0 },
    nativeMax: { type: [String, Number], default: void 0 },
    stayOpen: { type: Boolean, default: false },
    rootClasses: {
      type: Array,
      required: true
    },
    dropdownClasses: {
      type: Array,
      required: true
    },
    boxClass: {
      type: Array,
      required: true
    }
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:active", "change", "native-change", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isMobileNative = computed(
      () => !props.picker.inline && props.picker.mobileNative && isMobileAgent.any()
    );
    const dropdownRef = ref();
    const inputRef = ref();
    const nativeInputRef = ref();
    const elementRef = computed(
      () => isMobileNative.value ? nativeInputRef.value : inputRef.value
    );
    const {
      input,
      checkHtml5Validity,
      setFocus,
      onBlur,
      onFocus,
      onInvalid,
      isValid
    } = useInputHandler(elementRef, emits, props.picker);
    const initialNativeType = !props.picker.placeholder || !!props.nativeValue ? props.nativeType : "text";
    const inputValue = computed(
      () => isMobileNative.value ? props.nativeValue : props.formattedValue
    );
    const vmodel = ref(inputValue.value);
    watch(inputValue, (value) => vmodel.value = value);
    watch(
      () => props.value,
      () => {
        if (vmodel.value !== inputValue.value)
          vmodel.value = inputValue.value;
        if (!isMobileNative.value && !props.stayOpen)
          togglePicker(false);
        if (!isValid.value)
          checkHtml5Validity();
      },
      { flush: "post" }
    );
    const isActive = useModel(__props, "active");
    watch(isActive, onActiveChange);
    const ariaRole = computed(() => !props.picker.inline ? "dialog" : void 0);
    const triggers = computed(() => props.picker.openOnFocus ? ["click"] : []);
    if (isClient)
      useEventListener("keyup", onKeyPress);
    function onKeyPress(event) {
      if (isActive.value && (event.key === "Escape" || event.key === "Esc"))
        togglePicker(false);
    }
    function togglePicker(active) {
      if (dropdownRef.value) {
        if (active || props.picker.closeOnClick)
          nextTick(() => isActive.value = active);
      }
    }
    function onInputClick(event) {
      if (isActive.value)
        event.stopPropagation();
    }
    function onActiveChange(value) {
      if (value)
        onFocus();
      else if (!value)
        onBlur();
    }
    function onNativeClick(event) {
      if (!isMobileNative.value)
        return;
      if (input.value.type === "text") {
        event.preventDefault();
        event.stopPropagation();
        input.value.blur();
        setTimeout(() => {
          input.value.readOnly = false;
          input.value.type = props.nativeType;
          setFocus();
        }, 50);
      }
    }
    function onNativeFocus(event) {
      if (!isMobileNative.value)
        return;
      if (input.value.type === "text") {
        event.preventDefault();
        event.stopPropagation();
      } else
        onFocus();
    }
    function onNativeBlur() {
      if (!isMobileNative.value)
        return;
      if (!input.value.value) {
        input.value.readOnly = true;
        input.value.type = "text";
      }
      onBlur();
    }
    function handleNativeChange(event) {
      const value = event.target.value ? event.target.value : null;
      if (!value) {
        input.value.value = value;
        input.value.blur();
      }
      emits("native-change", value);
    }
    const attrs = useAttrs();
    const inputBind = computed(() => ({
      ...attrs,
      ...props.picker.inputClasses
    }));
    const dropdownBind = computed(() => ({
      "root-class": getActiveClasses(props.dropdownClasses),
      ...props.picker.dropdownClasses
    }));
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": __props.dataOruga,
        class: normalizeClass(__props.rootClasses),
        onClick: onNativeClick
      }, [
        !isMobileNative.value ? (openBlock(), createBlock(_sfc_main$1, mergeProps({
          key: 0,
          ref_key: "dropdownRef",
          ref: dropdownRef
        }, dropdownBind.value, {
          active: isActive.value,
          "onUpdate:active": _cache[5] || (_cache[5] = ($event) => isActive.value = $event),
          position: __props.picker.position,
          disabled: __props.picker.disabled,
          inline: __props.picker.inline,
          "mobile-modal": __props.picker.mobileModal,
          "trap-focus": __props.picker.trapFocus,
          "aria-role": ariaRole.value,
          "aria-modal": !__props.picker.inline,
          tabindex: -1,
          teleport: __props.picker.teleport,
          triggers: triggers.value
        }), createSlots({
          default: withCtx(() => [
            createVNode(_sfc_main$2, {
              override: "",
              tag: "div",
              "item-class": __props.boxClass,
              disabled: __props.picker.disabled,
              clickable: false
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["item-class", "disabled"])
          ]),
          _: 2
        }, [
          !__props.picker.inline ? {
            name: "trigger",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "trigger", {}, () => [
                createVNode(_sfc_main$3, mergeProps({
                  ref_key: "inputRef",
                  ref: inputRef
                }, inputBind.value, {
                  modelValue: vmodel.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
                  autocomplete: "off",
                  placeholder: __props.picker.placeholder,
                  size: __props.picker.size,
                  "icon-pack": __props.picker.iconPack,
                  icon: __props.picker.icon,
                  "icon-right": __props.picker.iconRight,
                  "icon-right-clickable": __props.picker.iconRightClickable,
                  expanded: __props.picker.expanded,
                  rounded: __props.picker.rounded,
                  disabled: __props.picker.disabled,
                  readonly: __props.picker.readonly,
                  "use-html5-validation": false,
                  onClick: onInputClick,
                  onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => togglePicker(true), ["enter"])),
                  onChange: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("change", $event.target.value)),
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur),
                  onIconClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("icon-click", $event)),
                  onIconRightClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("icon-right-click", $event))
                }), null, 16, ["modelValue", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "expanded", "rounded", "disabled", "readonly", "onFocus", "onBlur"])
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["active", "position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "aria-modal", "teleport", "triggers"])) : renderSlot(_ctx.$slots, "trigger", { key: 1 }, () => [
          createVNode(_sfc_main$3, mergeProps({
            ref_key: "nativeInputRef",
            ref: nativeInputRef
          }, inputBind.value, {
            modelValue: vmodel.value,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => vmodel.value = $event),
            type: unref(initialNativeType),
            min: __props.nativeMin,
            max: __props.nativeMax,
            step: __props.nativeStep,
            placeholder: __props.picker.placeholder,
            size: __props.picker.size,
            "icon-pack": __props.picker.iconPack,
            icon: __props.picker.icon,
            "icon-right": __props.picker.iconRight,
            "icon-right-clickable": __props.picker.iconRightClickable,
            rounded: __props.picker.rounded,
            disabled: __props.picker.disabled,
            readonly: unref(initialNativeType) == "text",
            autocomplete: "off",
            "use-html5-validation": false,
            onChange: handleNativeChange,
            onFocus: onNativeFocus,
            onBlur: onNativeBlur,
            onInvalid: unref(onInvalid),
            onIconClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("icon-click", $event)),
            onIconRightClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("icon-right-click", $event))
          }), null, 16, ["modelValue", "type", "min", "max", "step", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "rounded", "disabled", "readonly", "onInvalid"])
        ])
      ], 10, _hoisted_1);
    };
  }
});
function getMonthNames(locale = void 0, format = "long") {
  const dates = [];
  for (let i = 0; i < 12; i++) {
    dates.push(new Date(2e3, i, 15));
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    month: format
    // timeZone: 'UTC'
  });
  return dates.map((d) => dtf.format(d));
}
function getWeekdayNames(locale = void 0, firstDayOfWeek = 0, format = "narrow") {
  const dates = [];
  for (let i = 1, j = 0; j < 7; i++) {
    const d = new Date(2e3, 0, i);
    const day = d.getDay();
    if (day === firstDayOfWeek || j > 0) {
      dates.push(d);
      j++;
    }
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    weekday: format
    // timeZone: 'UTC'
  });
  return dates.map((d) => dtf.format(d));
}
function matchWithGroups(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g).map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)[1];
  }).reduce((acc, curr, index) => {
    if (matches && matches.length > index) {
      acc[curr] = matches[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function weekBuilder(startingDate, month, year, firstDayOfWeek) {
  const thisMonth = new Date(year, month);
  const thisWeek = [];
  const dayOfWeek = new Date(year, month, startingDate).getDay();
  const end = dayOfWeek >= firstDayOfWeek ? dayOfWeek - firstDayOfWeek : 7 - firstDayOfWeek + dayOfWeek;
  let daysAgo = 1;
  for (let i = 0; i < end; i++) {
    thisWeek.unshift(
      new Date(
        thisMonth.getFullYear(),
        thisMonth.getMonth(),
        startingDate - daysAgo
      )
    );
    daysAgo++;
  }
  thisWeek.push(new Date(year, month, startingDate));
  let daysForward = 1;
  while (thisWeek.length < 7) {
    thisWeek.push(new Date(year, month, startingDate + daysForward));
    daysForward++;
  }
  return thisWeek;
}
function firstWeekOffset(year, dow, doy) {
  const fwd = 7 + dow - doy;
  const firstJanuary = new Date(year, 0, fwd);
  const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function daysInYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0 ? 366 : 365;
}
function weeksInYear(year, dow, doy) {
  const weekOffset = firstWeekOffset(year, dow, doy);
  const weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
export {
  _sfc_main as _,
  weekBuilder as a,
  getWeekdayNames as b,
  firstWeekOffset as f,
  getMonthNames as g,
  matchWithGroups as m,
  weeksInYear as w
};
//# sourceMappingURL=utils-4B4N5qTH.mjs.map
