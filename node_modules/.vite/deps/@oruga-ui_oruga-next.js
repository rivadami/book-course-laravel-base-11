import {
  Comment,
  Fragment,
  Teleport,
  Text,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  readonly,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toValue,
  unref,
  useAttrs,
  useModel,
  useSlots,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-7FD7R2S7.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@oruga-ui/oruga-next/dist/esm/helpers.mjs
var uuid = () => Math.random().toString(36).substring(2, 15);
function signPoly(value) {
  if (value < 0)
    return -1;
  return value > 0 ? 1 : 0;
}
var sign = Math.sign || signPoly;
var mod = (n, mod2) => (n % mod2 + mod2) % mod2;
function bound(val, min, max) {
  return Math.max(min, Math.min(max, val));
}
var isObject = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
var isDate = (d) => d && d instanceof Date && !isNaN(d.getTime());
var isDefined = (d) => d !== null && d !== void 0;
var blankIfUndefined = (value) => typeof value !== "undefined" && value !== null ? value : "";
var toCssDimension = (width) => !isDefined(width) ? null : isNaN(width) ? width : width + "px";
function indexOf(array, obj, fn) {
  if (!array)
    return -1;
  if (!fn || typeof fn !== "function")
    return array.indexOf(obj);
  return array.findIndex((value, index30, arr) => fn(value, arr));
}
function isEqual(valueA, valueB) {
  if (!valueA && !!valueB || !!valueA && !valueB)
    return false;
  if (valueA === valueB)
    return true;
  if (isObject(valueA) && isObject(valueB)) {
    const keys1 = Object.keys(valueA);
    const keys2 = Object.keys(valueB);
    if (keys1.length !== keys2.length)
      return false;
    for (const key of keys1) {
      const val1 = valueA[key];
      const val2 = valueB[key];
      const areObjects = isObject(val1) && isObject(val2);
      if (areObjects && !isEqual(val1, val2) || !areObjects && val1 !== val2)
        return false;
    }
    return true;
  }
  if (Array.isArray(valueA) && Array.isArray(valueB)) {
    if (valueA.length !== valueB.length)
      return false;
    if (!valueA.every((val, index30) => val === valueB[index30]))
      return false;
    return true;
  }
  return false;
}
function clone(obj) {
  return Object.assign({}, obj);
}
function merge(target, source, deep = false) {
  if (!isObject(target) || !isObject(source))
    return source;
  if (!deep)
    return Object.assign(target, source);
  else
    return mergeDeep(target, source);
}
function mergeDeep(target, source) {
  if (!isObject(target) || !isObject(source))
    return source;
  Object.getOwnPropertyNames(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
      target[key] = targetValue.concat(sourceValue);
    } else if (isObject(targetValue) && isObject(sourceValue)) {
      target[key] = mergeDeep(
        Object.assign({}, targetValue),
        sourceValue
      );
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
}
function getValueByPath(obj, path, defaultValue) {
  const value = path.split(".").reduce(
    (o, i) => typeof o !== "undefined" ? o[i] : void 0,
    obj
  );
  return typeof value !== "undefined" ? value : defaultValue;
}
function setValueByPath(obj, path, value) {
  const p = path.split(".");
  if (p.length === 1) {
    obj[path] = value;
    return;
  }
  const field = p[0];
  if (typeof obj[field] === "undefined")
    obj[field] = {};
  return setValueByPath(obj[field], p.slice(1).join("."), value);
}
function removeElement(el) {
  if (typeof el.remove !== "undefined") {
    el.remove();
  } else if (typeof el.parentNode !== "undefined" && el.parentNode !== null) {
    el.parentNode.removeChild(el);
  }
}
function escapeRegExpChars(value) {
  if (!value)
    return value;
  return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function removeDiacriticsFromString(value) {
  if (!value)
    return value;
  return value.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function isVNodeEmpty(vnode) {
  if (!vnode)
    return true;
  if (vnode.type === Comment)
    return true;
  if (vnode.type === Text && !vnode.children.trim())
    return true;
  if (vnode.type === Fragment && isVNodeEmpty(vnode.children))
    return true;
  return false;
}
var isMobileAgent = {
  Android: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/Android/i),
  BlackBerry: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/BlackBerry/i),
  iOS: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/iPhone|iPad|iPod/i),
  Opera: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/Opera Mini/i),
  Windows: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/IEMobile/i),
  any: () => isMobileAgent.Android() || isMobileAgent.BlackBerry() || isMobileAgent.iOS() || isMobileAgent.Opera() || isMobileAgent.Windows()
};

// node_modules/@oruga-ui/oruga-next/dist/esm/config-C1k5NuG7.mjs
var oruga = ref({});
function addProgrammatic(property, component) {
  oruga.value[property] = component;
}
function useOruga() {
  return oruga.value;
}
var VueInstance;
var setVueInstance = (Vue) => {
  VueInstance = Vue;
};
var registerPlugin = (app, plugin2) => {
  app.use(plugin2);
};
var registerComponent = (app, component) => {
  app.component(component.name, component);
};
var registerComponentProgrammatic = (app, property, component) => {
  setVueInstance(app);
  const oruga2 = useOruga();
  addProgrammatic(property, component);
  if (!(app._context.provides && app._context.provides.oruga))
    app.provide("oruga", oruga2);
  if (!app.config.globalProperties.$oruga)
    app.config.globalProperties.$oruga = oruga2;
};
var globalOptions = ref({
  iconPack: "mdi",
  useHtml5Validation: true,
  statusIcon: true,
  transformClasses: void 0
});
var setOptions = (options) => {
  globalOptions.value = options;
};
var getOptions = () => {
  return clone(toRaw(globalOptions.value));
};
var getOption = (path, defaultValue) => {
  return getValueByPath(globalOptions.value, path, defaultValue);
};
var setOption = (path, defaultValue) => {
  setValueByPath(globalOptions.value, path, defaultValue);
};
var ConfigProgrammatic = {
  getOption,
  getOptions,
  setOption,
  setOptions(options) {
    setOptions(merge(getOptions(), options, true));
  }
};
var OrugaConfig = {
  install(app, options) {
    setVueInstance(app);
    setOptions(merge(getOptions(), options, true));
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/defineClasses-D0J9_rOy.mjs
var getActiveClasses = (classes) => {
  if (!classes)
    return [];
  return classes.flatMap(
    (bind2) => Object.keys(bind2).filter((key) => key && bind2[key])
  );
};
function defineClasses(...classDefinitions) {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "defineClasses must be called within a component setup function."
    );
  const scope = effectScope();
  const classes = ref([]);
  classes.value = classDefinitions.map((defintion, index30) => {
    const className = defintion[0];
    const defaultClass = defintion[1];
    const suffix = defintion[2];
    const apply = defintion[3];
    function getClassBind() {
      const computedClass = computeClass(
        vm,
        className,
        defaultClass,
        toValue(suffix)
      );
      const applied = !isDefined(apply) || toValue(apply);
      return { [computedClass]: applied };
    }
    if (isDefined(suffix) && isRef(suffix)) {
      scope.run(() => {
        watch(
          () => toValue(suffix),
          (value, oldValue) => {
            if (value === oldValue)
              return;
            const classBind = getClassBind();
            classes.value[index30] = classBind;
          }
        );
      });
    }
    if (isDefined(apply) && isRef(apply)) {
      scope.run(() => {
        watch(
          () => toValue(apply),
          (applied, oldValue) => {
            if (applied === oldValue)
              return;
            const classBind = classes.value[index30];
            Object.keys(classBind).forEach(
              (key) => classBind[key] = applied
            );
            classes.value[index30] = classBind;
          }
        );
      });
    }
    return getClassBind();
  });
  if (getCurrentScope())
    onScopeDispose(() => {
      if (scope)
        scope.stop();
    });
  return classes;
}
function computeClass(vm, field, defaultValue, suffix = "") {
  var _a;
  const props = getProps(vm).props;
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  if (!configField)
    throw new Error("component must define the 'configField' option.");
  const config = props.override === true ? {} : getOptions();
  const globalOverride = props.override || getValueByPath(config, "override", false);
  const localOverride = getValueByPath(
    config,
    `${configField}.override`,
    globalOverride
  );
  const overrideClass = getValueByPath(
    config,
    `${configField}.${field}.override`,
    localOverride
  );
  const globalTransformClasses = getValueByPath(
    config,
    "transformClasses",
    void 0
  );
  const localTransformClasses = getValueByPath(
    config,
    `${configField}.transformClasses`,
    void 0
  );
  let globalClass = getValueByPath(
    config,
    `${configField}.${field}.class`,
    ""
  ) || getValueByPath(config, `${configField}.${field}`, "");
  let currentClass = getValueByPath(props, field, "");
  if (Array.isArray(currentClass)) {
    currentClass = currentClass.join(" ");
  }
  if (typeof currentClass === "function") {
    const props2 = getProps(vm);
    currentClass = currentClass(suffix, props2);
  } else {
    currentClass = suffixProcessor(currentClass, suffix);
  }
  if (Array.isArray(globalClass)) {
    globalClass = globalClass.join(" ");
  }
  if (typeof globalClass === "function") {
    const props2 = getProps(vm);
    globalClass = globalClass(suffix, props2);
  } else {
    globalClass = suffixProcessor(globalClass, suffix);
  }
  if (defaultValue.includes("{*}")) {
    defaultValue = defaultValue.replace(
      /\{\*\}/g,
      blankIfUndefined(suffix)
    );
  } else {
    defaultValue = defaultValue + blankIfUndefined(suffix);
  }
  let appliedClasses = `${!overrideClass ? defaultValue : ""} ${blankIfUndefined(globalClass)} ${blankIfUndefined(currentClass)}`.trim().replace(/\s\s+/g, " ");
  if (localTransformClasses) {
    appliedClasses = localTransformClasses(appliedClasses);
  } else if (globalTransformClasses) {
    appliedClasses = globalTransformClasses(appliedClasses);
  }
  return appliedClasses;
}
function suffixProcessor(input, suffix) {
  return blankIfUndefined(input).split(" ").filter((cls) => cls.length > 0).map((cls) => cls + blankIfUndefined(suffix)).join(" ");
}
var getProps = (vm) => {
  let props = vm.proxy.$props;
  props = Object.keys(props).filter((key) => key.endsWith("Props")).map((key) => props[key]).reduce((a, b) => ({ ...a, ...b }), props);
  return { props };
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Icon.vue_vue_type_script_setup_true_lang-BiTdOP-d.mjs
var mdiIcons = {
  sizes: {
    default: "mdi-24px",
    small: null,
    medium: "mdi-36px",
    large: "mdi-48px"
  },
  iconPrefix: "mdi-"
};
var faIcons = () => {
  const iconComponent = getOption("iconComponent");
  const faIconPrefix = iconComponent ? "" : "fa-";
  return {
    sizes: {
      default: null,
      small: null,
      medium: "lg",
      large: "2xl"
    },
    iconPrefix: faIconPrefix,
    internalIcons: {
      check: "check",
      information: "info-circle",
      alert: "exclamation-triangle",
      "alert-circle": "exclamation-circle",
      "arrow-up": "arrow-up",
      "chevron-right": "angle-right",
      "chevron-left": "angle-left",
      "chevron-down": "angle-down",
      "chevron-up": "angle-up",
      eye: "eye",
      "eye-off": "eye-slash",
      "caret-down": "caret-down",
      "caret-up": "caret-up",
      "close-circle": "times-circle",
      close: "times",
      loading: "circle-notch"
    }
  };
};
var getIcons = () => {
  let icons = {
    mdi: mdiIcons,
    fa: faIcons(),
    fas: faIcons(),
    far: faIcons(),
    fad: faIcons(),
    fab: faIcons(),
    fal: faIcons()
  };
  const customIconPacks = getOption("customIconPacks");
  if (customIconPacks)
    icons = merge(icons, customIconPacks, true);
  return icons;
};
var getIcons$1 = getIcons;
var _sfc_main = defineComponent({
  ...{
    isOruga: true,
    name: "OIcon",
    configField: "icon"
  },
  __name: "Icon",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Icon component name */
    component: {
      type: String,
      default: () => getOption("iconComponent")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    pack: {
      type: String,
      default: () => getOption("iconPack", "mdi")
    },
    /**
     * 	Color of the icon
     *  @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("icon.variant")
    },
    /** Icon name */
    icon: { type: String, default: void 0 },
    /**
     * Icon size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("icon.size")
    },
    /**
     * Overrides icon font size
     * @values Depends on library: null (smallest), fa-sm, fa-lg, fa-xl, mdi-18px, mdi-24px, mdi-36px, mdi-48px
     */
    customSize: { type: String, default: void 0 },
    /**
     * Add class to icon font.
     * See icon library documentation for custom classes.
     */
    customClass: { type: String, default: void 0 },
    /** When true makes icon clickable */
    clickable: { type: Boolean, default: false },
    /** Enable spin effect on icon */
    spin: { type: Boolean, default: false },
    /** Rotation 0-360 */
    rotation: { type: [Number, String], default: void 0 },
    /**
     * This is used internally
     * @ignore
     */
    both: { type: Boolean, default: false },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon when clickable */
    clickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the element when spin */
    spinClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const rootStyle = computed(() => {
      const style = {};
      if (props.rotation) {
        style["transform"] = `rotate(${props.rotation}deg)`;
      }
      return style;
    });
    const iconConfig = computed(() => getIcons$1()[props.pack]);
    const iconPrefix = computed(
      () => {
        var _a;
        return ((_a = iconConfig.value) == null ? void 0 : _a.iconPrefix) ? iconConfig.value.iconPrefix : "";
      }
    );
    const customSizeByPack = computed(() => {
      var _a;
      if ((_a = iconConfig.value) == null ? void 0 : _a.sizes) {
        if (props.size && iconConfig.value.sizes[props.size] !== void 0) {
          return iconConfig.value.sizes[props.size];
        } else if (iconConfig.value.sizes.default) {
          return iconConfig.value.sizes.default;
        }
      }
      return null;
    });
    const computedIcon = computed(
      () => `${iconPrefix.value}${getEquivalentIconOf(props.icon)}`
    );
    const computedSize = computed(() => props.customSize || customSizeByPack.value);
    const computedVariant = computed(() => {
      if (!props.variant)
        return;
      let newVariant = "";
      if (typeof props.variant === "string") {
        newVariant = props.variant;
      } else {
        newVariant = Object.keys(props.variant).filter(
          (key) => props.variant[key]
        )[0];
      }
      return newVariant;
    });
    function getEquivalentIconOf(value) {
      var _a, _b;
      if (!props.both)
        return value;
      if (((_a = iconConfig.value) == null ? void 0 : _a.internalIcons) && ((_b = iconConfig.value) == null ? void 0 : _b.internalIcons[value]))
        return iconConfig.value.internalIcons[value];
      return value;
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-icon"],
      [
        "clickableClass",
        "o-icon--clickable",
        null,
        computed(() => props.clickable)
      ],
      ["spinClass", "o-icon--spin", null, computed(() => props.spin)],
      [
        "sizeClass",
        "o-icon--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "variantClass",
        "o-icon--",
        computedVariant,
        computed(() => !!computedVariant.value)
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "icon",
        style: normalizeStyle(rootStyle.value)
      }, [
        __props.component ? (openBlock(), createBlock(resolveDynamicComponent(__props.component), {
          key: 0,
          icon: [__props.pack, computedIcon.value],
          size: computedSize.value,
          class: normalizeClass([__props.customClass])
        }, null, 8, ["icon", "size", "class"])) : (openBlock(), createElementBlock("i", {
          key: 1,
          class: normalizeClass([__props.pack, computedIcon.value, computedSize.value, __props.customClass])
        }, null, 2))
      ], 6);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/fieldInjection-B9PE5wx6.mjs
var $FieldKey = Symbol("FielData");
function provideField(data) {
  provide($FieldKey, data);
}
function injectField() {
  const parentField = inject($FieldKey, void 0);
  const statusVariant = computed(() => {
    var _a;
    if (!((_a = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a.fieldVariant))
      return void 0;
    if (typeof parentField.value.fieldVariant === "string")
      return parentField.value.fieldVariant;
    if (Array.isArray(parentField.value.fieldVariant)) {
      for (const key in parentField.value.fieldVariant) {
        if (parentField.value.fieldVariant[key])
          return key;
      }
    }
    return void 0;
  });
  const statusMessage = computed(
    () => {
      var _a;
      return ((_a = parentField.value) == null ? void 0 : _a.hasMessage) ? parentField.value.fieldMessage : "";
    }
  );
  const statusVariantIcon = computed(() => {
    const statusVariantIcon2 = getOption("statusVariantIcon", {
      success: "check",
      danger: "alert-circle",
      info: "information",
      warning: "alert"
    });
    return statusVariantIcon2[statusVariant.value] || "";
  });
  return {
    parentField,
    statusVariant,
    statusVariantIcon,
    statusMessage
  };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/unrefElement-DtCqBtLW.mjs
function unrefElement(elRef) {
  const plain = toValue(elRef);
  return (plain == null ? void 0 : plain.$el) ?? plain;
}

// node_modules/@oruga-ui/oruga-next/dist/esm/ssr-BtcosYqY.mjs
var isClient = typeof window !== "undefined";
var isSSR = typeof window === "undefined";

// node_modules/@oruga-ui/oruga-next/dist/esm/useInputHandler-CIYFU5no.mjs
var validatableFormElementTypes = isSSR ? [] : [
  HTMLButtonElement,
  HTMLFieldSetElement,
  HTMLInputElement,
  HTMLObjectElement,
  HTMLOutputElement,
  HTMLSelectElement,
  HTMLTextAreaElement
];
function asValidatableFormElement(el) {
  return validatableFormElementTypes.some((t) => el instanceof t) ? el : null;
}
var constraintValidationAttributes = [
  "disabled",
  "required",
  "pattern",
  "maxlength",
  "minlength",
  "max",
  "min",
  "step"
];
function useInputHandler(inputRef, emits, props) {
  const { parentField } = injectField();
  const maybeElement = computed(() => {
    const el = unrefElement(inputRef);
    if (!el) {
      return void 0;
    }
    if (el.getAttribute("data-oruga-input"))
      return el;
    const inputs = el.querySelector("[data-oruga-input]");
    if (!inputs) {
      console.warn(
        "useInputHandler: Underlaying Oruga input component not found"
      );
      return void 0;
    }
    return inputs;
  });
  const element = computed(() => {
    const el = maybeElement.value;
    if (!el) {
      console.warn("useInputHandler: inputRef contains no element");
    }
    return el;
  });
  const isFocused = ref(false);
  function setFocus() {
    nextTick(() => {
      if (element.value)
        element.value.focus();
    });
  }
  function doClick() {
    nextTick(() => {
      if (element.value)
        element.value.click();
    });
  }
  function onBlur(event) {
    isFocused.value = false;
    if (parentField == null ? void 0 : parentField.value)
      parentField.value.setFocus(false);
    emits("blur", event);
    checkHtml5Validity();
  }
  function onFocus(event) {
    isFocused.value = true;
    if (parentField == null ? void 0 : parentField.value)
      parentField.value.setFocus(true);
    emits("focus", event);
  }
  const isValid = ref(true);
  function setFieldValidity(variant, message) {
    nextTick(() => {
      if (parentField == null ? void 0 : parentField.value) {
        if (!parentField.value.props.variant) {
          parentField.value.setVariant(variant);
        }
        if (!parentField.value.props.message) {
          parentField.value.setMessage(message);
        }
      }
    });
  }
  function checkHtml5Validity() {
    if (!props.useHtml5Validation)
      return;
    if (!element.value)
      return;
    if (element.value.validity.valid) {
      setFieldValidity(null, null);
      isValid.value = true;
    } else {
      setInvalid();
      isValid.value = false;
    }
  }
  function setInvalid() {
    const variant = "danger";
    const message = props.validationMessage || element.value.validationMessage;
    setFieldValidity(variant, message);
  }
  function onInvalid(event) {
    checkHtml5Validity();
    const validatable = asValidatableFormElement(event.target);
    if (validatable && (parentField == null ? void 0 : parentField.value) && props.useHtml5Validation) {
      event.preventDefault();
      let isFirstInvalid = false;
      if (validatable.form != null) {
        const formElements = validatable.form.elements;
        for (let i = 0; i < formElements.length; ++i) {
          const element2 = asValidatableFormElement(
            formElements.item(i)
          );
          if ((element2 == null ? void 0 : element2.willValidate) && !element2.validity.valid) {
            isFirstInvalid = validatable === element2;
            break;
          }
        }
      }
      if (isFirstInvalid) {
        const fieldElement = parentField.value.$el;
        const invalidHandler = getOption("invalidHandler");
        if (invalidHandler instanceof Function) {
          invalidHandler(validatable, fieldElement);
        } else {
          const canScrollToField = fieldElement ? fieldElement.scrollIntoView != void 0 : false;
          validatable.focus({ preventScroll: canScrollToField });
          if (canScrollToField) {
            fieldElement.scrollIntoView({ block: "nearest" });
          }
        }
      }
    }
    emits("invalid", event);
  }
  if (!isSSR) {
    const onAttributeChange = () => {
      if (!isValid.value)
        checkHtml5Validity();
    };
    let validationAttributeObserver = null;
    watch(
      [maybeElement, isValid, () => props.useHtml5Validation],
      (data) => {
        const el = data[0];
        const valid = data[1];
        const useValidation = data[2];
        if (validationAttributeObserver != null) {
          if (validationAttributeObserver.takeRecords().length > 0) {
            onAttributeChange();
          }
          validationAttributeObserver.disconnect();
        }
        if (!isDefined(el) || valid || !useValidation) {
          return;
        }
        if (validationAttributeObserver == null) {
          validationAttributeObserver = new MutationObserver(
            onAttributeChange
          );
        }
        validationAttributeObserver.observe(el, {
          attributeFilter: constraintValidationAttributes
        });
        let ancestor = el;
        while (ancestor = ancestor.parentNode) {
          if (ancestor instanceof HTMLFieldSetElement) {
            validationAttributeObserver.observe(ancestor, {
              attributeFilter: ["disabled"]
            });
          }
        }
      },
      { immediate: true }
    );
  }
  return {
    input: element,
    isFocused,
    isValid,
    setFocus,
    doClick,
    onFocus,
    onBlur,
    checkHtml5Validity,
    onInvalid
  };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/Input.vue_vue_type_script_setup_true_lang-Bvc5alcQ.mjs
var _hoisted_1 = ["id", "data-oruga-input", "type", "maxlength", "autocomplete", "placeholder", "disabled"];
var _hoisted_2 = ["id", "maxlength", "placeholder", "disabled"];
var _sfc_main2 = defineComponent({
  ...{
    isOruga: true,
    name: "OInput",
    configField: "input",
    inheritAttrs: false
  },
  __name: "Input",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: "" },
    /**
     * Input type, like native
     * @values Any native input type, and textarea
     */
    type: { type: String, default: "text" },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("input.size")
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("input.variant")
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: false },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Adds the reveal password functionality */
    passwordReveal: { type: Boolean, default: false },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: [Number, String], default: void 0 },
    /** Show character counter when maxlength prop is passed */
    counter: {
      type: Boolean,
      default: () => getOption("input.counter", false)
    },
    /** Automatically adjust height in textarea */
    autosize: { type: Boolean, default: false },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("input.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("input.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: false },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("input.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Add a button/icon to clear the inputed text */
    clearable: {
      type: Boolean,
      default: () => getOption("input.clearable", false)
    },
    /** Icon name to be added on the clear button */
    clearIcon: {
      type: String,
      default: () => getOption("input.clearIcon", "close-circle")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => getOption("statusIcon", true)
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("input.autocomplete", "off")
    },
    /** Same as native id. Also set the for label for o-field wrapper. */
    id: { type: String, default: () => uuid() },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when type textarea */
    textareaClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon space inside the input */
    iconLeftSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon space inside the input */
    iconRightSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class to display when a right icon is used */
    hasIconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the counter element */
    counterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "modelValue": { default: "" },
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "input", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    var _a;
    const props = __props;
    const emits = __emit;
    const inputRef = ref();
    const textareaRef = ref();
    const elementRef = computed(
      () => props.type === "textarea" ? textareaRef.value : inputRef.value
    );
    const {
      checkHtml5Validity,
      onBlur,
      onFocus,
      onInvalid,
      setFocus,
      isValid,
      isFocused
    } = useInputHandler(elementRef, emits, props);
    const { parentField, statusVariant, statusVariantIcon } = injectField();
    const vmodel = useModel(__props, "modelValue");
    if (props.id)
      (_a = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a.setInputId(props.id);
    const valueLength = computed(
      () => typeof vmodel.value === "string" ? vmodel.value.length : typeof vmodel.value === "number" ? vmodel.value.toString().length : 0
    );
    onMounted(() => {
      watch(
        () => vmodel.value,
        (value) => {
          if (parentField == null ? void 0 : parentField.value)
            parentField.value.setFilled(!!value);
          if (props.autosize)
            resize();
          if (!isValid.value)
            nextTick(() => checkHtml5Validity());
        },
        { immediate: true }
      );
    });
    const height = ref("auto");
    function resize() {
      height.value = "auto";
      nextTick(() => {
        if (!textareaRef.value)
          return;
        const scrollHeight = textareaRef.value.scrollHeight;
        height.value = scrollHeight + "px";
      });
    }
    const computedStyles = computed(
      () => props.autosize ? {
        resize: "none",
        height: height.value,
        overflow: "hidden"
      } : {}
    );
    function onInput(event) {
      emits("input", event.target.value, event);
    }
    const hasIconRight = computed(() => {
      return !!(props.passwordReveal || props.statusIcon && statusVariantIcon.value || props.clearable && vmodel.value && props.clearIcon || props.iconRight);
    });
    const computedIconRight = computed(() => {
      if (props.passwordReveal) {
        return passwordVisibleIcon.value;
      } else if (props.clearable && vmodel.value && props.clearIcon) {
        return props.clearIcon;
      } else if (props.iconRight) {
        return props.iconRight;
      }
      return statusVariantIcon.value;
    });
    const computedIconRightVariant = computed(
      () => props.passwordReveal || props.iconRight ? props.iconRightVariant || props.variant || null : statusVariant.value
    );
    function iconClick(event) {
      emits("icon-click", event);
      nextTick(() => setFocus());
    }
    function rightIconClick(event) {
      if (props.passwordReveal)
        togglePasswordVisibility();
      else if (props.clearable)
        vmodel.value = "";
      if (props.iconRightClickable) {
        emits("icon-right-click", event);
        nextTick(() => setFocus());
      }
    }
    const isPasswordVisible = ref(false);
    const inputType = computed(() => {
      if (props.passwordReveal) {
        return isPasswordVisible.value ? "text" : "password";
      } else {
        return props.type;
      }
    });
    const passwordVisibleIcon = computed(
      () => !isPasswordVisible.value ? "eye" : "eye-off"
    );
    function togglePasswordVisibility() {
      isPasswordVisible.value = !isPasswordVisible.value;
      nextTick(() => setFocus());
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-input__wrapper"],
      [
        "expandedClass",
        "o-input__wrapper--expanded",
        null,
        computed(() => props.expanded)
      ],
      [
        "hasIconRightClass",
        "o-input__wrapper--has-icon-right",
        null,
        hasIconRight
      ]
    );
    const inputClasses = defineClasses(
      ["inputClass", "o-input"],
      ["roundedClass", "o-input--rounded", null, computed(() => props.rounded)],
      [
        "sizeClass",
        "o-input--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "variantClass",
        "o-input--",
        computed(() => statusVariant.value || props.variant),
        computed(() => !!statusVariant.value || !!props.variant)
      ],
      [
        "disabledClass",
        "o-input--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "textareaClass",
        "o-input__textarea",
        null,
        computed(() => props.type === "textarea")
      ],
      [
        "iconLeftSpaceClass",
        "o-input--iconspace-left",
        null,
        computed(() => !!props.icon)
      ],
      ["iconRightSpaceClass", "o-input--iconspace-right", null, hasIconRight]
    );
    const iconLeftClasses = defineClasses(["iconLeftClass", "o-input__icon-left"]);
    const iconRightClasses = defineClasses([
      "iconRightClass",
      "o-input__icon-right"
    ]);
    const counterClasses = defineClasses(["counterClass", "o-input__counter"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "input",
        class: normalizeClass(unref(rootClasses))
      }, [
        __props.type !== "textarea" ? withDirectives((openBlock(), createElementBlock("input", mergeProps({ key: 0 }, _ctx.$attrs, {
          id: __props.id,
          ref_key: "inputRef",
          ref: inputRef,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
          "data-oruga-input": inputType.value,
          type: inputType.value,
          class: unref(inputClasses),
          maxlength: __props.maxlength,
          autocomplete: __props.autocomplete,
          placeholder: __props.placeholder,
          disabled: __props.disabled,
          onBlur: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput
        }), null, 16, _hoisted_1)), [
          [vModelDynamic, vmodel.value]
        ]) : withDirectives((openBlock(), createElementBlock("textarea", mergeProps({ key: 1 }, _ctx.$attrs, {
          id: __props.id,
          ref_key: "textareaRef",
          ref: textareaRef,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => vmodel.value = $event),
          "data-oruga-input": "textarea",
          class: unref(inputClasses),
          maxlength: __props.maxlength,
          style: computedStyles.value,
          placeholder: __props.placeholder,
          disabled: __props.disabled,
          onBlur: _cache[5] || (_cache[5] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[7] || (_cache[7] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput
        }), null, 16, _hoisted_2)), [
          [vModelText, vmodel.value]
        ]),
        __props.icon ? (openBlock(), createBlock(_sfc_main, {
          key: 2,
          class: normalizeClass(unref(iconLeftClasses)),
          clickable: __props.iconClickable,
          icon: __props.icon,
          pack: __props.iconPack,
          size: __props.size,
          onClick: iconClick
        }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : createCommentVNode("", true),
        hasIconRight.value ? (openBlock(), createBlock(_sfc_main, {
          key: 3,
          class: normalizeClass(unref(iconRightClasses)),
          clickable: __props.passwordReveal || __props.clearable || __props.iconRightClickable,
          icon: computedIconRight.value,
          pack: __props.iconPack,
          size: __props.size,
          variant: computedIconRightVariant.value,
          both: "",
          onClick: rightIconClick
        }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : createCommentVNode("", true),
        __props.maxlength && __props.counter && unref(isFocused) && __props.type !== "number" ? (openBlock(), createElementBlock("small", {
          key: 4,
          class: normalizeClass(unref(counterClasses))
        }, toDisplayString(valueLength.value) + " / " + toDisplayString(__props.maxlength), 3)) : createCommentVNode("", true)
      ], 2);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/PositionWrapper.vue_vue_type_script_setup_true_lang-CiXmKQFF.mjs
function getScrollingParent(target) {
  if (target.style.position === "fixed" || !target)
    return document.documentElement;
  let isScrollingParent = false;
  let nextParent = target.parentElement;
  while (!isScrollingParent && isDefined(nextParent)) {
    if (nextParent === document.documentElement)
      break;
    const { overflow, overflowY } = getComputedStyle(nextParent);
    const { scrollHeight, clientHeight } = nextParent;
    isScrollingParent = /(auto|scroll)/.test(`${overflow}${overflowY}`) && scrollHeight > clientHeight;
    if (isScrollingParent)
      break;
    nextParent = nextParent.parentElement;
  }
  return nextParent;
}
var _sfc_main3 = defineComponent({
  ...{ inheritAttrs: false },
  __name: "PositionWrapper",
  props: {
    teleport: {
      type: [Boolean, String, Object],
      required: true
    },
    trigger: {
      type: Object,
      default: void 0
    },
    /**
     * Position of the component relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      validator: (value) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(value) > -1,
      default: void 0
    },
    /** Used for calculation position auto */
    defaultPosition: {
      type: String,
      validator: (value) => ["top", "bottom", "left", "right"].indexOf(value) > -1,
      default: "top"
    },
    /** disable the position calculation */
    disabled: { type: Boolean, default: false },
    /** update positioning on teleport */
    disablePositioning: { type: Boolean, default: true }
  },
  emits: ["update:position"],
  setup(__props, { emit: __emit }) {
    const opposites = {
      top: "bottom",
      bottom: "top",
      right: "left",
      left: "right"
    };
    const props = __props;
    const emits = __emit;
    const teleportTo = computed(
      () => typeof props.teleport === "boolean" ? "body" : props.teleport
    );
    const teleportDisabled = computed(
      () => typeof props.teleport === "boolean" || !props.teleport ? !props.teleport : false
    );
    const contentRef = ref();
    function setContent(el) {
      contentRef.value = el;
      nextTick(() => {
        updatePositioning();
        addHandler();
      });
      return el;
    }
    const initialPosition = props.position;
    const scrollingParent = ref(void 0);
    const resizeObserver = ref(null);
    if (isClient && window.ResizeObserver) {
      resizeObserver.value = new window.ResizeObserver(updatePositioning);
    }
    watch(
      () => props.disabled,
      () => {
        if (!props.disabled)
          addHandler();
        else
          removeHandler();
      },
      { immediate: true }
    );
    watch(
      [
        () => !!props.trigger,
        () => props.disablePositioning,
        () => props.disabled
      ],
      () => {
        nextTick(() => updatePositioning());
      },
      { immediate: true }
    );
    onBeforeUnmount(() => removeHandler());
    function addHandler() {
      if (isClient && !scrollingParent.value && contentRef.value) {
        scrollingParent.value = getScrollingParent(unrefElement(contentRef));
        if (scrollingParent.value && scrollingParent.value !== document.documentElement) {
          scrollingParent.value.addEventListener(
            "scroll",
            updatePositioning,
            { passive: true }
          );
          if (window.ResizeObserver)
            resizeObserver.value.observe(scrollingParent.value);
        } else {
          document.addEventListener("scroll", updatePositioning, {
            passive: true
          });
          window.addEventListener("resize", updatePositioning);
        }
      }
    }
    function removeHandler() {
      var _a;
      if (isClient) {
        if (window.ResizeObserver)
          (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
        window.removeEventListener("resize", updatePositioning);
        document.removeEventListener("scroll", updatePositioning);
        scrollingParent.value = void 0;
      }
    }
    function updatePositioning() {
      if (props.disabled)
        return;
      let position = props.position;
      if (initialPosition === "auto") {
        position = getAutoPosition();
        if (position != props.position)
          emits("update:position", position);
      }
      if (!props.teleport)
        return;
      const content = unrefElement(contentRef);
      const trigger = unrefElement(props.trigger);
      if (content && trigger) {
        const rect = trigger.getBoundingClientRect();
        let top = rect.top + window.scrollY;
        let left = rect.left + window.scrollX;
        if (position.includes("bottom")) {
          top += trigger.clientHeight;
        } else if (position.includes("top")) {
          top -= content.clientHeight;
        }
        if (position === "left") {
          left -= content.clientWidth;
        } else if (position === "right") {
          left += trigger.clientWidth;
        } else if (position.includes("-right")) {
          left += trigger.clientWidth - content.clientWidth;
        }
        if (position === "top" || position === "bottom") {
          left += trigger.clientWidth / 2;
        }
        if (position === "left" || position === "right") {
          top += trigger.clientHeight / 2;
        }
        if (props.disablePositioning) {
          content.style.position = "relative";
          content.style.top = `${top}px`;
          content.style.left = `${left}px`;
        } else {
          content.style.position = "";
          content.style.top = "";
          content.style.left = "";
        }
      }
    }
    function getAutoPosition() {
      let bestPosition = props.defaultPosition;
      if (!props.trigger || !contentRef.value)
        return bestPosition;
      if (!scrollingParent.value)
        return bestPosition;
      const viewRect = new DOMRect(
        scrollingParent.value.offsetLeft,
        scrollingParent.value.offsetTop,
        scrollingParent.value.clientWidth,
        scrollingParent.value.clientHeight
      );
      const contentRect = unrefElement(contentRef).getBoundingClientRect();
      const triggerRect = unrefElement(props.trigger).getBoundingClientRect();
      const triggerAnchors = anchors(triggerRect);
      const contentAnchors = anchors(contentRect);
      const contentRectAtAnchor = (pos) => {
        const triggerAnchor = triggerAnchors[pos];
        const contentAnchor = contentAnchors[opposites[pos]];
        return new DOMRect(
          contentRect.x + (triggerAnchor.x - contentAnchor.x),
          contentRect.y + (triggerAnchor.y - contentAnchor.y),
          contentRect.width,
          contentRect.height
        );
      };
      const defaultOpposite = opposites[props.defaultPosition];
      const crossPosition = props.defaultPosition === "top" || props.defaultPosition === "bottom" ? "left" : "top";
      const crossOpposite = opposites[crossPosition];
      const positions = [
        props.defaultPosition,
        defaultOpposite,
        crossPosition,
        crossOpposite
      ];
      let maxOverlap = 0;
      for (const position of positions) {
        const overlap = intersectionArea(
          viewRect,
          contentRectAtAnchor(position)
        );
        if (overlap > maxOverlap) {
          maxOverlap = overlap;
          bestPosition = position;
        }
      }
      return bestPosition;
    }
    function intersectionArea(a, b) {
      const left = Math.max(a.left, b.left);
      const right = Math.min(a.right, b.right);
      const top = Math.max(a.top, b.top);
      const bottom = Math.min(a.bottom, b.bottom);
      return Math.max(right - left, 0) * Math.max(bottom - top, 0);
    }
    const anchors = (rect) => ({
      top: { x: (rect.left + rect.right) * 0.5, y: rect.top },
      bottom: { x: (rect.left + rect.right) * 0.5, y: rect.bottom },
      left: { x: rect.left, y: (rect.top + rect.bottom) * 0.5 },
      right: { x: rect.right, y: (rect.top + rect.bottom) * 0.5 }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: teleportTo.value,
        disabled: teleportDisabled.value
      }, [
        teleportDisabled.value ? renderSlot(_ctx.$slots, "default", {
          key: 0,
          setContent
        }) : (openBlock(), createElementBlock("div", mergeProps({ key: 1 }, _ctx.$attrs, { style: { position: "absolute", left: "0px", top: "0px" } }), [
          renderSlot(_ctx.$slots, "default", { setContent })
        ], 16))
      ], 8, ["to", "disabled"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/trapFocus-D3wF5u_Q.mjs
var findFocusable = (element, programmatic = false) => {
  if (!element)
    return null;
  if (programmatic)
    return element.querySelectorAll(`*[tabindex="-1"]`);
  return element.querySelectorAll(`a[href]:not([tabindex="-1"]),
                                     area[href],
                                     input:not([disabled]),
                                     select:not([disabled]),
                                     textarea:not([disabled]),
                                     button:not([disabled]),
                                     iframe,
                                     object,
                                     embed,
                                     *[tabindex]:not([tabindex="-1"]),
                                     *[contenteditable]`);
};
var onKeyDown;
var bind = (el, { value = true }) => {
  if (value) {
    let focusable = findFocusable(el);
    let focusableProg = findFocusable(el, true);
    if (focusable && focusable.length > 0) {
      onKeyDown = (event) => {
        focusable = findFocusable(el);
        focusableProg = findFocusable(el, true);
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        if (event.target === firstFocusable && event.shiftKey && event.key === "Tab") {
          event.preventDefault();
          lastFocusable.focus();
        } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === "Tab") {
          event.preventDefault();
          firstFocusable.focus();
        }
      };
      el.addEventListener("keydown", onKeyDown);
    }
  }
};
var unbind = (el) => {
  el.removeEventListener("keydown", onKeyDown);
};
var directive = {
  beforeMount: bind,
  beforeUnmount: unbind
};
var vTrapFocus = directive;

// node_modules/@oruga-ui/oruga-next/dist/esm/useEventListener-DXZDse6S.mjs
function useEventListener(event, listener, el = document, options) {
  let cleanup;
  const register = () => {
    if (!el)
      return;
    const target = unrefElement(el);
    const optionsClone = isObject(options) ? { ...options } : options;
    target.addEventListener(event, listener, optionsClone);
    cleanup = () => target.removeEventListener(event, listener, optionsClone);
  };
  const stop = () => {
    if (typeof cleanup === "function")
      cleanup();
  };
  if (options == null ? void 0 : options.immediate)
    register();
  else {
    onMounted(() => register());
    onBeforeUnmount(() => stop());
  }
  return stop;
}

// node_modules/@oruga-ui/oruga-next/dist/esm/useMatchMedia-C64GX8hs.mjs
function useMatchMedia(mobileBreakpoint) {
  var _a;
  const isMobile = ref(false);
  const mediaQuery = ref();
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useMatchMedia must be called within a component setup function."
    );
  const props = vm.props;
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  if (!configField)
    throw new Error("component must define the 'configField' option.");
  let width = props.mobileBreakpoint;
  if (!width) {
    const defaultWidth = getOption(
      `mobileBreakpoint`,
      mobileBreakpoint || "1023px"
    );
    width = getOption(`${configField}.mobileBreakpoint`, defaultWidth);
  }
  mediaQuery.value = isClient ? window.matchMedia(`(max-width: ${width})`) : void 0;
  if (mediaQuery.value) {
    isMobile.value = mediaQuery.value.matches;
    useEventListener("change", onMatchMedia, mediaQuery.value);
  } else {
    isMobile.value = false;
  }
  function onMatchMedia(event) {
    isMobile.value = event.matches;
  }
  return { isMobile };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/useParentProvider-CVABNV-7.mjs
function useProviderParent(rootRef, options) {
  var _a;
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  const key = (options == null ? void 0 : options.key) || configField;
  const childItems = ref([]);
  const sequence = ref(1);
  const sortedItems = computed(
    () => childItems.value.slice().sort((a, b) => a.index - b.index)
  );
  function registerItem(data) {
    const index30 = childItems.value.length;
    const identifier = nextSequence();
    const item = { index: index30, data, identifier };
    childItems.value.push(item);
    if (rootRef == null ? void 0 : rootRef.value) {
      nextTick(() => {
        const ids = childItems.value.map((item2) => `[data-id="${key}-${item2.identifier}"]`).join(",");
        const parent = unrefElement(rootRef);
        const children = parent.querySelectorAll(ids);
        const sortedIds = Array.from(children).map(
          (el) => el.getAttribute("data-id").replace(`${key}-`, "")
        );
        childItems.value.forEach(
          (item2) => item2.index = sortedIds.indexOf(`${item2.identifier}`)
        );
      });
    }
    return item;
  }
  function unregisterItem(item) {
    childItems.value = childItems.value.filter((i) => i !== item);
  }
  function nextSequence() {
    return String(sequence.value++);
  }
  provide("$o-" + key, {
    registerItem,
    unregisterItem,
    data: options == null ? void 0 : options.data
  });
  return {
    childItems,
    sortedItems
  };
}
function useProviderChild(options = { needParent: true }) {
  var _a;
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  const key = (options == null ? void 0 : options.key) || configField;
  const parent = inject(
    "$o-" + key,
    void 0
  );
  const needParent = options.needParent !== false;
  const register = options.register !== false;
  if (needParent && !parent) {
    throw new Error(
      `You should wrap ${vm.proxy.$options.name} in a ${key} component`
    );
  }
  const item = ref();
  if (parent && register)
    item.value = parent.registerItem(options.data);
  onUnmounted(() => {
    if (parent && item.value)
      parent.unregisterItem(item.value);
  });
  return { parent: parent == null ? void 0 : parent.data, item };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/useClickOutside-DcbY7k0a.mjs
function useClickOutside(target, handler, ignore = []) {
  if (!window)
    return;
  const shouldIgnore = (event) => {
    return ignore.some((target2) => {
      if (typeof target2 === "string") {
        return Array.from(
          window.document.querySelectorAll(target2)
        ).some(
          (el) => el === event.target || event.composedPath().includes(el)
        );
      } else {
        const el = unrefElement(target2);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  const listener = (event) => {
    const el = unrefElement(target);
    if (!el || el === event.target || event.composedPath().includes(el))
      return;
    if (shouldIgnore(event))
      return;
    handler(event);
  };
  const stop = useEventListener("click", listener, window, {
    immediate: true,
    passive: true
  });
  return stop;
}

// node_modules/@oruga-ui/oruga-next/dist/esm/DropdownItem.vue_vue_type_script_setup_true_lang-Dpj7m-LI.mjs
var _hoisted_12 = ["aria-hidden"];
var _sfc_main$1 = defineComponent({
  ...{
    isOruga: true,
    name: "ODropdown",
    configField: "dropdown"
  },
  __name: "Dropdown",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: void 0
    },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /** Trigger label, unnecessary when trgger slot is used */
    label: { type: String, default: void 0 },
    /** Dropdown is disabled */
    disabled: { type: Boolean, default: false },
    /** Dropdown content (items) are shown inline, trigger is removed */
    inline: { type: Boolean, default: false },
    /** Dropdown content will be scrollable */
    scrollable: { type: Boolean, default: false },
    /** Max height of dropdown content */
    maxHeight: {
      type: [String, Number],
      default: () => getOption("dropdown.maxHeight", 200)
    },
    /**
     * Position of the dropdown relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      default: () => getOption("dropdown.position", "bottom-left"),
      validator: (value) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(value) > -1
    },
    /** Dropdown content (items) are shown into a modal on mobile */
    mobileModal: {
      type: Boolean,
      default: () => getOption("dropdown.mobileModal", true)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("dropdown.animation", "fade")
    },
    /** Allows multiple selections */
    multiple: { type: Boolean, default: false },
    /** Trap focus inside the dropdown. */
    trapFocus: {
      type: Boolean,
      default: () => getOption("dropdown.trapFocus", true)
    },
    /** Makes the component check if menu reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => getOption("dropdown.checkScroll", false)
    },
    /** Dropdown will be expanded (full-width) */
    expanded: { type: Boolean, default: false },
    /** HTML element ID of the dropdown menu element */
    menuId: { type: String, default: null },
    /** Tabindex of the dropdown menu element */
    menuTabindex: { type: Number, default: null },
    /** Dropdown menu tag name */
    menuTag: {
      type: [String, Object, Function],
      default: () => getOption("dropdown.menuTag", "div")
    },
    /** Dropdown trigger tag name */
    triggerTag: {
      type: [String, Object, Function],
      default: () => getOption("dropdown.triggerTag", "div")
    },
    /**
     * Dropdown will be triggered by any events
     * @values click, hover, contextmenu, focus
     */
    triggers: {
      type: Array,
      default: () => getOption("dropdown.triggers", ["click"]),
      validator: (values) => values.filter(
        (value) => ["click", "hover", "contextmenu", "focus"].indexOf(value) > -1
      ).length === values.length
    },
    /** Dropdown delay before it appears (number in ms) */
    delay: { type: Number, default: void 0 },
    /**
     * Dropdown close options (pressing escape, clicking the content or outside)
     * @values true, false, escape, outside, content
     */
    closeable: {
      type: [Array, Boolean],
      default: () => getOption("dropdown.closeable", ["escape", "outside", "content"])
    },
    /** Set the tabindex attribute on the dropdown trigger div (-1 to prevent selection via tab key) */
    tabindex: { type: Number, default: 0 },
    /**
     * Role attribute to be passed to the list container for better accessibility.
     * Use menu only in situations where your dropdown is related to a navigation menu.
     * @values list, listbox, menu, dialog
     */
    ariaRole: {
      type: String,
      default: getOption("dropdown.ariaRole", "list"),
      validator: (value) => ["list", "listbox", "menu", "dialog"].indexOf(value) > -1
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("dropdown.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("dropdown.teleport", false)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the dropdown is teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the trigger element */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu when inline */
    inlineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the overlay when on mobile */
    menuMobileOverlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown menu */
    menuClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu position */
    menuPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu when active */
    menuActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element indicating position of dropdown */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element indicating whether the dropdown is open */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element when the dropdown is hoverable */
    hoverableClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "modelValue": {},
    "modelModifiers": {},
    "active": { type: Boolean },
    "activeModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "update:active", "change", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const vmodel = useModel(__props, "modelValue");
    const isActive = useModel(__props, "active");
    const autoPosition = ref(props.position);
    watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const isMobileModal = computed(
      () => isMobile.value && props.mobileModal && !props.inline
    );
    const isMobileNative = computed(() => props.mobileModal && isMobileAgent.any());
    const menuStyle = computed(() => ({
      maxHeight: props.scrollable ? toCssDimension(props.maxHeight) : null,
      overflow: props.scrollable ? "auto" : null
    }));
    const hoverable = computed(() => props.triggers.indexOf("hover") >= 0);
    const contentRef = ref();
    const triggerRef = ref();
    const eventCleanups = [];
    let timer;
    watch(
      isActive,
      (value) => {
        if (value && isClient) {
          setTimeout(() => {
            if (cancelOptions.value.indexOf("outside") >= 0) {
              eventCleanups.push(
                useClickOutside(contentRef, onClickedOutside, [
                  triggerRef
                ])
              );
            }
            if (cancelOptions.value.indexOf("escape") >= 0) {
              eventCleanups.push(
                useEventListener("keyup", onKeyPress, document, {
                  immediate: true
                })
              );
            }
          });
        } else if (!value) {
          eventCleanups.forEach((fn) => fn());
          eventCleanups.length = 0;
        }
      },
      { immediate: true }
    );
    onUnmounted(() => {
      eventCleanups.forEach((fn) => fn());
      eventCleanups.length = 0;
    });
    const cancelOptions = computed(
      () => typeof props.closeable === "boolean" ? props.closeable ? ["escape", "outside", "content"] : [] : props.closeable
    );
    function onClickedOutside() {
      if (!isActive.value || props.inline)
        return;
      if (cancelOptions.value.indexOf("outside") < 0)
        return;
      emits("close", "outside");
      isActive.value = false;
    }
    function onKeyPress(event) {
      if (isActive.value && (event.key === "Escape" || event.key === "Esc")) {
        if (cancelOptions.value.indexOf("escape") < 0)
          return;
        emits("close", "escape");
        isActive.value = false;
      }
    }
    function onClick() {
      if (props.triggers.indexOf("click") < 0)
        return;
      toggle();
    }
    function onContextMenu(event) {
      if (props.triggers.indexOf("contextmenu") < 0)
        return;
      event.preventDefault();
      open();
    }
    function onFocus() {
      if (props.triggers.indexOf("focus") < 0)
        return;
      open();
    }
    const isHovered = ref(false);
    function onHover() {
      if (!isMobileNative.value && props.triggers.indexOf("hover") >= 0) {
        isHovered.value = true;
        open();
      }
    }
    function onHoverLeave() {
      if (!isMobileNative.value && isHovered.value) {
        isHovered.value = false;
        onClose();
      }
    }
    function toggle() {
      if (props.disabled)
        return;
      if (isActive.value)
        isActive.value = !isActive.value;
      else
        nextTick(() => isActive.value = !isActive.value);
    }
    function open() {
      if (props.disabled)
        return;
      if (props.delay) {
        timer = setTimeout(() => {
          isActive.value = true;
          timer = null;
        }, props.delay);
      } else {
        isActive.value = true;
      }
    }
    function onClose() {
      if (cancelOptions.value.indexOf("content") < 0)
        return;
      emits("close", "content");
      isActive.value = !props.closeable;
      if (timer && props.closeable)
        clearTimeout(timer);
    }
    if (isClient && props.checkScroll)
      useEventListener("scroll", checkDropdownScroll, contentRef);
    function checkDropdownScroll() {
      const dropdown = unrefElement(contentRef);
      if (dropdown.clientHeight !== dropdown.scrollHeight) {
        if (dropdown.scrollTop + dropdown.clientHeight >= dropdown.scrollHeight) {
          emits("scroll-end");
        } else if (dropdown.scrollTop <= 0) {
          emits("scroll-start");
        }
      }
    }
    function selectItem(value) {
      if (props.multiple) {
        if (vmodel.value && Array.isArray(vmodel.value)) {
          if (vmodel.value.indexOf(value) === -1) {
            vmodel.value = [...vmodel.value, value];
          } else {
            vmodel.value = vmodel.value.filter((val) => val !== value);
          }
        } else {
          vmodel.value = [value];
        }
        nextTick(() => emits("change", vmodel.value));
      } else {
        if (vmodel.value !== value) {
          vmodel.value = value;
          nextTick(() => emits("change", vmodel.value));
        }
      }
      if (!props.multiple) {
        if (cancelOptions.value.indexOf("content") < 0)
          return;
        emits("close", "content");
        isActive.value = false;
        isHovered.value = false;
      }
    }
    const provideData = computed(() => ({
      props,
      selected: vmodel.value,
      selectItem
    }));
    useProviderParent(contentRef, { data: provideData });
    const rootClasses = defineClasses(
      ["rootClass", "o-drop"],
      ["disabledClass", "o-drop--disabled", null, computed(() => props.disabled)],
      ["expandedClass", "o-drop--expanded", null, computed(() => props.expanded)],
      ["inlineClass", "o-drop--inline", null, computed(() => props.inline)],
      [
        "mobileClass",
        "o-drop--mobile",
        null,
        computed(() => isMobileModal.value && !hoverable.value)
      ],
      [
        "positionClass",
        "o-drop--position-",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "activeClass",
        "o-drop--active",
        null,
        computed(() => isActive.value || props.inline)
      ],
      ["hoverableClass", "o-drop--hoverable", null, hoverable]
    );
    const triggerClasses = defineClasses(["triggerClass", "o-drop__trigger"]);
    const positionWrapperClasses = defineClasses([
      "teleportClass",
      "o-drop--teleport",
      null,
      computed(() => !!props.teleport)
    ]);
    const menuMobileOverlayClasses = defineClasses([
      "menuMobileOverlayClass",
      "o-drop__overlay"
    ]);
    const menuClasses = defineClasses(
      ["menuClass", "o-drop__menu"],
      [
        "menuPositionClass",
        "o-drop__menu--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "menuActiveClass",
        "o-drop__menu--active",
        null,
        computed(() => isActive.value || props.inline)
      ]
    );
    __expose({ $trigger: triggerRef, $content: contentRef });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "dropdown",
        class: normalizeClass(unref(rootClasses)),
        onMouseleave: onHoverLeave,
        onFocusout: onHoverLeave
      }, [
        !__props.inline ? (openBlock(), createBlock(resolveDynamicComponent(__props.triggerTag), {
          key: 0,
          ref_key: "triggerRef",
          ref: triggerRef,
          tabindex: __props.disabled ? null : __props.tabindex,
          class: normalizeClass(unref(triggerClasses)),
          "aria-haspopup": __props.ariaRole === "list" ? true : __props.ariaRole,
          onClick,
          onContextmenu: onContextMenu,
          onMouseenter: onHover,
          onFocusCapture: onFocus
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger", { active: isActive.value }, () => [
              createTextVNode(toDisplayString(__props.label), 1)
            ])
          ]),
          _: 3
        }, 40, ["tabindex", "class", "aria-haspopup"])) : createCommentVNode("", true),
        createVNode(_sfc_main3, {
          position: autoPosition.value,
          "onUpdate:position": _cache[0] || (_cache[0] = ($event) => autoPosition.value = $event),
          teleport: __props.teleport,
          class: normalizeClass([...unref(rootClasses), ...unref(positionWrapperClasses)]),
          trigger: triggerRef.value,
          disabled: !isActive.value,
          "default-position": "bottom",
          "disable-positioning": !isMobileModal.value
        }, {
          default: withCtx(({ setContent }) => [
            createVNode(Transition, { name: __props.animation }, {
              default: withCtx(() => [
                isMobileModal.value ? withDirectives((openBlock(), createElementBlock("div", {
                  key: 0,
                  tabindex: -1,
                  class: normalizeClass(unref(menuMobileOverlayClasses)),
                  "aria-hidden": __props.disabled || !isActive.value
                }, null, 10, _hoisted_12)), [
                  [vShow, isActive.value]
                ]) : createCommentVNode("", true)
              ]),
              _: 1
            }, 8, ["name"]),
            createVNode(Transition, { name: __props.animation }, {
              default: withCtx(() => [
                withDirectives((openBlock(), createBlock(resolveDynamicComponent(__props.menuTag), {
                  id: __props.menuId,
                  ref: (el) => contentRef.value = setContent(el),
                  tabindex: __props.menuTabindex,
                  class: normalizeClass(unref(menuClasses)),
                  style: normalizeStyle(menuStyle.value),
                  role: __props.ariaRole,
                  "aria-hidden": __props.disabled || !isActive.value,
                  "aria-modal": !__props.inline && __props.trapFocus
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "default", {
                      active: isActive.value,
                      toggle
                    })
                  ]),
                  _: 2
                }, 1032, ["id", "tabindex", "class", "style", "role", "aria-hidden", "aria-modal"])), [
                  [vShow, !__props.disabled && (isActive.value || isHovered.value) || __props.inline],
                  [unref(vTrapFocus), __props.trapFocus]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled", "disable-positioning"])
      ], 34);
    };
  }
});
var _sfc_main4 = defineComponent({
  ...{
    isOruga: true,
    name: "ODropdownItem",
    configField: "dropdown"
  },
  __name: "DropdownItem",
  props: {
    /** The value that will be returned on events and v-model - default is a uuid */
    value: {
      type: [String, Number, Boolean, Object, Array],
      default: void 0
      // () => uuid(),
    },
    /** Item label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Item is disabled */
    disabled: { type: Boolean, default: false },
    /** Item is clickable and emit an event */
    clickable: { type: Boolean, default: true },
    /** Dropdown item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => getOption("dropdown.itemTag", "div")
    },
    /** Set the tabindex attribute on the dropdown item div (-1 to prevent selection via tab key) */
    tabindex: { type: [Number, String], default: 0 },
    /**
     * Role attribute to be passed to the list item for better accessibility.
     * Use menuitem only in situations where your dropdown is related to a navigation menu.
     * @values listitem, menuitem, button
     */
    ariaRole: {
      type: String,
      default: getOption("dropdown.itemAriaRole", "listitem")
    },
    // class props (will not be displayed in the docs)
    /** Class of the dropdown item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when active  */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when clickable */
    itemClickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when disabled */
    itemDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const itemValue = computed(() => props.value || uuid());
    const { parent } = useProviderChild();
    const isClickable = computed(
      () => !parent.value.props.disabled && !props.disabled && props.clickable
    );
    const isActive = computed(() => {
      if (parent.value.selected === null)
        return false;
      if (parent.value.props.multiple && Array.isArray(parent.value.selected))
        return parent.value.selected.some(
          (selected) => isEqual(itemValue.value, selected)
        );
      return isEqual(itemValue.value, parent.value.selected);
    });
    function selectItem(event) {
      if (!isClickable.value)
        return;
      parent.value.selectItem(itemValue.value);
      emits("click", itemValue.value, event);
    }
    const rootClasses = defineClasses(
      ["itemClass", "o-drop__item"],
      [
        "itemDisabledClass",
        "o-drop__item--disabled",
        null,
        computed(() => parent.value.props.disabled || props.disabled)
      ],
      ["itemActiveClass", "o-drop__item--active", null, isActive],
      ["itemClickableClass", "o-drop__item--clickable", null, isClickable]
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), {
        class: normalizeClass(unref(rootClasses)),
        role: __props.ariaRole,
        tabindex: __props.tabindex,
        "data-oruga": "dropdown-item",
        onClick: selectItem
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "role", "tabindex"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/useDebounce-Bl5cEME3.mjs
function useDebounce(func, wait, immediate) {
  let timeout;
  return (...args) => {
    const later = () => {
      timeout = null;
      if (!immediate)
        func.apply(this, args);
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(this, args);
  };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/Autocomplete.vue_vue_type_script_setup_true_lang-D7a3Rjfy.mjs
var _hoisted_13 = { key: 1 };
var _hoisted_22 = { key: 1 };
var SpecialOption = ((SpecialOption2) => {
  SpecialOption2[SpecialOption2["Header"] = 0] = "Header";
  SpecialOption2[SpecialOption2["Footer"] = 1] = "Footer";
  return SpecialOption2;
})(SpecialOption || {});
var _sfc_main5 = defineComponent({
  ...{
    isOruga: true,
    name: "OAutocomplete",
    configField: "autocomplete",
    inheritAttrs: false
  },
  __name: "Autocomplete",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: void 0 },
    /** Input type */
    type: { type: String, default: "text" },
    /** Menu tag name */
    menuTag: {
      type: [String, Object, Function],
      default: () => getOption("autocomplete.menuTag", "div")
    },
    /** Menu item tag name */
    itemTag: {
      type: [String, Object, Function],
      default: () => getOption("autocomplete.itemTag", "div")
    },
    /** Options / suggestions */
    data: { type: Array, default: () => [] },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("autocomplete.size")
    },
    /**
     * Position of the dropdown
     * @values auto, top, bottom
     */
    position: {
      type: String,
      default: () => getOption("autocomplete.position", "auto"),
      validator: (value) => ["auto", "top", "bottom"].indexOf(value) >= 0
    },
    /** Property of the object (if data is array of objects) to use as display text, and to keep track of selected option */
    field: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as display text of group */
    groupField: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as key to get items array of each group */
    groupOptions: { type: String, default: void 0 },
    /** Function to format an option to a string for display in the input (as alternative to field prop) */
    formatter: {
      type: Function,
      default: void 0
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: false },
    /** Same as native input disabled */
    disabled: { type: Boolean, default: false },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: [String, Number], default: void 0 },
    /** Makes the component check if list reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => getOption("autocomplete.checkScroll", false)
    },
    /** Number of milliseconds to delay before to emit input event */
    debounce: {
      type: Number,
      default: () => getOption("autocomplete.debounce", 400)
    },
    /** The first option will always be pre-selected (easier to just hit enter or tab) */
    keepFirst: {
      type: Boolean,
      default: () => getOption("autocomplete.keepFirst", false)
    },
    /** Clear input text on select */
    clearOnSelect: {
      type: Boolean,
      default: () => getOption("autocomplete.clearOnSelect", false)
    },
    /** Open dropdown list on focus */
    openOnFocus: {
      type: Boolean,
      default: () => getOption("autocomplete.openOnFocus", false)
    },
    /** Keep open dropdown list after select */
    keepOpen: {
      type: Boolean,
      default: () => getOption("autocomplete.keepOpen", false)
    },
    /** Max height of dropdown content */
    maxHeight: {
      type: [String, Number],
      default: () => getOption("autocomplete.maxHeight")
    },
    /** Array of keys (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) which will add a tag when typing (default tab and enter) */
    confirmKeys: {
      type: Array,
      default: () => getOption("autocomplete.confirmKeys", ["Tab", "Enter"])
    },
    /** Dropdown content (items) are shown into a modal on mobile */
    mobileModal: {
      type: Boolean,
      default: () => getOption("autocomplete.mobileModal", false)
    },
    /** Transition name to apply on dropdown list */
    animation: {
      type: String,
      default: () => getOption("autocomplete.animation", "fade")
    },
    /** Trigger the select event for the first pre-selected option when clicking outside and `keep-first` is enabled */
    selectOnClickOutside: { type: Boolean, default: false },
    /** Allows the header in the autocomplete to be selectable */
    selectableHeader: { type: Boolean, default: false },
    /** Allows the footer in the autocomplete to be selectable */
    selectableFooter: { type: Boolean, default: false },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("autocomplete.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("autocomplete.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: false },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("autocomplete.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Add a button/icon to clear the inputed text */
    clearable: {
      type: Boolean,
      default: () => getOption("autocomplete.clearable", false)
    },
    /** Icon name to be added on the clear button */
    clearIcon: {
      type: String,
      default: () => getOption("autocomplete.clearIcon", "close-circle")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => getOption("statusIcon", true)
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("autocomplete.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("autocomplete.teleport", false)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items on hover */
    itemHoverClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items group title */
    itemGroupTitleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu empty placeholder item */
    itemEmptyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu header item */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu footer item */
    itemFooterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Classes to apply on internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => getOption("autocomplete.inputClasses", {})
    }
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "input", "select", "select-header", "select-footer", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    function isSpecialOption(option) {
      return option in SpecialOption;
    }
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const inputRef = ref();
    const dropdownRef = ref();
    const footerRef = ref();
    const headerRef = ref();
    const itemRefs = ref([]);
    function setItemRef(el, groupIndex, itemIndex) {
      if (groupIndex === 0 && itemIndex === 0)
        itemRefs.value.splice(0);
      if (el)
        itemRefs.value.push(el);
    }
    const { checkHtml5Validity, onInvalid, onFocus, onBlur, isFocused, setFocus } = useInputHandler(inputRef, emits, props);
    const vmodel = useModel(__props, "modelValue");
    const isActive = ref(false);
    const selectedOption = ref();
    const hoveredOption = ref();
    const headerHovered = ref(false);
    const footerHovered = ref(false);
    const hoveredId = ref(null);
    const menuId = uuid();
    watch(
      () => vmodel.value,
      (value) => {
        const currentValue = getValue(selectedOption.value);
        if (currentValue && currentValue !== value)
          setSelected(null, false);
        nextTick(() => {
          if (isEmpty.value && !slots.empty)
            isActive.value = false;
          else if (isFocused.value && (!props.openOnFocus || value))
            isActive.value = !!value;
        });
      }
    );
    watch(
      () => props.data,
      () => {
        if (props.keepFirst) {
          nextTick(() => {
            if (isActive.value)
              selectFirstOption();
            else
              setHovered(null);
          });
        } else if (hoveredOption.value) {
          const hoveredValue = getValue(hoveredOption.value);
          const data = computedData.value.map((d) => d.items).reduce((a, b) => [...a, ...b], []);
          const index30 = data.findIndex((d) => getValue(d) === hoveredValue);
          if (index30 >= 0)
            nextTick(() => setHoveredIdToIndex(index30));
          else
            setHovered(null);
        }
      }
    );
    const computedData = computed(() => {
      if (props.groupField) {
        if (props.groupOptions)
          return props.data.map((option) => {
            const group = getValueByPath(option, props.groupField);
            const items = getValueByPath(option, props.groupOptions);
            return { group, items };
          });
        else
          return Object.keys(props.data).map((group) => ({
            group,
            items: props.data[group]
          }));
      }
      if (!props.openOnFocus && !props.keepOpen && vmodel.value === "") {
        return [{ items: [] }];
      }
      return [{ items: props.data }];
    });
    const isEmpty = computed(
      () => {
        var _a;
        return !((_a = computedData.value) == null ? void 0 : _a.some(
          (element) => element.items && element.items.length
        ));
      }
    );
    watch(isEmpty, (empty) => {
      if (isFocused.value)
        isActive.value = !empty || !!slots.empty;
    });
    const closeableOptions = computed(() => {
      const options = ["escape"];
      if (!props.keepOpen) {
        options.push("content");
        options.push("outside");
      }
      return options;
    });
    function onDropdownClose(method) {
      if (method === "outside") {
        if (props.keepFirst && hoveredOption.value && props.selectOnClickOutside)
          setSelected(hoveredOption.value, true);
      }
    }
    function getValue(option) {
      if (!option)
        return "";
      const property = props.field && typeof option === "object" ? getValueByPath(option, props.field) : option;
      const label = typeof props.formatter === "function" ? props.formatter(property) : property;
      return label || "";
    }
    function setHovered(option) {
      if (option === void 0)
        return;
      hoveredOption.value = isSpecialOption(option) ? null : option;
      headerHovered.value = option === 0;
      footerHovered.value = option === 1;
      hoveredId.value = null;
    }
    function setHoveredIdToIndex(index30) {
      const element = unrefElement(itemRefs.value[index30]);
      hoveredId.value = element ? element.id : null;
    }
    function setSelected(option, closeDropdown = true, event = void 0) {
      if (option === void 0)
        return;
      selectedOption.value = option;
      emits("select", selectedOption.value, event);
      if (selectedOption.value !== null) {
        if (props.clearOnSelect) {
          const input = inputRef.value.$el.querySelector("input");
          input.value = "";
        } else {
          vmodel.value = getValue(selectedOption.value);
        }
        setHovered(null);
      }
      if (closeDropdown)
        nextTick(() => isActive.value = false);
      checkHtml5Validity();
    }
    function selectFirstOption() {
      nextTick(() => {
        const nonEmptyElements = computedData.value.filter(
          (element) => element.items && element.items.length
        );
        if (nonEmptyElements.length) {
          const option = nonEmptyElements[0].items[0];
          setHovered(option);
          setHoveredIdToIndex(0);
        } else {
          setHovered(null);
        }
      });
    }
    function selectHeaderOrFooterByClick(event, origin, closeDropdown = true) {
      if (props.selectableHeader && (headerHovered.value || origin === 0)) {
        emits("select-header", event);
        if (origin)
          setHovered(null);
        if (closeDropdown)
          isActive.value = false;
      }
      if (props.selectableFooter && (footerHovered.value || origin === 1)) {
        emits("select-footer", event);
        if (origin)
          setHovered(null);
        if (closeDropdown)
          isActive.value = false;
      }
    }
    function navigateItem(direction) {
      if (!isActive.value) {
        isActive.value = true;
        return;
      }
      const data = computedData.value.map((d) => d.items).reduce((a, b) => [...a, ...b], []);
      if (headerRef.value && props.selectableHeader)
        data.unshift(void 0);
      if (footerRef.value && props.selectableFooter)
        data.push(void 0);
      let index30 = data.map(toRaw).indexOf(toRaw(hoveredOption.value));
      if (headerHovered.value)
        index30 = 0 + direction;
      else if (footerHovered.value)
        index30 = data.length - 1 + direction;
      else
        index30 = index30 + direction;
      index30 = index30 > data.length - 1 ? data.length - 1 : index30;
      index30 = index30 < 0 ? 0 : index30;
      if (footerRef.value && props.selectableFooter && index30 === data.length - 1)
        setHovered(
          1
          /* Footer */
        );
      else if (headerRef.value && props.selectableHeader && index30 === 0)
        setHovered(
          0
          /* Header */
        );
      else
        setHovered(data[index30] !== void 0 ? data[index30] : null);
      let items = itemRefs.value || [];
      if (headerRef.value && props.selectableHeader)
        items = [headerRef.value, ...items];
      if (footerRef.value && props.selectableFooter)
        items = [...items, footerRef.value];
      const element = unrefElement(items[index30]);
      if (!element)
        return;
      hoveredId.value = element.id;
      const dropdownMenu = unrefElement(dropdownRef.value.$content);
      const visMin = dropdownMenu.scrollTop;
      const visMax = dropdownMenu.scrollTop + dropdownMenu.clientHeight - element.clientHeight;
      if (element.offsetTop < visMin) {
        dropdownMenu.scrollTop = element.offsetTop;
      } else if (element.offsetTop >= visMax) {
        dropdownMenu.scrollTop = element.offsetTop - dropdownMenu.clientHeight + element.clientHeight;
      }
      if (props.checkScroll)
        checkDropdownScroll();
    }
    function onKeydown(event) {
      if (event.key === "Enter")
        event.preventDefault();
      if (props.confirmKeys.indexOf(event.key) >= 0) {
        if (event.key === ",")
          event.preventDefault();
        const closeDropdown = !props.keepOpen || event.key === "Tab";
        if (hoveredOption.value === null) {
          selectHeaderOrFooterByClick(event, null, closeDropdown);
          return;
        }
        setSelected(hoveredOption.value, closeDropdown, event);
      }
    }
    function handleFocus(event) {
      if (getValue(selectedOption.value) === vmodel.value) {
        inputRef.value.$el.querySelector("input").select();
      }
      if (props.openOnFocus) {
        isActive.value = true;
        if (props.keepFirst)
          selectFirstOption();
      }
      onFocus(event);
    }
    function handleBlur(event) {
      onBlur(event);
    }
    function onInput(value) {
      const currentValue = getValue(selectedOption.value);
      if (currentValue && currentValue === vmodel.value)
        return;
      debouncedInput(value);
    }
    let debouncedInput = useDebounce(emitInput, props.debounce || 0);
    watchEffect(() => {
      debouncedInput = useDebounce(emitInput, props.debounce);
    });
    function emitInput(value) {
      emits("input", value);
      checkHtml5Validity();
    }
    const computedIconRight = computed(
      () => props.clearable && vmodel.value && props.clearIcon ? props.clearIcon : props.iconRight
    );
    const computedIconRightClickable = computed(
      () => props.clearable ? true : props.iconRightClickable
    );
    function rightIconClick(event) {
      if (props.clearable) {
        vmodel.value = "";
        setSelected(null, false);
        if (props.openOnFocus)
          setFocus();
      } else
        emits("icon-right-click", event);
    }
    onMounted(() => {
      if (isClient && props.checkScroll)
        useEventListener(
          "scroll",
          checkDropdownScroll,
          dropdownRef.value.$content,
          { immediate: true }
        );
    });
    function checkDropdownScroll() {
      var _a, _b;
      const dropdown = unrefElement(dropdownRef.value.$content);
      if (!dropdown)
        return;
      const trashhold = dropdown.offsetTop;
      const headerHeight = ((_a = headerRef.value) == null ? void 0 : _a.clientHeight) || 0;
      const footerHeight = (((_b = footerRef.value) == null ? void 0 : _b.clientHeight) || 0) + trashhold;
      if (dropdown.clientHeight !== dropdown.scrollHeight) {
        if (dropdown.scrollTop + dropdown.clientHeight + footerHeight >= dropdown.scrollHeight) {
          emits("scroll-end");
        } else if (dropdown.scrollTop <= headerHeight) {
          emits("scroll-start");
        }
      }
    }
    const attrs = useAttrs();
    const inputBind = computed(() => ({
      ...attrs,
      ...props.inputClasses
    }));
    const rootClasses = defineClasses(["rootClass", "o-acp"]);
    const itemClasses = defineClasses(["itemClass", "o-acp__item"]);
    const itemEmptyClasses = defineClasses([
      "itemEmptyClass",
      "o-acp__item--empty"
    ]);
    const itemGroupClasses = defineClasses([
      "itemGroupTitleClass",
      "o-acp__item-group-title"
    ]);
    const itemHeaderClasses = defineClasses(
      ["itemHeaderClass", "o-acp__item-header"],
      ["itemHoverClass", "o-acp__item--hover", null, headerHovered]
    );
    const itemFooterClasses = defineClasses(
      ["itemFooterClass", "o-acp__item-footer"],
      ["itemHoverClass", "o-acp__item--hover", null, footerHovered]
    );
    function itemOptionClasses(option) {
      const optionClasses = defineClasses([
        "itemHoverClass",
        "o-acp__item--hover",
        null,
        toRaw(option) === toRaw(hoveredOption.value)
      ]);
      return [...itemClasses.value, ...optionClasses.value];
    }
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$1, {
        ref_key: "dropdownRef",
        ref: dropdownRef,
        modelValue: selectedOption.value,
        "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => selectedOption.value = $event),
        active: isActive.value,
        "onUpdate:active": _cache[8] || (_cache[8] = ($event) => isActive.value = $event),
        "data-oruga": "autocomplete",
        class: normalizeClass(unref(rootClasses)),
        "menu-id": unref(menuId),
        "menu-tabindex": -1,
        "menu-tag": __props.menuTag,
        scrollable: "",
        "aria-role": "listbox",
        tabindex: -1,
        "trap-focus": false,
        triggers: [],
        disabled: __props.disabled,
        closeable: closeableOptions.value,
        "mobile-modal": __props.mobileModal,
        "max-height": __props.maxHeight,
        animation: __props.animation,
        position: __props.position,
        teleport: __props.teleport,
        expanded: __props.expanded,
        onClose: onDropdownClose
      }, {
        trigger: withCtx(() => [
          createVNode(_sfc_main2, mergeProps({
            ref_key: "inputRef",
            ref: inputRef
          }, inputBind.value, {
            modelValue: vmodel.value,
            "onUpdate:modelValue": [
              _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
              onInput
            ],
            type: __props.type,
            size: __props.size,
            rounded: __props.rounded,
            icon: __props.icon,
            "icon-right": computedIconRight.value,
            "icon-right-clickable": computedIconRightClickable.value,
            "icon-pack": __props.iconPack,
            placeholder: __props.placeholder,
            maxlength: __props.maxlength,
            autocomplete: __props.autocomplete,
            "use-html5-validation": false,
            role: "combobox",
            "aria-activedescendant": hoveredId.value,
            "aria-autocomplete": __props.keepFirst ? "both" : "list",
            "aria-controls": unref(menuId),
            "aria-expanded": isActive.value,
            expanded: __props.expanded,
            disabled: __props.disabled,
            "status-icon": __props.statusIcon,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onInvalid: unref(onInvalid),
            onKeydown: [
              onKeydown,
              _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => navigateItem(-1), ["prevent"]), ["up"])),
              _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => navigateItem(1), ["prevent"]), ["down"]))
            ],
            onIconClick: _cache[3] || (_cache[3] = (event) => _ctx.$emit("icon-click", event)),
            onIconRightClick: rightIconClick
          }), null, 16, ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "placeholder", "maxlength", "autocomplete", "aria-activedescendant", "aria-autocomplete", "aria-controls", "aria-expanded", "expanded", "disabled", "status-icon", "onInvalid"])
        ]),
        default: withCtx(() => [
          _ctx.$slots.header ? (openBlock(), createBlock(_sfc_main4, {
            key: 0,
            id: `${unref(menuId)}-header`,
            ref_key: "headerRef",
            ref: headerRef,
            tag: __props.itemTag,
            "aria-role": "option",
            "aria-selected": headerHovered.value,
            tabindex: -1,
            class: normalizeClass([...unref(itemClasses), ...unref(itemHeaderClasses)]),
            onClick: _cache[4] || (_cache[4] = (v, e) => selectHeaderOrFooterByClick(
              e,
              0
              /* Header */
            ))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "header")
            ]),
            _: 3
          }, 8, ["id", "tag", "aria-selected", "class"])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(computedData.value, (element, groupindex) => {
            return openBlock(), createElementBlock(Fragment, null, [
              element.group ? (openBlock(), createBlock(_sfc_main4, {
                key: groupindex + "group",
                tag: __props.itemTag,
                tabindex: -1,
                class: normalizeClass([...unref(itemClasses), ...unref(itemGroupClasses)])
              }, {
                default: withCtx(() => [
                  _ctx.$slots.group ? renderSlot(_ctx.$slots, "group", {
                    key: 0,
                    group: element.group,
                    index: groupindex
                  }) : (openBlock(), createElementBlock("span", _hoisted_13, toDisplayString(element.group), 1))
                ]),
                _: 2
              }, 1032, ["tag", "class"])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(element.items, (option, index30) => {
                return openBlock(), createBlock(_sfc_main4, {
                  id: `${unref(menuId)}-${groupindex}-${index30}`,
                  key: groupindex + ":" + index30,
                  ref_for: true,
                  ref: (el) => setItemRef(el, groupindex, index30),
                  value: option,
                  tag: __props.itemTag,
                  class: normalizeClass(itemOptionClasses(option)),
                  "aria-role": "option",
                  "aria-selected": toRaw(option) === toRaw(hoveredOption.value),
                  tabindex: -1,
                  onClick: _cache[5] || (_cache[5] = (value, event) => setSelected(value, !__props.keepOpen, event))
                }, {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", {
                      key: 0,
                      option,
                      value: getValue(option),
                      index: index30
                    }) : (openBlock(), createElementBlock("span", _hoisted_22, toDisplayString(getValue(option)), 1))
                  ]),
                  _: 2
                }, 1032, ["id", "value", "tag", "class", "aria-selected"]);
              }), 128))
            ], 64);
          }), 256)),
          isEmpty.value && _ctx.$slots.empty ? (openBlock(), createBlock(_sfc_main4, {
            key: 1,
            tag: __props.itemTag,
            class: normalizeClass([...unref(itemClasses), ...unref(itemEmptyClasses)])
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "empty")
            ]),
            _: 3
          }, 8, ["tag", "class"])) : createCommentVNode("", true),
          _ctx.$slots.footer ? (openBlock(), createBlock(_sfc_main4, {
            key: 2,
            id: `${unref(menuId)}-footer`,
            ref_key: "footerRef",
            ref: footerRef,
            tag: __props.itemTag,
            "aria-role": "option",
            "aria-selected": footerHovered.value,
            tabindex: -1,
            class: normalizeClass([...unref(itemClasses), ...unref(itemFooterClasses)]),
            onClick: _cache[6] || (_cache[6] = (v, e) => selectHeaderOrFooterByClick(
              e,
              1
              /* Footer */
            ))
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "footer")
            ]),
            _: 3
          }, 8, ["id", "tag", "aria-selected", "class"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["modelValue", "active", "class", "menu-id", "menu-tag", "disabled", "closeable", "mobile-modal", "max-height", "animation", "position", "teleport", "expanded"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/autocomplete.mjs
var index = {
  install(app) {
    registerComponent(app, _sfc_main5);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Button.vue_vue_type_script_setup_true_lang-BMN4deA8.mjs
var _sfc_main6 = defineComponent({
  ...{
    isOruga: true,
    name: "OButton",
    configField: "button"
  },
  __name: "Button",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /**
     * Button tag name
     * @values button, a, input, router-link, nuxt-link (or other nuxt alias)
     */
    tag: {
      type: [String, Object, Function],
      default: () => getOption("button.tag", "button")
    },
    /**
     * Color variant of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("button.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("button.size")
    },
    /** Button label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("button.iconPack", void 0)
    },
    /** Icon name to show on the left */
    iconLeft: { type: String, default: void 0 },
    /** Icon name to show on the right */
    iconRight: { type: String, default: void 0 },
    /** Enable rounded style */
    rounded: {
      type: Boolean,
      default: () => getOption("button.rounded", false)
    },
    /** Button will be expanded (full-width) */
    expanded: { type: Boolean, default: false },
    /** Button will be disabled */
    disabled: { type: Boolean, default: false },
    /** Enable outlined style */
    outlined: { type: Boolean, default: false },
    /** Enable loading style */
    loading: { type: Boolean, default: false },
    /** Enable inverted style */
    inverted: { type: Boolean, default: false },
    /** Button type, like native */
    nativeType: {
      type: String,
      default: "button",
      validator: (value) => ["button", "submit", "reset"].indexOf(value) >= 0
    },
    /** Accessibility Role attribute to be passed to the button. */
    role: {
      type: String,
      default: () => getOption("button.role", "button")
    },
    /**
     * This is used internally
     * @ignore
     */
    iconBoth: { type: Boolean, default: false },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button elements wrapper */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when outlined */
    outlinedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button with loading */
    loadingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when inverted */
    invertedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon on the left */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon on the right */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const computedTag = computed(
      () => typeof props.disabled !== "undefined" && props.disabled !== false ? "button" : props.tag
    );
    const computedNativeType = computed(
      () => props.tag === "button" || props.tag === "input" ? props.nativeType : null
    );
    const computedDisabled = computed(() => props.disabled ? true : null);
    const rootClasses = defineClasses(
      ["rootClass", "o-btn"],
      [
        "sizeClass",
        "o-btn--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "variantClass",
        "o-btn--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "outlinedClass",
        "o-btn--outlined",
        null,
        computed(() => props.outlined && !props.variant)
      ],
      [
        "invertedClass",
        "o-btn--inverted",
        null,
        computed(() => props.inverted && !props.variant)
      ],
      [
        "outlinedClass",
        "o-btn--outlined-",
        computed(() => props.variant),
        computed(() => props.outlined && !!props.variant)
      ],
      [
        "invertedClass",
        "o-btn--inverted-",
        computed(() => props.variant),
        computed(() => props.inverted && !!props.variant)
      ],
      ["expandedClass", "o-btn--expanded", null, computed(() => props.expanded)],
      ["loadingClass", "o-btn--loading", null, computed(() => props.loading)],
      ["roundedClass", "o-btn--rounded", null, computed(() => props.rounded)],
      ["disabledClass", "o-btn--disabled", null, computed(() => props.disabled)]
    );
    const labelClasses = defineClasses(["labelClass", "o-btn__label"]);
    const iconClasses = defineClasses(["iconClass", "o-btn__icon"]);
    const iconLeftClasses = defineClasses(["iconLeftClass", "o-btn__icon-left"]);
    const iconRightClasses = defineClasses(["iconRightClass", "o-btn__icon-right"]);
    const wrapperClasses = defineClasses(["wrapperClass", "o-btn__wrapper"]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(computedTag.value), {
        disabled: computedDisabled.value,
        type: computedNativeType.value,
        class: normalizeClass(unref(rootClasses)),
        role: __props.role,
        "data-oruga": "button"
      }, {
        default: withCtx(() => [
          createBaseVNode("span", {
            class: normalizeClass(unref(wrapperClasses))
          }, [
            __props.iconLeft ? (openBlock(), createBlock(_sfc_main, {
              key: 0,
              pack: __props.iconPack,
              icon: __props.iconLeft,
              size: __props.size,
              both: __props.iconBoth,
              class: normalizeClass([...unref(iconClasses), ...unref(iconLeftClasses)])
            }, null, 8, ["pack", "icon", "size", "both", "class"])) : createCommentVNode("", true),
            __props.label || _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(labelClasses))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(__props.label), 1)
              ])
            ], 2)) : createCommentVNode("", true),
            __props.iconRight ? (openBlock(), createBlock(_sfc_main, {
              key: 2,
              pack: __props.iconPack,
              icon: __props.iconRight,
              size: __props.size,
              both: __props.iconBoth,
              class: normalizeClass([...unref(iconClasses), ...unref(iconRightClasses)])
            }, null, 8, ["pack", "icon", "size", "both", "class"])) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["disabled", "type", "class", "role"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/button.mjs
var index2 = {
  install(app) {
    registerComponent(app, _sfc_main6);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/usePropValue-pUJCuQ_7.mjs
function usePropBinding(name, props, emit, options) {
  const event = (options == null ? void 0 : options.eventName) || `update:${name.toString()}`;
  if (options == null ? void 0 : options.passive) {
    const proxy = ref(props[name]);
    let isUpdating = false;
    watch(
      () => props[name],
      (value) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = value;
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (value) => {
        if (!isUpdating && value !== props[name] || options.deep)
          emit(event, value);
      },
      { deep: options.deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return props[name];
      },
      set(value) {
        emit(event, value);
      }
    });
  }
}
function useVModelBinding(props, emit, options) {
  return usePropBinding("modelValue", props, emit, options);
}

// node_modules/@oruga-ui/oruga-next/dist/esm/carousel.mjs
var _hoisted_1$1 = ["onFocus", "onMouseover", "onClick", "onKeypress"];
var _sfc_main$12 = defineComponent({
  ...{
    isOruga: true,
    name: "OCarousel",
    configField: "carousel"
  },
  __name: "Carousel",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Number, default: 0 },
    /** Enable drag mode */
    dragable: { type: Boolean, default: true },
    /** Timer interval for `autoplay` */
    interval: {
      type: Number,
      default: () => getOption("carousel.interval", 3500)
    },
    /** Move item automaticalls after `interval` */
    autoplay: { type: Boolean, default: false },
    /** Pause autoplay on hover */
    pauseHover: { type: Boolean, default: false },
    /** Repeat from the beginning after reaching the end */
    repeat: { type: Boolean, default: false },
    /** Show an overlay */
    overlay: { type: Boolean, default: false },
    /** Enable indicators */
    indicators: { type: Boolean, default: true },
    /** Place indicators inside the carousel */
    indicatorInside: { type: Boolean, default: false },
    /**
     * Indicator interaction mode
     * @values click, hover
     */
    indicatorMode: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover"].indexOf(value) >= 0
    },
    /** Position of the indicator - depends on used theme */
    indicatorPosition: {
      type: String,
      default: () => getOption("carousel.indicatorPosition", "bottom")
    },
    /** Style of the indicator - depends on used theme */
    indicatorStyle: {
      type: String,
      default: () => getOption("carousel.indicatorStyle", "dots")
    },
    /** Number of items to show at once*/
    itemsToShow: {
      type: Number,
      default: () => getOption("carousel.itemsToShow", 1)
    },
    /** Number of items to switch at once */
    itemsToList: {
      type: Number,
      default: () => getOption("carousel.itemsToList", 1)
    },
    /** Show next / prev arrows */
    arrows: {
      type: Boolean,
      default: () => getOption("carousel.arrows", true)
    },
    /** Show next / prev arrows only on hover */
    arrowsHover: {
      type: Boolean,
      default: () => getOption("carousel.arrowsHover", true)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("carousel.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => getOption("carousel.iconSize")
    },
    /** Icon name for previous icon */
    iconPrev: {
      type: String,
      default: () => getOption("carousel.iconPrev", "chevron-left")
    },
    /** Icon name for next icon */
    iconNext: {
      type: String,
      default: () => getOption("carousel.iconNext", "chevron-right")
    },
    /** Define these props for different screen sizes */
    breakpoints: {
      type: Object,
      default: () => ({})
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element in overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the wrapper element of carousel items */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider items */
    itemsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider items on drag */
    itemsDraggingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of arrow elements */
    arrowIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of prev arrow element */
    arrowIconPrevClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of next arrow element */
    arrowIconNextClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator link element */
    indicatorClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element */
    indicatorsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element when inside */
    indicatorsInsideClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element when inside and position */
    indicatorsInsidePositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator item element */
    indicatorItemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator element when is active */
    indicatorItemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator element to separate different styles */
    indicatorItemStyleClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "scroll", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = ref();
    function restartTimer() {
      pauseTimer();
      startTimer();
    }
    const provideData = computed(() => ({
      restartTimer,
      itemWidth: itemWidth.value,
      activeIndex: scrollIndex.value,
      onClick: (event) => emits("click", event),
      setActive: (index210) => switchTo(index210)
    }));
    const { childItems } = useProviderParent(rootRef, { data: provideData });
    const activeIndex = useVModelBinding(props, emits);
    const scrollIndex = ref(props.modelValue);
    const resizeObserver = ref(null);
    const windowWidth = ref(0);
    const refresh_ = ref(0);
    watch(
      () => props.modelValue,
      (value) => {
        if (value <= childItems.value.length - 1)
          switchTo(value * settings.value.itemsToList, true);
      }
    );
    watch([() => props.itemsToList, () => props.itemsToShow], () => onRefresh());
    onMounted(() => {
      if (isClient) {
        if (window.ResizeObserver) {
          resizeObserver.value = new window.ResizeObserver(onRefresh);
          resizeObserver.value.observe(rootRef.value);
        }
        onResized();
        startTimer();
      }
    });
    onBeforeUnmount(() => {
      if (isClient) {
        if (window.ResizeObserver)
          resizeObserver.value.disconnect();
        dragEnd();
        pauseTimer();
      }
    });
    if (isClient) {
      useEventListener("resize", onResized, window);
      useEventListener("animationend", onRefresh);
      useEventListener("transitionend", onRefresh);
      useEventListener("transitionstart", onRefresh);
    }
    function onResized() {
      windowWidth.value = window.innerWidth;
    }
    function onRefresh() {
      nextTick(() => refresh_.value++);
    }
    const settings = computed(() => {
      const breakpoints = Object.keys(props.breakpoints).map(Number).sort((a, b) => b - a);
      const breakpoint = breakpoints.filter(
        (breakpoint2) => windowWidth.value >= breakpoint2
      )[0];
      const settings2 = toRaw(
        breakpoint ? { ...props, ...props.breakpoints[breakpoint] } : props
      );
      if (!settings2.itemsToList)
        settings2.itemsToList = 1;
      if (!settings2.itemsToShow)
        settings2.itemsToShow = 1;
      return readonly(settings2);
    });
    const itemWidth = computed(() => {
      if (!windowWidth.value)
        return 0;
      refresh_.value;
      const rect = rootRef.value.getBoundingClientRect();
      return rect.width / settings.value.itemsToShow;
    });
    const translation = computed(
      () => -bound(
        delta.value + scrollIndex.value * itemWidth.value,
        0,
        (childItems.value.length - settings.value.itemsToShow) * itemWidth.value
      )
    );
    const total = computed(() => childItems.value.length);
    const indicatorCount = computed(
      () => Math.ceil(total.value / settings.value.itemsToList)
    );
    const indicatorIndex = computed(
      () => Math.ceil(scrollIndex.value / settings.value.itemsToList)
    );
    const hasArrows = computed(
      () => settings.value.arrowsHover && isHovered.value || !settings.value.arrowsHover
    );
    const hasPrev = computed(
      () => (settings.value.repeat || scrollIndex.value > 0) && hasArrows.value
    );
    function onPrev() {
      switchTo(scrollIndex.value - settings.value.itemsToList);
    }
    const hasNext = computed(
      () => (settings.value.repeat || scrollIndex.value < total.value - 1) && hasArrows.value
    );
    function onNext() {
      switchTo(scrollIndex.value + settings.value.itemsToList);
    }
    function switchTo(index210, onlyMove) {
      if (settings.value.repeat)
        index210 = mod(index210, total.value);
      index210 = bound(index210, 0, total.value);
      scrollIndex.value = index210;
      emits("scroll", indicatorIndex.value);
      if (!onlyMove)
        activeIndex.value = Math.ceil(index210 / settings.value.itemsToList);
    }
    function onModeChange(trigger, index210) {
      if (props.indicatorMode === trigger)
        switchTo(index210 * settings.value.itemsToList);
    }
    const isHovered = ref(false);
    const isPaused = ref(false);
    const timer = ref(null);
    function onMouseEnter() {
      isHovered.value = true;
      checkPause();
    }
    function onMouseLeave() {
      isHovered.value = false;
      startTimer();
    }
    watch(
      () => props.autoplay,
      (status) => {
        if (status)
          startTimer();
        else
          pauseTimer();
      }
    );
    watch(
      () => props.repeat,
      (status) => {
        if (status)
          startTimer();
      }
    );
    function startTimer() {
      if (!props.autoplay || timer.value)
        return;
      isPaused.value = false;
      timer.value = setInterval(() => {
        if (!props.repeat && !hasNext.value)
          pauseTimer();
        else
          onNext();
      }, props.interval);
    }
    function pauseTimer() {
      isPaused.value = true;
      if (timer.value) {
        clearInterval(timer.value);
        timer.value = null;
      }
    }
    function checkPause() {
      if (props.pauseHover && props.autoplay)
        pauseTimer();
    }
    const isTouch = ref(false);
    const dragX = ref();
    const hold = ref(0);
    const delta = ref(0);
    const isDragging = computed(() => isDefined(dragX.value));
    function onDragStart(event) {
      if (isDragging.value || !settings.value.dragable || event.button !== 0 && event.type !== "touchstart")
        return;
      hold.value = Date.now();
      isTouch.value = !!event.touches;
      dragX.value = isTouch.value ? event.touches[0].clientX : event.clientX;
      if (isTouch.value) {
        pauseTimer();
      }
      if (isClient) {
        window.addEventListener(
          isTouch.value ? "touchmove" : "mousemove",
          dragMove
        );
        window.addEventListener(
          isTouch.value ? "touchend" : "mouseup",
          dragEnd
        );
      }
    }
    function dragMove(event) {
      if (!isDragging.value)
        return;
      const dragEndX = event.touches ? (event.changedTouches[0] || event.touches[0]).clientX : event.clientX;
      delta.value = dragX.value - dragEndX;
      if (!event.touches)
        event.preventDefault();
    }
    function dragEnd(event) {
      if (!isDragging.value && !hold.value)
        return;
      if (hold.value) {
        const signCheck = sign(delta.value);
        const results = Math.round(
          Math.abs(delta.value / itemWidth.value) + 0.15
        );
        switchTo(scrollIndex.value + signCheck * results);
      }
      delta.value = 0;
      dragX.value = void 0;
      if (event == null ? void 0 : event.touches)
        startTimer();
      if (isClient) {
        window.removeEventListener(
          isTouch.value ? "touchmove" : "mousemove",
          dragMove
        );
        window.removeEventListener(
          isTouch.value ? "touchend" : "mouseup",
          dragEnd
        );
      }
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-car"],
      ["overlayClass", "o-car__overlay", null, computed(() => props.overlay)]
    );
    const wrapperClasses = defineClasses(["wrapperClass", "o-car__wrapper"]);
    const itemsClasses = defineClasses(
      ["itemsClass", "o-car__items"],
      ["itemsDraggingClass", "o-car__items--dragging", null, isDragging]
    );
    const arrowIconClasses = defineClasses([
      "arrowIconClass",
      "o-car__arrow__icon"
    ]);
    const arrowIconPrevClasses = defineClasses([
      "arrowIconPrevClass",
      "o-car__arrow__icon-prev"
    ]);
    const arrowIconNextClasses = defineClasses([
      "arrowIconNextClass",
      "o-car__arrow__icon-next"
    ]);
    function indicatorItemClasses(index210) {
      return defineClasses(
        ["indicatorItemClass", "o-car__indicator__item"],
        [
          "indicatorItemActiveClass",
          "o-car__indicator__item--active",
          null,
          indicatorIndex.value === index210
        ],
        [
          "indicatorItemStyleClass",
          "o-car__indicator__item--",
          props.indicatorStyle,
          !!props.indicatorStyle
        ]
      ).value;
    }
    const indicatorsClasses = defineClasses(
      ["indicatorsClass", "o-car__indicators"],
      [
        "indicatorsInsideClass",
        "o-car__indicators--inside",
        null,
        computed(() => !!props.indicatorInside)
      ],
      [
        "indicatorsInsidePositionClass",
        "o-car__indicators--inside--",
        computed(() => props.indicatorPosition),
        computed(() => props.indicatorInside && !!props.indicatorPosition)
      ]
    );
    const indicatorClasses = defineClasses(["indicatorClass", "o-car__indicator"]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "carousel",
        role: "region",
        onMouseover: onMouseEnter,
        onMouseleave: onMouseLeave,
        onFocus: onMouseEnter,
        onBlur: onMouseLeave,
        onKeydown: [
          withKeys(onPrev, ["left"]),
          withKeys(onNext, ["right"])
        ]
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(wrapperClasses))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(unref(itemsClasses)),
            style: normalizeStyle("transform:translateX(" + translation.value + "px)"),
            tabindex: "0",
            role: "group",
            draggable: "true",
            "aria-roledescription": "carousel",
            onMousedown: onDragStart,
            onTouchstart: onDragStart
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 38),
          renderSlot(_ctx.$slots, "arrow", {
            hasPrev: hasPrev.value,
            prev: onPrev,
            hasNext: hasNext.value,
            next: onNext
          }, () => [
            __props.arrows ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              withDirectives(createVNode(_sfc_main, {
                class: normalizeClass([...unref(arrowIconClasses), ...unref(arrowIconPrevClasses)]),
                pack: __props.iconPack,
                icon: __props.iconPrev,
                size: __props.iconSize,
                both: "",
                role: "button",
                tabindex: "0",
                onClick: onPrev,
                onKeydown: withKeys(onPrev, ["enter"])
              }, null, 8, ["class", "pack", "icon", "size"]), [
                [vShow, hasPrev.value]
              ]),
              withDirectives(createVNode(_sfc_main, {
                class: normalizeClass([...unref(arrowIconClasses), ...unref(arrowIconNextClasses)]),
                pack: __props.iconPack,
                icon: __props.iconNext,
                size: __props.iconSize,
                both: "",
                role: "button",
                tabindex: "0",
                onClick: onNext,
                onKeydown: withKeys(onNext, ["enter"])
              }, null, 8, ["class", "pack", "icon", "size"]), [
                [vShow, hasNext.value]
              ])
            ], 64)) : createCommentVNode("", true)
          ])
        ], 2),
        renderSlot(_ctx.$slots, "indicators", {
          active: unref(activeIndex),
          switchTo,
          indicatorIndex: indicatorIndex.value
        }, () => [
          unref(childItems).length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            __props.indicators ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(indicatorsClasses)),
              role: "group"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(indicatorCount.value, (_, index210) => {
                return openBlock(), createElementBlock("div", {
                  key: index210,
                  class: normalizeClass(unref(indicatorClasses)),
                  role: "button",
                  tabindex: "0",
                  onFocus: ($event) => onModeChange("hover", index210),
                  onMouseover: ($event) => onModeChange("hover", index210),
                  onClick: ($event) => onModeChange("click", index210),
                  onKeypress: withKeys(($event) => onModeChange("click", index210), ["enter"])
                }, [
                  renderSlot(_ctx.$slots, "indicator", { index: index210 }, () => [
                    createBaseVNode("span", {
                      class: normalizeClass(indicatorItemClasses(index210))
                    }, null, 2)
                  ])
                ], 42, _hoisted_1$1);
              }), 128))
            ], 2)) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true)
        ]),
        __props.overlay ? renderSlot(_ctx.$slots, "overlay", { key: 0 }) : createCommentVNode("", true)
      ], 34);
    };
  }
});
var _hoisted_14 = ["data-id", "role", "aria-selected"];
var _sfc_main7 = defineComponent({
  ...{
    isOruga: true,
    name: "OCarouselItem",
    configField: "carousel"
  },
  __name: "CarouselItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Make item clickable */
    clickable: { type: Boolean, default: false },
    /** Role attribute to be passed to the div wrapper for better accessibility */
    ariaRole: {
      type: String,
      default: () => getOption("carousel.ariaRole", "option")
    },
    // class props (will not be displayed in the docs)
    /** Class of carousel item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of carousel item when is active */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of carousel item when is clickable */
    itemClickableClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const { parent, item } = useProviderChild();
    const isActive = computed(() => parent.value.activeIndex === item.value.index);
    const itemStyle = computed(() => ({ width: `${parent.value.itemWidth}px` }));
    function onClick(event) {
      if (isActive.value)
        parent.value.onClick(event);
      if (props.clickable)
        parent.value.setActive(item.value.index);
    }
    const itemClasses = defineClasses(
      ["itemClass", "o-car__item"],
      ["itemActiveClass", "o-car__item--active", null, isActive],
      [
        "itemClickableClass",
        "o-car__item--clickable",
        null,
        computed(() => props.clickable)
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(itemClasses)),
        style: normalizeStyle(itemStyle.value),
        "data-id": `carousel-${unref(item).identifier}`,
        "data-oruga": "carousel-item",
        role: __props.ariaRole,
        "aria-roledescription": "item",
        "aria-selected": isActive.value,
        onClick,
        onKeypress: withKeys(onClick, ["enter"])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_14);
    };
  }
});
var index3 = {
  install(app) {
    registerComponent(app, _sfc_main$12);
    registerComponent(app, _sfc_main7);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Checkbox.vue_vue_type_script_setup_true_lang-QleomGq0.mjs
var _hoisted_15 = ["aria-checked"];
var _hoisted_23 = ["disabled", "required", "name", "autocomplete", "value", ".indeterminate", "true-value", "false-value"];
var _sfc_main8 = defineComponent({
  ...{
    isOruga: true,
    name: "OCheckbox",
    configField: "checkbox",
    inheritAttrs: false
  },
  __name: "Checkbox",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean, Array], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("checkbox.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("checkbox.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native indeterminate */
    indeterminate: { type: Boolean, default: false },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Same as native required */
    required: { type: Boolean, default: false },
    /** Same as native name */
    name: { type: String, default: void 0 },
    /** Overrides the returned value when it's checked */
    trueValue: { type: [String, Number, Boolean], default: true },
    /** Overrides the returned value when it's not checked */
    falseValue: { type: [String, Number, Boolean], default: false },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("checkbox.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when checkbox is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element when checked */
    checkedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox input */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox input when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when checkbox is indeterminate */
    indeterminateClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox labe */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "update:indeterminate", "focus", "blur", "invalid"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const inputRef = ref();
    const { onBlur, onFocus, onInvalid, setFocus } = useInputHandler(
      inputRef,
      emits,
      props
    );
    const vmodel = useVModelBinding(props, emits, { passive: true });
    const isIndeterminate = usePropBinding("indeterminate", props, emits);
    const isChecked = computed(
      () => vmodel.value === props.trueValue || Array.isArray(vmodel.value) && vmodel.value.includes(props.nativeValue)
    );
    function onInput(event) {
      emits("input", vmodel.value, event);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-chk"],
      ["checkedClass", "o-chk--checked", null, isChecked],
      [
        "sizeClass",
        "o-chk--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      ["disabledClass", "o-chk--disabled", null, computed(() => props.disabled)],
      [
        "variantClass",
        "o-chk--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    const inputClasses = defineClasses(
      ["inputClass", "o-chk__input"],
      ["inputCheckedClass", "o-chk__input--checked", null, isChecked],
      [
        "indeterminateClass",
        "o-chk__input--indeterminate",
        null,
        isIndeterminate
      ]
    );
    const labelClasses = defineClasses(["labelClass", "o-chk__label"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        ref: "label",
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "checkbox",
        role: "checkbox",
        "aria-checked": isChecked.value,
        onClick: _cache[5] || (_cache[5] = withModifiers(
          //@ts-ignore
          (...args) => unref(setFocus) && unref(setFocus)(...args),
          ["stop"]
        )),
        onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(
          //@ts-ignore
          (...args) => unref(setFocus) && unref(setFocus)(...args),
          ["prevent"]
        ), ["enter"]))
      }, [
        withDirectives(createBaseVNode("input", mergeProps(_ctx.$attrs, {
          ref_key: "inputRef",
          ref: inputRef,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(vmodel) ? vmodel.value = $event : null),
          type: "checkbox",
          "data-oruga-input": "checkbox",
          class: unref(inputClasses),
          disabled: __props.disabled,
          required: __props.required,
          name: __props.name,
          autocomplete: __props.autocomplete,
          value: __props.nativeValue,
          ".indeterminate": __props.indeterminate,
          "true-value": __props.trueValue,
          "false-value": __props.falseValue,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          onBlur: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput
        }), null, 48, _hoisted_23), [
          [vModelCheckbox, unref(vmodel)]
        ]),
        __props.label || _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(unref(labelClasses))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 2)) : createCommentVNode("", true)
      ], 42, _hoisted_15);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/checkbox.mjs
var index4 = {
  install(app) {
    registerComponent(app, _sfc_main8);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/collapse.mjs
var _hoisted_16 = ["id"];
var _sfc_main9 = defineComponent({
  ...{
    isOruga: true,
    name: "OCollapse",
    configField: "collapse"
  },
  __name: "Collapse",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether collapse is open or not, use v-model:open to make it two-way binding */
    open: { type: Boolean, default: true },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("collapse.animation", "fade")
    },
    /** Id property of the content container */
    contentId: { type: String, default: () => uuid() },
    /**
     * Trigger position
     * @values top, bottom
     */
    position: {
      type: String,
      default: () => getOption("collapse.position", "top"),
      validator: (value) => ["top", "bottom"].indexOf(value) > -1
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the trigger element */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:open", "open", "close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isOpen = usePropBinding("open", props, emits, { passive: true });
    function toggle() {
      isOpen.value = !isOpen.value;
      isOpen.value ? emits("open") : emits("close");
    }
    const rootClasses = defineClasses(["rootClass", "o-clps"]);
    const triggerClasses = defineClasses(["triggerClass", "o-clps__trigger"]);
    const contentClasses = defineClasses(["contentClass", "o-clps__content"]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "collapse"
      }, [
        __props.position === "top" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(triggerClasses)),
          role: "button",
          tabindex: "0",
          onClick: toggle,
          onKeydown: withKeys(toggle, ["enter"])
        }, [
          renderSlot(_ctx.$slots, "trigger", { open: unref(isOpen) })
        ], 34)) : createCommentVNode("", true),
        createVNode(Transition, { name: __props.animation }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", {
              id: __props.contentId,
              class: normalizeClass(unref(contentClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 10, _hoisted_16), [
              [vShow, unref(isOpen)]
            ])
          ]),
          _: 3
        }, 8, ["name"]),
        __props.position === "bottom" ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(unref(triggerClasses)),
          role: "button",
          tabindex: "0",
          onClick: toggle,
          onKeydown: withKeys(toggle, ["enter"])
        }, [
          renderSlot(_ctx.$slots, "trigger", { open: unref(isOpen) })
        ], 34)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var index5 = {
  install(app) {
    registerComponent(app, _sfc_main9);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Select.vue_vue_type_script_setup_true_lang-CL_yS9EM.mjs
var _hoisted_17 = ["id", "autocomplete", "multiple", "size", "disabled"];
var _hoisted_24 = {
  key: 0,
  value: null,
  disabled: "",
  hidden: ""
};
var _hoisted_3 = ["value"];
var _sfc_main10 = defineComponent({
  ...{
    isOruga: true,
    name: "OSelect",
    configField: "select",
    inheritAttrs: false
  },
  __name: "Select",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: null
    },
    /** Select options, unnecessary when default slot is used */
    options: {
      type: Array,
      default: void 0
    },
    /**
     * Vertical size of input
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("select.size")
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("select.variant")
    },
    /** Text when nothing is selected */
    placeholder: { type: String, default: void 0 },
    /** Allow multiple selection */
    multiple: { type: Boolean, default: false },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: false },
    /** Same as native size */
    nativeSize: { type: [String, Number], default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("select.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("select.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: false },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("select.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Same as native id. Also set the for label for o-field wrapper. */
    id: { type: String, default: () => uuid() },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("select.autocomplete", "off")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => getOption("statusIcon", true)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native select element */
    selectClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon space inside the select */
    iconLeftSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon space inside the select */
    iconRightSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select when multiple mode is active */
    multipleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select placeholder */
    placeholderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select arrow */
    arrowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select variant for the root element*/
    rootVariantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "focus", "blur", "invalid", "icon-click", "icon-right-click"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const selectRef = ref();
    const { checkHtml5Validity, onBlur, onFocus, onInvalid, setFocus } = useInputHandler(selectRef, emits, props);
    const { parentField, statusVariant, statusVariantIcon } = injectField();
    const vmodel = useVModelBinding(props, emits, { passive: true });
    const placeholderVisible = computed(() => vmodel.value === null);
    onMounted(() => {
      watch(
        () => vmodel.value,
        (value) => {
          if (parentField == null ? void 0 : parentField.value)
            parentField.value.setFilled(!!value);
          checkHtml5Validity();
        },
        { immediate: true }
      );
    });
    const selectOptions = computed(() => {
      if (!props.options || !Array.isArray(props.options))
        return [];
      return props.options.map(
        (option) => typeof option === "string" ? { value: option, label: option, key: uuid() } : { ...option, key: uuid() }
      );
    });
    const hasIconRight = computed(
      () => props.iconRight && !props.multiple || props.statusIcon && statusVariantIcon.value
    );
    const rightIcon = computed(
      () => props.iconRight ? props.iconRight : statusVariantIcon.value
    );
    const rightIconVariant = computed(
      () => props.iconRight ? props.iconRightVariant || props.variant || null : statusVariant.value
    );
    function iconClick(emit, event) {
      emits(emit, event);
      nextTick(() => setFocus());
    }
    function rightIconClick(event) {
      if (props.iconRightClickable)
        iconClick("icon-right-click", event);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-ctrl-sel"],
      [
        "expandedClass",
        "o-ctrl-sel--expanded",
        null,
        computed(() => props.expanded)
      ],
      [
        "rootVariantClass",
        "o-ctrl-sel--",
        computed(() => statusVariant.value || props.variant),
        computed(() => !!statusVariant.value || !!props.variant)
      ]
    );
    const selectClasses = defineClasses(
      ["selectClass", "o-sel"],
      ["roundedClass", "o-sel--rounded", null, computed(() => props.rounded)],
      ["multipleClass", "o-sel--multiple", null, computed(() => props.multiple)],
      [
        "sizeClass",
        "o-sel--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "variantClass",
        "o-sel--",
        computed(() => statusVariant.value || props.variant),
        computed(() => !!statusVariant.value || !!props.variant)
      ],
      ["disabledClass", "o-sel--disabled", null, computed(() => props.disabled)],
      [
        "iconLeftSpaceClass",
        "o-sel-iconspace-left",
        null,
        computed(() => !!props.icon)
      ],
      [
        "iconRightSpaceClass",
        "o-sel-iconspace-right",
        null,
        computed(() => !!props.iconRight)
      ],
      ["placeholderClass", "o-sel--placeholder", null, placeholderVisible],
      [
        "arrowClass",
        "o-sel-arrow",
        null,
        computed(() => !props.iconRight && !props.multiple)
      ]
    );
    const iconLeftClasses = defineClasses(["iconLeftClass", "o-sel__icon-left"]);
    const iconRightClasses = defineClasses(["iconRightClass", "o-sel__icon-right"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "select"
      }, [
        __props.icon ? (openBlock(), createBlock(_sfc_main, {
          key: 0,
          class: normalizeClass(unref(iconLeftClasses)),
          clickable: __props.iconClickable,
          icon: __props.icon,
          pack: __props.iconPack,
          size: __props.size,
          onClick: _cache[0] || (_cache[0] = ($event) => iconClick("icon-click", $event))
        }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : createCommentVNode("", true),
        withDirectives(createBaseVNode("select", mergeProps(_ctx.$attrs, {
          id: __props.id,
          ref_key: "selectRef",
          ref: selectRef,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(vmodel) ? vmodel.value = $event : null),
          "data-oruga-input": "select",
          class: unref(selectClasses),
          autocomplete: __props.autocomplete,
          multiple: __props.multiple,
          size: __props.nativeSize,
          disabled: __props.disabled,
          onBlur: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args))
        }), [
          __props.placeholder || _ctx.$slots.placeholder ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            placeholderVisible.value ? (openBlock(), createElementBlock("option", _hoisted_24, [
              renderSlot(_ctx.$slots, "placeholder", {}, () => [
                createTextVNode(toDisplayString(__props.placeholder), 1)
              ])
            ])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default", {}, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(selectOptions.value, (option) => {
              return openBlock(), createElementBlock("option", mergeProps({
                key: option.key,
                value: option.value
              }, option.attrs), toDisplayString(option.label), 17, _hoisted_3);
            }), 128))
          ])
        ], 16, _hoisted_17), [
          [vModelSelect, unref(vmodel)]
        ]),
        hasIconRight.value ? (openBlock(), createBlock(_sfc_main, {
          key: 1,
          class: normalizeClass(unref(iconRightClasses)),
          clickable: __props.iconRightClickable,
          icon: rightIcon.value,
          pack: __props.iconPack,
          size: __props.size,
          variant: rightIconVariant.value,
          both: "",
          onClick: rightIconClick
        }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/utils-4B4N5qTH.mjs
var _hoisted_18 = ["data-oruga"];
var _sfc_main11 = defineComponent({
  ...{
    name: "OPickerWrapper"
  },
  __name: "PickerWrapper",
  props: mergeModels({
    /** parent picker component props  */
    picker: { type: Object, required: true },
    /** data-oruga attribute value */
    dataOruga: { type: String, required: true },
    /** the internal input value */
    value: { type: [Date, Array], default: void 0 },
    /** the active state of the dropdown */
    active: { type: Boolean, default: false },
    /** formatted display value to show when client is desktop */
    formattedValue: { type: String, default: void 0 },
    /** native value when client is mobile native */
    nativeValue: { type: [String, Number], default: void 0 },
    nativeType: { type: String, required: true },
    nativeStep: { type: String, default: void 0 },
    nativeMin: { type: [String, Number], default: void 0 },
    nativeMax: { type: [String, Number], default: void 0 },
    stayOpen: { type: Boolean, default: false },
    rootClasses: {
      type: Array,
      required: true
    },
    dropdownClasses: {
      type: Array,
      required: true
    },
    boxClass: {
      type: Array,
      required: true
    }
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: mergeModels(["update:active", "change", "native-change", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isMobileNative = computed(
      () => !props.picker.inline && props.picker.mobileNative && isMobileAgent.any()
    );
    const dropdownRef = ref();
    const inputRef = ref();
    const nativeInputRef = ref();
    const elementRef = computed(
      () => isMobileNative.value ? nativeInputRef.value : inputRef.value
    );
    const {
      input,
      checkHtml5Validity,
      setFocus,
      onBlur,
      onFocus,
      onInvalid,
      isValid
    } = useInputHandler(elementRef, emits, props.picker);
    const initialNativeType = !props.picker.placeholder || !!props.nativeValue ? props.nativeType : "text";
    const inputValue = computed(
      () => isMobileNative.value ? props.nativeValue : props.formattedValue
    );
    const vmodel = ref(inputValue.value);
    watch(inputValue, (value) => vmodel.value = value);
    watch(
      () => props.value,
      () => {
        if (vmodel.value !== inputValue.value)
          vmodel.value = inputValue.value;
        if (!isMobileNative.value && !props.stayOpen)
          togglePicker(false);
        if (!isValid.value)
          checkHtml5Validity();
      },
      { flush: "post" }
    );
    const isActive = useModel(__props, "active");
    watch(isActive, onActiveChange);
    const ariaRole = computed(() => !props.picker.inline ? "dialog" : void 0);
    const triggers = computed(() => props.picker.openOnFocus ? ["click"] : []);
    if (isClient)
      useEventListener("keyup", onKeyPress);
    function onKeyPress(event) {
      if (isActive.value && (event.key === "Escape" || event.key === "Esc"))
        togglePicker(false);
    }
    function togglePicker(active) {
      if (dropdownRef.value) {
        if (active || props.picker.closeOnClick)
          nextTick(() => isActive.value = active);
      }
    }
    function onInputClick(event) {
      if (isActive.value)
        event.stopPropagation();
    }
    function onActiveChange(value) {
      if (value)
        onFocus();
      else if (!value)
        onBlur();
    }
    function onNativeClick(event) {
      if (!isMobileNative.value)
        return;
      if (input.value.type === "text") {
        event.preventDefault();
        event.stopPropagation();
        input.value.blur();
        setTimeout(() => {
          input.value.readOnly = false;
          input.value.type = props.nativeType;
          setFocus();
        }, 50);
      }
    }
    function onNativeFocus(event) {
      if (!isMobileNative.value)
        return;
      if (input.value.type === "text") {
        event.preventDefault();
        event.stopPropagation();
      } else
        onFocus();
    }
    function onNativeBlur() {
      if (!isMobileNative.value)
        return;
      if (!input.value.value) {
        input.value.readOnly = true;
        input.value.type = "text";
      }
      onBlur();
    }
    function handleNativeChange(event) {
      const value = event.target.value ? event.target.value : null;
      if (!value) {
        input.value.value = value;
        input.value.blur();
      }
      emits("native-change", value);
    }
    const attrs = useAttrs();
    const inputBind = computed(() => ({
      ...attrs,
      ...props.picker.inputClasses
    }));
    const dropdownBind = computed(() => ({
      "root-class": getActiveClasses(props.dropdownClasses),
      ...props.picker.dropdownClasses
    }));
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": __props.dataOruga,
        class: normalizeClass(__props.rootClasses),
        onClick: onNativeClick
      }, [
        !isMobileNative.value ? (openBlock(), createBlock(_sfc_main$1, mergeProps({
          key: 0,
          ref_key: "dropdownRef",
          ref: dropdownRef
        }, dropdownBind.value, {
          active: isActive.value,
          "onUpdate:active": _cache[5] || (_cache[5] = ($event) => isActive.value = $event),
          position: __props.picker.position,
          disabled: __props.picker.disabled,
          inline: __props.picker.inline,
          "mobile-modal": __props.picker.mobileModal,
          "trap-focus": __props.picker.trapFocus,
          "aria-role": ariaRole.value,
          "aria-modal": !__props.picker.inline,
          tabindex: -1,
          teleport: __props.picker.teleport,
          triggers: triggers.value
        }), createSlots({
          default: withCtx(() => [
            createVNode(_sfc_main4, {
              override: "",
              tag: "div",
              "item-class": __props.boxClass,
              disabled: __props.picker.disabled,
              clickable: false
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["item-class", "disabled"])
          ]),
          _: 2
        }, [
          !__props.picker.inline ? {
            name: "trigger",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "trigger", {}, () => [
                createVNode(_sfc_main2, mergeProps({
                  ref_key: "inputRef",
                  ref: inputRef
                }, inputBind.value, {
                  modelValue: vmodel.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
                  autocomplete: "off",
                  placeholder: __props.picker.placeholder,
                  size: __props.picker.size,
                  "icon-pack": __props.picker.iconPack,
                  icon: __props.picker.icon,
                  "icon-right": __props.picker.iconRight,
                  "icon-right-clickable": __props.picker.iconRightClickable,
                  expanded: __props.picker.expanded,
                  rounded: __props.picker.rounded,
                  disabled: __props.picker.disabled,
                  readonly: __props.picker.readonly,
                  "use-html5-validation": false,
                  onClick: onInputClick,
                  onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => togglePicker(true), ["enter"])),
                  onChange: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("change", $event.target.value)),
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur),
                  onIconClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("icon-click", $event)),
                  onIconRightClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("icon-right-click", $event))
                }), null, 16, ["modelValue", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "expanded", "rounded", "disabled", "readonly", "onFocus", "onBlur"])
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["active", "position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "aria-modal", "teleport", "triggers"])) : renderSlot(_ctx.$slots, "trigger", { key: 1 }, () => [
          createVNode(_sfc_main2, mergeProps({
            ref_key: "nativeInputRef",
            ref: nativeInputRef
          }, inputBind.value, {
            modelValue: vmodel.value,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => vmodel.value = $event),
            type: unref(initialNativeType),
            min: __props.nativeMin,
            max: __props.nativeMax,
            step: __props.nativeStep,
            placeholder: __props.picker.placeholder,
            size: __props.picker.size,
            "icon-pack": __props.picker.iconPack,
            icon: __props.picker.icon,
            "icon-right": __props.picker.iconRight,
            "icon-right-clickable": __props.picker.iconRightClickable,
            rounded: __props.picker.rounded,
            disabled: __props.picker.disabled,
            readonly: unref(initialNativeType) == "text",
            autocomplete: "off",
            "use-html5-validation": false,
            onChange: handleNativeChange,
            onFocus: onNativeFocus,
            onBlur: onNativeBlur,
            onInvalid: unref(onInvalid),
            onIconClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("icon-click", $event)),
            onIconRightClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("icon-right-click", $event))
          }), null, 16, ["modelValue", "type", "min", "max", "step", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "rounded", "disabled", "readonly", "onInvalid"])
        ])
      ], 10, _hoisted_18);
    };
  }
});
function getMonthNames(locale = void 0, format = "long") {
  const dates = [];
  for (let i = 0; i < 12; i++) {
    dates.push(new Date(2e3, i, 15));
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    month: format
    // timeZone: 'UTC'
  });
  return dates.map((d) => dtf.format(d));
}
function getWeekdayNames(locale = void 0, firstDayOfWeek = 0, format = "narrow") {
  const dates = [];
  for (let i = 1, j = 0; j < 7; i++) {
    const d = new Date(2e3, 0, i);
    const day = d.getDay();
    if (day === firstDayOfWeek || j > 0) {
      dates.push(d);
      j++;
    }
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    weekday: format
    // timeZone: 'UTC'
  });
  return dates.map((d) => dtf.format(d));
}
function matchWithGroups(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g).map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)[1];
  }).reduce((acc, curr, index30) => {
    if (matches && matches.length > index30) {
      acc[curr] = matches[index30 + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function weekBuilder(startingDate, month, year, firstDayOfWeek) {
  const thisMonth = new Date(year, month);
  const thisWeek = [];
  const dayOfWeek = new Date(year, month, startingDate).getDay();
  const end = dayOfWeek >= firstDayOfWeek ? dayOfWeek - firstDayOfWeek : 7 - firstDayOfWeek + dayOfWeek;
  let daysAgo = 1;
  for (let i = 0; i < end; i++) {
    thisWeek.unshift(
      new Date(
        thisMonth.getFullYear(),
        thisMonth.getMonth(),
        startingDate - daysAgo
      )
    );
    daysAgo++;
  }
  thisWeek.push(new Date(year, month, startingDate));
  let daysForward = 1;
  while (thisWeek.length < 7) {
    thisWeek.push(new Date(year, month, startingDate + daysForward));
    daysForward++;
  }
  return thisWeek;
}
function firstWeekOffset(year, dow, doy) {
  const fwd = 7 + dow - doy;
  const firstJanuary = new Date(year, 0, fwd);
  const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function daysInYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0 ? 366 : 365;
}
function weeksInYear(year, dow, doy) {
  const weekOffset = firstWeekOffset(year, dow, doy);
  const weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// node_modules/@oruga-ui/oruga-next/dist/esm/Datepicker.vue_vue_type_script_setup_true_lang-2qtpILMI.mjs
function useDatepickerMixins(props) {
  function isDateSelectable(date, month) {
    const validity = [];
    if (props.minDate)
      validity.push(date >= props.minDate);
    if (props.maxDate)
      validity.push(date <= props.maxDate);
    if (props.nearbyMonthDays && !props.nearbySelectableMonthDays)
      validity.push(date.getMonth() === month);
    if (props.selectableDates) {
      if (typeof props.selectableDates === "function") {
        if (props.selectableDates(date))
          return true;
        else
          validity.push(false);
      } else {
        for (let i = 0; i < props.selectableDates.length; i++) {
          const enabledDate = props.selectableDates[i];
          if (date.getDate() === enabledDate.getDate() && date.getFullYear() === enabledDate.getFullYear() && date.getMonth() === enabledDate.getMonth())
            return true;
          else
            validity.push(false);
        }
      }
    }
    if (props.unselectableDates) {
      if (typeof props.unselectableDates === "function") {
        validity.push(!props.unselectableDates(date));
      } else {
        for (let i = 0; i < props.unselectableDates.length; i++) {
          const disabledDate = props.unselectableDates[i];
          validity.push(
            date.getDate() !== disabledDate.getDate() || date.getFullYear() !== disabledDate.getFullYear() || date.getMonth() !== disabledDate.getMonth()
          );
        }
      }
    }
    if (props.unselectableDaysOfWeek) {
      for (let i = 0; i < props.unselectableDaysOfWeek.length; i++) {
        const dayOfWeek = props.unselectableDaysOfWeek[i];
        validity.push(date.getDay() !== dayOfWeek);
      }
    }
    return validity.indexOf(false) < 0;
  }
  const isTypeMonth = computed(() => props.type === "month");
  const localeOptions = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      year: "numeric",
      month: "numeric"
    }).resolvedOptions()
  );
  const dtf = computed(
    () => new Intl.DateTimeFormat(
      props.locale
      /*, { timeZone: 'UTC' }*/
    )
  );
  const dtfMonth = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      year: localeOptions.value.year || "numeric",
      month: localeOptions.value.month || "2-digit"
      // timeZone: 'UTC'
    })
  );
  const sampleTime = computed(() => {
    const d = props.dateCreator();
    d.setHours(10);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setMilliseconds(0);
    return d;
  });
  const defaultDateFormatter = (date) => {
    if (!date)
      return "";
    const targetDates = Array.isArray(date) ? date : [date];
    if (!targetDates.length)
      return "";
    const dates = targetDates.map((date2) => {
      const d = new Date(
        date2.getFullYear(),
        date2.getMonth(),
        date2.getDate(),
        12
      );
      return !isTypeMonth.value ? dtf.value.format(d) : dtfMonth.value.format(d);
    });
    return !props.multiple ? dates.join(" - ") : dates.join(", ");
  };
  const defaultDateParser = (date) => {
    if (!date)
      return null;
    const targetDates = !props.multiple ? [date] : date.split(", ");
    const dates = targetDates.map((date2) => {
      if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
        const formatRegex = (isTypeMonth.value ? dtfMonth.value : dtf.value).formatToParts(sampleTime.value).map((part) => {
          if (part.type === "literal")
            return part.value;
          return `((?!=<${part.type}>)\\d+)`;
        }).join("");
        const dateGroups = matchWithGroups(formatRegex, date2);
        if (dateGroups.year && dateGroups.year.length === 4 && dateGroups.month && dateGroups.month <= 12) {
          if (isTypeMonth.value)
            return new Date(dateGroups.year, dateGroups.month - 1);
          else if (dateGroups.day && dateGroups.day <= 31) {
            return new Date(
              dateGroups.year,
              dateGroups.month - 1,
              dateGroups.day,
              12
            );
          }
        }
      }
      if (!isTypeMonth.value)
        return new Date(Date.parse(date2));
      const s = date2.split("/");
      const year = s[0].length === 4 ? s[0] : s[1];
      const month = s[0].length === 2 ? s[0] : s[1];
      if (year && month) {
        return new Date(
          parseInt(year, 10),
          parseInt(month, 10) - 1,
          1,
          0,
          0,
          0,
          0
        );
      }
    });
    return props.multiple ? dates : dates[0];
  };
  return { isDateSelectable, defaultDateParser, defaultDateFormatter };
}
var _hoisted_1$2 = ["tabindex"];
var _hoisted_2$2 = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"];
var _sfc_main$3 = defineComponent({
  ...{
    name: "ODatepickerTableRow",
    configField: "datepicker"
  },
  __name: "DatepickerTableRow",
  props: {
    day: { type: Number, required: true },
    week: { type: Array, required: true },
    month: { type: Number, required: true },
    selectedDate: {
      type: [Date, Array],
      default: void 0
    },
    events: { type: Array, default: void 0 },
    hoveredDateRange: { type: Array, default: () => [] },
    pickerProps: {
      type: Object,
      required: true
    }
  },
  emits: ["select", "hover-enddate", "change-focus", "week-number-click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isDateSelectable } = useDatepickerMixins(props.pickerProps);
    const datepicker = computed(() => props.pickerProps);
    const hasEvents = computed(() => {
      var _a;
      return !!((_a = props.events) == null ? void 0 : _a.length);
    });
    const dayRefs = ref(/* @__PURE__ */ new Map());
    function setDayRef(date, el) {
      const refKey = `day-${date.getMonth()}-${date.getDate()}`;
      if (el)
        dayRefs.value.set(refKey, el);
    }
    watch(
      () => props.day,
      (day) => {
        if (props.week.map((d) => d.getDate()).includes(day))
          nextTick(() => {
            const refKey = `day-${props.month}-${day}`;
            const ref2 = dayRefs.value.get(refKey);
            if (ref2)
              ref2.focus();
          });
      }
    );
    watch(
      () => props.month,
      // clear day refs on month change
      () => dayRefs.value = /* @__PURE__ */ new Map()
    );
    function clickWeekNumber(week) {
      if (datepicker.value.weekNumberClickable)
        emits("week-number-click", week);
    }
    function getDayOfYear(input) {
      return Math.round(
        (input.getTime() - new Date(input.getFullYear(), 0, 1).getTime()) / 864e5
      ) + 1;
    }
    function getWeekNumber(mom) {
      const dow = datepicker.value.firstDayOfWeek;
      const doy = datepicker.value.rulesForFirstWeek;
      const weekOffset = firstWeekOffset(mom.getFullYear(), dow, doy);
      const week = Math.floor((getDayOfYear(mom) - weekOffset - 1) / 7) + 1;
      let resWeek;
      let resYear;
      if (week < 1) {
        resYear = mom.getFullYear() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.getFullYear(), dow, doy)) {
        resWeek = week - weeksInYear(mom.getFullYear(), dow, doy);
        resYear = mom.getFullYear() + 1;
      } else {
        resYear = mom.getFullYear();
        resWeek = week;
      }
      return resWeek;
    }
    function eventsDateMatch(day) {
      var _a;
      if (!((_a = props.events) == null ? void 0 : _a.length))
        return [];
      return props.events.filter((event) => event.date.getDay() === day.getDay());
    }
    function onKeydown(event, weekDay) {
      let preventDefault = true;
      switch (event.key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          selectDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault)
        event.preventDefault();
    }
    function selectDate(date) {
      if (datepicker.value.disabled || datepicker.value.readonly)
        return;
      if (isDateSelectable(date, props.month))
        emits("select", date);
    }
    function changeFocus(day, inc) {
      const nextDay = new Date(day.getTime());
      nextDay.setDate(day.getDate() + inc);
      while (datepicker.value.minDate && nextDay < datepicker.value.minDate || datepicker.value.maxDate && nextDay > datepicker.value.maxDate || !isDateSelectable(nextDay, nextDay.getMonth())) {
        nextDay.setDate(nextDay.getDate() - Math.sign(inc));
      }
      setRangeHoverEndDate(nextDay);
      emits("change-focus", nextDay);
    }
    function setRangeHoverEndDate(day) {
      if (datepicker.value.range)
        emits("hover-enddate", day);
    }
    function dateMatch(dateOne, dateTwo, multiple = false) {
      if (!dateOne || !dateTwo || multiple)
        return false;
      if (Array.isArray(dateTwo)) {
        return dateTwo.some(
          (date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
        );
      }
      return dateOne.getDate() === dateTwo.getDate() && dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
    }
    function dateWithin(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || multiple)
        return false;
      return dateOne > dates[0] && dateOne < dates[1];
    }
    function cellClasses(day) {
      const classes = defineClasses(
        [
          "tableCellSelectedClass",
          "o-dpck__table__cell--selected",
          null,
          dateMatch(day, props.selectedDate) || dateWithin(day, props.selectedDate, datepicker.value.multiple)
        ],
        [
          "tableCellFirstSelectedClass",
          "o-dpck__table__cell--first-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.selectedDate) && props.selectedDate[0],
            datepicker.value.multiple
          )
        ],
        [
          "tableCellWithinSelectedClass",
          "o-dpck__table__cell--within-selected",
          null,
          dateWithin(day, props.selectedDate, datepicker.value.multiple)
        ],
        [
          "tableCellLastSelectedClass",
          "o-dpck__table__cell--last-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.selectedDate) && props.selectedDate[1],
            datepicker.value.multiple
          )
        ],
        [
          "tableCellFirstHoveredClass",
          "o-dpck__table__cell--first-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(props.hoveredDateRange) && props.hoveredDateRange[0]
          )
        ],
        [
          "tableCellWithinHoveredClass",
          "o-dpck__table__cell--within-hovered",
          null,
          dateWithin(day, props.hoveredDateRange)
        ],
        [
          "tableCellLastHoveredClass",
          "o-dpck__table__cell--last-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(props.hoveredDateRange) && props.hoveredDateRange[1]
          )
        ],
        [
          "tableCellTodayClass",
          "o-dpck__table__cell--today",
          null,
          dateMatch(day, datepicker.value.dateCreator())
        ],
        [
          "tableCellSelectableClass",
          "o-dpck__table__cell--selectable",
          null,
          isDateSelectable(day, props.month) && !datepicker.value.disabled && !datepicker.value.readonly
        ],
        [
          "tableCellUnselectableClass",
          "o-dpck__table__cell--unselectable",
          null,
          !isDateSelectable(day, props.month) || datepicker.value.disabled
        ],
        [
          "tableCellInvisibleClass",
          "o-dpck__table__cell--invisible",
          null,
          !datepicker.value.nearbyMonthDays && day.getMonth() !== props.month
        ],
        [
          "tableCellNearbyClass",
          "o-dpck__table__cell--nearby",
          null,
          datepicker.value.nearbySelectableMonthDays && day.getMonth() !== props.month
        ],
        [
          "tableCellTodayClass",
          "o-dpck__table__cell--today",
          null,
          dateMatch(day, datepicker.value.dateCreator())
        ]
      );
      return [
        ...tableCellClasses.value,
        ...cellEventsClass.value,
        ...classes.value
      ];
    }
    function eventClasses(event) {
      const classes = defineClasses(
        ["tableEventClass", "o-dpck__table__event"],
        [
          "tableEventVariantClass",
          "o-dpck__table__event--",
          event.type,
          !!event.type
        ],
        [
          "tableEventIndicatorsClass",
          "o-dpck__table__event--",
          datepicker.value.indicators,
          !!datepicker.value.indicators
        ]
      );
      return classes.value;
    }
    const tableRowClasses = defineClasses(["tableRowClass", "o-dpck__table__row"]);
    const tableCellClasses = defineClasses([
      "tableCellClass",
      "o-dpck__table__cell"
    ]);
    const tableEventsClasses = defineClasses([
      "tableEventsClass",
      "o-dpck__table__events"
    ]);
    const cellEventsClass = defineClasses([
      "tableCellEventsClass",
      "o-dpck__table__cell--events",
      null,
      hasEvents
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(tableRowClasses))
      }, [
        datepicker.value.showWeekNumber ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(tableCellClasses)),
          style: normalizeStyle({
            cursor: datepicker.value.weekNumberClickable ? "pointer" : "auto"
          }),
          tabindex: datepicker.value.weekNumberClickable ? 0 : null,
          role: "button",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => clickWeekNumber(getWeekNumber(__props.week[6])), ["prevent"])),
          onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => clickWeekNumber(getWeekNumber(__props.week[6])), ["prevent"]), ["enter"]))
        }, [
          createBaseVNode("span", null, toDisplayString(getWeekNumber(__props.week[6])), 1)
        ], 46, _hoisted_1$2)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.week, (weekDay, idx) => {
          return openBlock(), createElementBlock(Fragment, { key: idx }, [
            !datepicker.value.disabled && !datepicker.value.readonly && unref(isDateSelectable)(weekDay, __props.month) ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_for: true,
              ref: (el) => setDayRef(weekDay, el),
              class: normalizeClass(cellClasses(weekDay)),
              role: "button",
              tabindex: __props.day === weekDay.getDate() && __props.month === weekDay.getMonth() ? null : 0,
              onClick: withModifiers(($event) => selectDate(weekDay), ["prevent"]),
              onMouseenter: ($event) => setRangeHoverEndDate(weekDay),
              onFocus: ($event) => setRangeHoverEndDate(weekDay),
              onKeydown: withKeys(withModifiers(($event) => onKeydown($event, weekDay), ["prevent"]), ["enter"])
            }, [
              createBaseVNode("span", null, toDisplayString(weekDay.getDate()), 1),
              eventsDateMatch(weekDay).length ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(tableEventsClasses))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(eventsDateMatch(weekDay), (event, index30) => {
                  return openBlock(), createElementBlock("div", {
                    key: index30,
                    class: normalizeClass(eventClasses(event))
                  }, null, 2);
                }), 128))
              ], 2)) : createCommentVNode("", true)
            ], 42, _hoisted_2$2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(cellClasses(weekDay))
            }, [
              createBaseVNode("span", null, toDisplayString(weekDay.getDate()), 1)
            ], 2))
          ], 64);
        }), 128))
      ], 2);
    };
  }
});
var _sfc_main$2 = defineComponent({
  ...{
    name: "ODatepickerTable",
    configField: "datepicker"
  },
  __name: "DatepickerTable",
  props: mergeModels({
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    focusedDate: { type: Object, required: true },
    dayNames: { type: Array, required: true },
    monthNames: { type: Array, required: true },
    pickerProps: {
      type: Object,
      required: true
    }
  }, {
    "focusedDate": {},
    "focusedDateModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "update:focusedDate", "range-start", "range-end", "week-number-click"], ["update:focusedDate"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isDateSelectable } = useDatepickerMixins(props.pickerProps);
    const focusedDateModel = useModel(__props, "focusedDate");
    const selectedBeginDate = ref();
    const selectedEndDate = ref();
    const hoveredEndDate = ref();
    const datepicker = computed(() => props.pickerProps);
    const visibleDayNames = computed(() => {
      const visibleDayNames2 = [];
      let index30 = datepicker.value.firstDayOfWeek;
      while (visibleDayNames2.length < props.dayNames.length) {
        const currentDayName = props.dayNames[index30 % props.dayNames.length];
        visibleDayNames2.push(currentDayName);
        index30++;
      }
      if (datepicker.value.showWeekNumber)
        visibleDayNames2.unshift("");
      return visibleDayNames2;
    });
    const eventsInThisMonth = computed(() => {
      if (!datepicker.value.events)
        return [];
      return datepicker.value.events.map(
        (event) => !event.date && event instanceof Date ? { date: event } : event
      ).filter(
        (event) => event.date.getMonth() === focusedDateModel.value.month && event.date.getFullYear() === focusedDateModel.value.year
      );
    });
    const weeksInThisMonth = computed(() => {
      validateFocusedDay();
      const month = focusedDateModel.value.month;
      const year = focusedDateModel.value.year;
      const weeksInThisMonth2 = [];
      let startingDay = 1;
      while (weeksInThisMonth2.length < 6) {
        const newWeek = weekBuilder(
          startingDay,
          month,
          year,
          datepicker.value.firstDayOfWeek
        );
        weeksInThisMonth2.push(newWeek);
        startingDay += 7;
      }
      return weeksInThisMonth2;
    });
    function eventsInThisWeek(week) {
      if (!datepicker.value.events)
        return [];
      return eventsInThisMonth.value.filter((event) => {
        const stripped = new Date(event.date);
        stripped.setHours(0, 0, 0, 0);
        const timed = stripped.getTime();
        return week.some((weekDate) => weekDate.getTime() === timed);
      });
    }
    const hoveredDateRange = computed(() => {
      if (!datepicker.value.range || selectedEndDate.value)
        return [];
      return (hoveredEndDate.value < selectedBeginDate.value ? [hoveredEndDate.value, selectedBeginDate.value] : [selectedBeginDate.value, hoveredEndDate.value]).filter(isDefined);
    });
    function validateFocusedDay() {
      const currentDate = new Date(
        focusedDateModel.value.year,
        focusedDateModel.value.month,
        focusedDateModel.value.day
      );
      if (isDateSelectable(currentDate, focusedDateModel.value.month))
        return;
      let day = 0;
      const monthDays = new Date(
        focusedDateModel.value.year,
        focusedDateModel.value.month + 1,
        0
      ).getDate();
      let firstFocusable = null;
      while (!firstFocusable && ++day < monthDays) {
        const date = new Date(
          focusedDateModel.value.year,
          focusedDateModel.value.month,
          day
        );
        if (isDateSelectable(date, focusedDateModel.value.month)) {
          firstFocusable = currentDate;
          focusedDateModel.value = {
            day: date.getDate(),
            month: date.getMonth(),
            year: date.getFullYear()
          };
        }
      }
    }
    function onSelectedDate(date) {
      if (datepicker.value.disabled)
        return;
      if (!datepicker.value.range && !datepicker.value.multiple)
        emits("update:modelValue", date);
      else if (datepicker.value.range)
        handleSelectRangeDate(date);
      else if (datepicker.value.multiple)
        handleSelectMultipleDates(date);
    }
    function handleSelectRangeDate(date) {
      if (selectedBeginDate.value && selectedEndDate.value) {
        selectedBeginDate.value = date;
        selectedEndDate.value = void 0;
        emits("range-start", date);
      } else if (selectedBeginDate.value && !selectedEndDate.value) {
        if (selectedBeginDate.value > date) {
          selectedEndDate.value = selectedBeginDate.value;
          selectedBeginDate.value = date;
        } else {
          selectedEndDate.value = date;
        }
        emits("range-end", date);
        emits("update:modelValue", [
          selectedBeginDate.value,
          selectedEndDate.value
        ]);
      } else {
        selectedBeginDate.value = date;
        emits("range-start", date);
      }
    }
    function handleSelectMultipleDates(date) {
      if (!Array.isArray(props.modelValue))
        return;
      let multipleSelectedDates = props.modelValue;
      const multipleSelect = multipleSelectedDates.filter(
        (selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth()
      );
      if (multipleSelect.length) {
        multipleSelectedDates = multipleSelectedDates.filter(
          (selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth()
        );
      } else {
        multipleSelectedDates = [...multipleSelectedDates, date];
      }
      emits("update:modelValue", multipleSelectedDates);
    }
    function onRangeHoverEndDate(date) {
      hoveredEndDate.value = date;
    }
    function onChangeFocus(date) {
      focusedDateModel.value = {
        day: date.getDate(),
        month: date.getMonth(),
        year: date.getFullYear()
      };
    }
    const tableClasses = defineClasses(["tableClass", "o-dpck__table"]);
    const tableHeadClasses = defineClasses([
      "tableHeadClass",
      "o-dpck__table__head"
    ]);
    const tableCellClasses = defineClasses([
      "tableCellClass",
      "o-dpck__table__cell"
    ]);
    const tableHeadCellClasses = defineClasses([
      "tableHeadCellClass",
      "o-dpck__table__head-cell"
    ]);
    const tableBodyClasses = defineClasses([
      "tableBodyClass",
      "o-dpck__table__body"
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(unref(tableClasses))
      }, [
        createBaseVNode("header", {
          class: normalizeClass(unref(tableHeadClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleDayNames.value, (day, index30) => {
            return openBlock(), createElementBlock("div", {
              key: index30,
              class: normalizeClass([...unref(tableCellClasses), ...unref(tableHeadCellClasses)])
            }, [
              createBaseVNode("span", null, toDisplayString(day), 1)
            ], 2);
          }), 128))
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(unref(tableBodyClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(weeksInThisMonth.value, (week, index30) => {
            return openBlock(), createBlock(_sfc_main$3, {
              key: index30,
              "selected-date": __props.modelValue,
              day: focusedDateModel.value.day,
              week,
              month: focusedDateModel.value.month,
              events: eventsInThisWeek(week),
              "hovered-date-range": hoveredDateRange.value,
              "picker-props": props.pickerProps,
              onSelect: onSelectedDate,
              onHoverEnddate: onRangeHoverEndDate,
              onChangeFocus,
              onWeekNumberClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("week-number-click", $event))
            }, null, 8, ["selected-date", "day", "week", "month", "events", "hovered-date-range", "picker-props"]);
          }), 128))
        ], 2)
      ], 2);
    };
  }
});
var _hoisted_1$12 = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"];
var _hoisted_2$1 = {
  key: 0,
  class: "events"
};
var _sfc_main$13 = defineComponent({
  ...{
    name: "ODatepickerMonth",
    configField: "datepicker",
    inheritAttrs: false
  },
  __name: "DatepickerMonth",
  props: {
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    monthNames: { type: Array, required: true },
    focusedDate: { type: Object, required: true },
    pickerProps: {
      type: Object,
      required: true
    }
  },
  emits: ["update:modelValue", "update:focusedDate", "range-start", "range-end"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const selectedBeginDate = ref();
    const selectedEndDate = ref();
    const hoveredEndDate = ref();
    const datepicker = computed(() => props.pickerProps);
    const hasEvents = computed(() => {
      var _a;
      return !!((_a = datepicker.value.events) == null ? void 0 : _a.length);
    });
    const monthRefs = ref(/* @__PURE__ */ new Map());
    function setMonthRef(date, el) {
      const refKey = `month-${date.getMonth()}`;
      if (el)
        monthRefs.value.set(refKey, el);
    }
    watch(
      () => props.focusedDate.month,
      (month) => {
        const refKey = `month-${month}`;
        nextTick(() => {
          const ref2 = monthRefs.value.get(refKey);
          if ((ref2 == null ? void 0 : ref2.length) > 0 && ref2[0]) {
            ref2[0].focus();
          }
        });
      }
    );
    const eventsInThisYear = computed(() => {
      if (!datepicker.value.events)
        return [];
      return datepicker.value.events.map((event) => {
        if (!event.date && event instanceof Date)
          event = { date: event };
        if (!event.type)
          event.type = "is-primary";
        return event;
      }).filter((event) => event.date.getFullYear() === props.focusedDate.year);
    });
    const monthDates = computed(() => {
      const year = props.focusedDate.year;
      const months = [];
      for (let i = 0; i < 12; i++) {
        const d = new Date(year, i, 1);
        d.setHours(0, 0, 0, 0);
        months.push(d);
      }
      return months;
    });
    const hoveredDateRange = computed(() => {
      if (!datepicker.value.range || !selectedEndDate.value)
        return [];
      return (hoveredEndDate.value < selectedBeginDate.value ? [hoveredEndDate.value, selectedBeginDate.value] : [selectedBeginDate.value, hoveredEndDate.value]).filter(isDefined);
    });
    function eventsDateMatch(day) {
      if (!eventsInThisYear.value.length)
        return [];
      return eventsInThisYear.value.filter(
        (event) => event.date.getMonth() === day.getMonth()
      );
    }
    function isDateSelectable(date) {
      const validity = [];
      if (datepicker.value.minDate)
        validity.push(date >= datepicker.value.minDate);
      if (datepicker.value.maxDate)
        validity.push(date <= datepicker.value.maxDate);
      validity.push(date.getFullYear() === props.focusedDate.year);
      if (datepicker.value.selectableDates) {
        if (typeof datepicker.value.selectableDates === "function") {
          if (datepicker.value.selectableDates(date))
            return true;
          else
            validity.push(false);
        } else {
          for (let i = 0; i < datepicker.value.selectableDates.length; i++) {
            const enabledDate = datepicker.value.selectableDates[i];
            if (date.getFullYear() === enabledDate.getFullYear() && date.getMonth() === enabledDate.getMonth())
              return true;
            else
              validity.push(false);
          }
        }
      }
      if (datepicker.value.unselectableDates) {
        if (typeof datepicker.value.unselectableDates === "function") {
          validity.push(!datepicker.value.unselectableDates(date));
        } else {
          for (let i = 0; i < datepicker.value.unselectableDates.length; i++) {
            const disabledDate = datepicker.value.unselectableDates[i];
            validity.push(
              date.getFullYear() !== disabledDate.getFullYear() || date.getMonth() !== disabledDate.getMonth()
            );
          }
        }
      }
      if (datepicker.value.unselectableDaysOfWeek) {
        for (let i = 0; i < datepicker.value.unselectableDaysOfWeek.length; i++) {
          const dayOfWeek = datepicker.value.unselectableDaysOfWeek[i];
          validity.push(date.getDay() !== dayOfWeek);
        }
      }
      return validity.indexOf(false) < 0;
    }
    function onKeydown(event, weekDay) {
      let preventDefault = true;
      switch (event.key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          selectDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault)
        event.preventDefault();
    }
    function selectDate(date) {
      if (datepicker.value.disabled || datepicker.value.readonly)
        return;
      if (!datepicker.value.range && !datepicker.value.multiple && isDateSelectable(date))
        emits("update:modelValue", date);
      else if (datepicker.value.range)
        handleSelectRangeDate(date);
      else if (datepicker.value.multiple)
        handleSelectMultipleDates(date);
    }
    function handleSelectRangeDate(date) {
      if (selectedBeginDate.value && selectedEndDate.value) {
        selectedBeginDate.value = date;
        selectedEndDate.value = void 0;
        emits("range-start", date);
      } else if (selectedBeginDate.value && !selectedEndDate.value) {
        if (selectedBeginDate.value > date) {
          selectedEndDate.value = selectedBeginDate.value;
          selectedBeginDate.value = date;
        } else {
          selectedEndDate.value = date;
        }
        emits("range-end", date);
        emits("update:modelValue", [
          selectedBeginDate.value,
          selectedEndDate.value
        ]);
      } else {
        selectedBeginDate.value = date;
        emits("range-start", date);
      }
    }
    const multipleSelectedDates = computed(
      () => datepicker.value.multiple && props.modelValue ? props.modelValue : []
    );
    function handleSelectMultipleDates(date) {
      if (!Array.isArray(props.modelValue))
        return;
      let multipleSelectedDates2 = props.modelValue;
      const multipleSelect = multipleSelectedDates2.filter(
        (selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth()
      );
      if (multipleSelect.length) {
        multipleSelectedDates2 = multipleSelectedDates2.filter(
          (selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth()
        );
      } else {
        multipleSelectedDates2.push(date);
      }
      emits("update:modelValue", multipleSelectedDates2);
    }
    function changeFocus(month, inc) {
      month.setMonth(month.getMonth() + inc);
      const focused = {
        day: month.getDate(),
        month: month.getMonth(),
        year: month.getFullYear()
      };
      emits("update:focusedDate", focused);
    }
    function onRangeHoverEndDate(day) {
      if (datepicker.value.range)
        hoveredEndDate.value = day;
    }
    function dateMatch(dateOne, dateTwo, multiple = false) {
      if (!dateOne || !dateTwo || multiple)
        return false;
      if (Array.isArray(dateTwo))
        return dateTwo.some(
          (date) => dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
        );
      return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
    }
    function dateWithin(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || multiple)
        return false;
      return dateOne > dates[0] && dateOne < dates[1];
    }
    function dateMultipleSelected(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || !multiple)
        return false;
      return dates.some(
        (date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
      );
    }
    const monthClasses = defineClasses(["monthClass", "o-dpck__month"]);
    const monthBodyClasses = defineClasses([
      "monthBodyClass",
      "o-dpck__month__body"
    ]);
    const monthTableClasses = defineClasses([
      "monthTableClass",
      "o-dpck__month__table"
    ]);
    const monthCellClasses = defineClasses(
      ["monthCellClass", "o-dpck__month__cell"],
      ["monthCellEventsClass", "o-dpck__month__cell--events", null, hasEvents]
    );
    function cellClasses(day) {
      const classes = defineClasses(
        [
          "monthCellSelectedClass",
          "o-dpck__month__cell--selected",
          null,
          dateMatch(day, props.modelValue, datepicker.value.multiple) || dateWithin(day, props.modelValue, datepicker.value.multiple) || dateMultipleSelected(
            day,
            multipleSelectedDates.value,
            datepicker.value.multiple
          )
        ],
        [
          "monthCellFirstSelectedClass",
          "o-dpck__month__cell--first-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.modelValue) && props.modelValue[0],
            datepicker.value.multiple
          )
        ],
        [
          "monthCellWithinSelectedClass",
          "o-dpck__month__cell--within-selected",
          null,
          dateWithin(day, props.modelValue, datepicker.value.multiple)
        ],
        [
          "monthCellLastSelectedClass",
          "o-dpck__month__cell--last-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.modelValue) && props.modelValue[1],
            datepicker.value.multiple
          )
        ],
        [
          "monthCellWithinHoveredRangeClass",
          "o-dpck__month__cell--within-hovered-range",
          null,
          hoveredDateRange.value && hoveredDateRange.value.length === 2 && (dateMatch(day, hoveredDateRange.value) || dateWithin(day, hoveredDateRange.value))
        ],
        [
          "monthCellFirstHoveredClass",
          "o-dpck__month__cell--first-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(hoveredDateRange.value) && hoveredDateRange.value[0]
          )
        ],
        [
          "monthCellWithinHoveredClass",
          "o-dpck__month__cell--within-hovered",
          null,
          dateWithin(day, hoveredDateRange.value)
        ],
        [
          "monthCellLastHoveredClass",
          "o-dpck__month__cell--last-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(hoveredDateRange.value) && hoveredDateRange.value[1]
          )
        ],
        [
          "monthCellTodayClass",
          "o-dpck__month__cell--today",
          null,
          dateMatch(day, datepicker.value.dateCreator())
        ],
        [
          "monthCellSelectableclass",
          "o-dpck__month__cell--selectable",
          null,
          isDateSelectable(day) && !datepicker.value.disabled && !datepicker.value.readonly
        ],
        [
          "monthCellUnselectableClass",
          "o-dpck__month__cell--unselectable",
          null,
          !isDateSelectable(day) || datepicker.value.disabled
        ]
      );
      return [...monthCellClasses.value, ...classes.value];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(unref(monthClasses))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(monthBodyClasses))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(unref(monthTableClasses))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(monthDates.value, (date, idx) => {
              return openBlock(), createElementBlock(Fragment, { key: idx }, [
                !datepicker.value.disabled && !datepicker.value.readonly && isDateSelectable(date) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: (el) => setMonthRef(date, el),
                  class: normalizeClass(cellClasses(date)),
                  role: "button",
                  tabindex: __props.focusedDate.month === date.getMonth() ? null : 0,
                  onClick: withModifiers(($event) => selectDate(date), ["prevent"]),
                  onMouseenter: ($event) => onRangeHoverEndDate(date),
                  onFocus: ($event) => onRangeHoverEndDate(date),
                  onKeydown: withModifiers(($event) => onKeydown($event, date), ["prevent"])
                }, [
                  createTextVNode(toDisplayString(__props.monthNames[date.getMonth()]) + " ", 1),
                  eventsDateMatch(date).length ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(eventsDateMatch(date), (event, index30) => {
                      return openBlock(), createElementBlock("div", {
                        key: index30,
                        class: normalizeClass(["event", event.type])
                      }, null, 2);
                    }), 128))
                  ])) : createCommentVNode("", true)
                ], 42, _hoisted_1$12)) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(cellClasses(date))
                }, toDisplayString(__props.monthNames[date.getMonth()]), 3))
              ], 64);
            }), 128))
          ], 2)
        ], 2)
      ], 2);
    };
  }
});
var _hoisted_19 = ["value", "disabled"];
var _hoisted_25 = ["value"];
var _sfc_main12 = defineComponent({
  ...{
    isOruga: true,
    name: "ODatepicker",
    configField: "datepicker"
  },
  __name: "Datepicker",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /**
     * Define picker mode
     * @values date, month
     */
    type: {
      type: String,
      default: "date",
      validator: (value) => ["month", "date"].indexOf(value) >= 0
    },
    /** Set custom day names, else use names based on locale */
    dayNames: {
      type: Array,
      default: () => getOption("datepicker.dayNames", void 0)
    },
    /** Set custom month names, else use names based on locale */
    monthNames: {
      type: Array,
      default: () => getOption("datepicker.monthNames", void 0)
    },
    /**
     * Size of the control input
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("datepicker.size")
    },
    /** Set default date to focus on */
    focusedDate: { type: Date, default: void 0 },
    /** Events to display on picker */
    events: { type: Array, default: void 0 },
    /** Event indicators for style class definiton */
    indicators: { type: String, default: "dots" },
    /** Min date to select */
    minDate: { type: Date, default: void 0 },
    /** Max date to select */
    maxDate: { type: Date, default: void 0 },
    /** Enable date range selection */
    range: { type: Boolean, default: false },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: false },
    /** Display datepicker inline */
    inline: { type: Boolean, default: false },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: false },
    /** Same as native, also push new item to v-model instead of replacing */
    multiple: { type: Boolean, default: false },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => getOption("datepicker.openOnFocus", true)
    },
    /** Close dropdown on click */
    closeOnClick: {
      type: Boolean,
      default: () => getOption("datepicker.closeOnClick", true)
    },
    /** Date format locale */
    locale: {
      type: String,
      default: () => getOption("locale")
    },
    /** Custom function to format a date into a string */
    dateFormatter: {
      type: Function,
      default: (date, defaultFunction) => getOption("datepicker.dateFormatter", defaultFunction)(date)
    },
    /** Custom function to parse a string into a date */
    dateParser: {
      type: Function,
      default: (date, defaultFunction) => getOption("datepicker.dateParser", defaultFunction)(date)
    },
    /** Date creator function, default is `new Date()` */
    dateCreator: {
      type: Function,
      default: () => getOption("datepicker.dateCreator", () => /* @__PURE__ */ new Date())()
    },
    /** Define a list of dates which can be selected */
    selectableDates: {
      type: [Array, Function],
      default: () => []
    },
    /** Define a list of dates which can not be selected */
    unselectableDates: {
      type: [Array, Function],
      default: () => []
    },
    /** Define a list of weeks which can not be selected */
    unselectableDaysOfWeek: {
      type: Array,
      default: () => getOption("datepicker.unselectableDaysOfWeek", void 0)
    },
    /** Show nearby month days */
    nearbyMonthDays: {
      type: Boolean,
      default: () => getOption("datepicker.nearbyMonthDays", true)
    },
    /** Define if nearby month days can be selected */
    nearbySelectableMonthDays: {
      type: Boolean,
      default: () => getOption("datepicker.nearbySelectableMonthDays", false)
    },
    /** Show weeek numbers */
    showWeekNumber: {
      type: Boolean,
      default: () => getOption("datepicker.showWeekNumber", false)
    },
    /** Define if weeek numbers are clickable */
    weekNumberClickable: {
      type: Boolean,
      default: () => getOption("datepicker.weekNumberClickable", false)
    },
    /** Set the first day of a week */
    firstDayOfWeek: {
      type: Number,
      default: () => getOption("datepicker.firstDayOfWeek", 0)
    },
    /** Rules for the first week : 1 for the 1st January, 4 for the 4th January */
    rulesForFirstWeek: { type: Number, default: () => 4 },
    /** Define the range of years to show */
    yearsRange: {
      type: Array,
      default: () => getOption("datepicker.yearsRange", [-100, 10])
    },
    /** Trap dropdown on focus */
    trapFocus: {
      type: Boolean,
      default: () => getOption("datepicker.trapFocus", true)
    },
    /** Position of the dropdown relative to the input */
    position: { type: String, default: void 0 },
    /** Enable dropdown mobile modal */
    mobileModal: {
      type: Boolean,
      default: () => getOption("datepicker.mobileModal", true)
    },
    /**
     * Enable mobile native input if mobile agent
     * (Default will be switched to `false` in 0.9)
     */
    mobileNative: {
      type: Boolean,
      default: () => getOption("datepicker.mobileNative", true)
      // TODO: make false
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("datepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("datepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("datepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /** Icon name for previous icon */
    iconPrev: {
      type: String,
      default: () => getOption("datepicker.iconPrev", "chevron-left")
    },
    /** Icon name for next icon */
    iconNext: {
      type: String,
      default: () => getOption("datepicker.iconNext", "chevron-right")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("datepicker.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("datepicker.teleport", false)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /** Accessibility next button aria label */
    ariaNextLabel: {
      type: String,
      default: () => getOption("datepicker.ariaNextLabel", "Next Page")
    },
    /** Accessibility previous button aria label  */
    ariaPreviousLabel: {
      type: String,
      default: () => getOption("datepicker.ariaNextLabel", "Previous Page")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker box where you choose the date */
    boxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker header inside the box */
    headerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker buttons inside the box */
    headerButtonsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker buttons inside the box when a size is choosen */
    headerButtonsSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the prev button inside the Datepicker box */
    prevButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the next button inside the Datepicker box */
    nextButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the month and year selects container inside the Datepicker box */
    listsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker table inside the box */
    tableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Datepicker header with days of the week inside the table */
    tableHeadClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the cell inside the table header */
    tableHeadCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table body inside the box */
    tableBodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table row */
    tableRowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell */
    tableCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when nearby month days are hidden */
    tableCellInvisibleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of table cell when it's selected */
    tableCellSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first selected table cell when in range */
    tableCellFirstSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cells within the range when the range is selected */
    tableCellWithinSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last selected table cell during range selection */
    tableCellLastSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first hovered table cell during range selection */
    tableCellFirstHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection */
    tableCellWithinHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last table cell hovered during range selection */
    tableCellLastHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell of the current day */
    tableCellTodayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is selectable */
    tableCellSelectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is unselectable */
    tableCellUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when nearby days (prev/next month) are selectable */
    tableCellNearbyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the cell of a row when at least one event is present */
    tableCellEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the events container */
    tableEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event */
    tableEventClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event indicator when a `variant` is specified */
    tableEventVariantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event indicator */
    tableEventIndicatorsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker table inside the box when type is month */
    monthClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table body inside the box when type is month */
    monthBodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table container when type is month */
    monthTableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when type is month */
    monthCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of table cell when it's selected when type is month */
    monthCellSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first selected table cell when in range when type is month */
    monthCellFirstSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cells within the range when the range is selected when type is month */
    monthCellWithinSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last selected table cell during range selection when type is month */
    monthCellLastSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first hovered table cell during range selection when type is month */
    monthCellWithinHoveredRangeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection when type is month */
    monthCellFirstHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection and cell is in range when type is month */
    monthCellWithinHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last table cell hovered during range selection when type is month */
    monthCellLastHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell of the current day when type is month */
    monthCellTodayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is selectable when type is month */
    monthCellSelectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is unselectable when type is month */
    monthCellUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**Class of the events container when type is month */
    monthCellEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => getOption("datepicker.inputClasses", {})
    },
    /**
     * Class configuration for the internal dropdown component
     * @ignore
     */
    dropdownClasses: {
      type: Object,
      default: () => getOption(
        "datepicker.dropdownClasses",
        {}
      )
    },
    /**
     * Class configuration for the internal select component
     * @ignore
     */
    selectClasses: {
      type: Object,
      default: () => getOption("datepicker.selectClasses", {})
    }
  }, {
    "modelValue": { default: null },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { defaultDateFormatter, defaultDateParser } = useDatepickerMixins(props);
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const pickerRef = ref();
    const vmodel = useModel(__props, "modelValue");
    const isActive = useModel(__props, "active");
    const formattedValue = computed(
      () => Array.isArray(vmodel.value) ? props.dateFormatter([...vmodel.value], defaultDateFormatter) : props.dateFormatter(vmodel.value, defaultDateFormatter)
    );
    const isTypeMonth = computed(() => props.type === "month");
    watch(
      () => props.modelValue,
      (value) => {
        const isArray = Array.isArray(value);
        const currentDate = isArray ? value.length ? value[value.length - 1] : props.dateCreator() : value ? value : props.dateCreator();
        if (!isArray || isArray && Array.isArray(vmodel.value) && value.length > vmodel.value.length)
          focusedDateData.value = {
            day: currentDate.getDate(),
            month: currentDate.getMonth(),
            year: currentDate.getFullYear()
          };
      }
    );
    watch(
      () => props.focusedDate,
      (value) => {
        if (value) {
          focusedDateData.value = {
            day: value.getDate(),
            month: value.getMonth(),
            year: value.getFullYear()
          };
        }
      }
    );
    const _initialDate = (Array.isArray(props.modelValue) ? props.modelValue[0] : props.modelValue) || props.focusedDate || props.dateCreator();
    if (!props.modelValue && props.maxDate && props.maxDate.getFullYear() < _initialDate.getFullYear()) {
      _initialDate.setFullYear(props.maxDate.getFullYear());
    }
    const focusedDateData = ref({
      day: _initialDate.getDate(),
      month: _initialDate.getMonth(),
      year: _initialDate.getFullYear()
    });
    watch(
      () => focusedDateData.value.month,
      (value) => emits("change-month", value)
    );
    watch(
      () => focusedDateData.value.year,
      (value) => emits("change-year", value)
    );
    const computedMonthNames = computed(
      () => Array.isArray(props.monthNames) ? props.monthNames : getMonthNames(props.locale)
    );
    const listOfMonths = computed(() => {
      let minMonth = 0;
      let maxMonth = 12;
      if (props.minDate && focusedDateData.value.year === props.minDate.getFullYear()) {
        minMonth = props.minDate.getMonth();
      }
      if (props.maxDate && focusedDateData.value.year === props.maxDate.getFullYear()) {
        maxMonth = props.maxDate.getMonth();
      }
      return computedMonthNames.value.map((name, index30) => ({
        name,
        index: index30,
        disabled: index30 < minMonth || index30 > maxMonth
      }));
    });
    const computedDayNames = computed(() => {
      if (Array.isArray(props.dayNames))
        return props.dayNames;
      return getWeekdayNames(props.locale);
    });
    const listOfYears = computed(() => {
      let latestYear = focusedDateData.value.year + props.yearsRange[1];
      if (props.maxDate && props.maxDate.getFullYear() < latestYear) {
        latestYear = Math.max(
          props.maxDate.getFullYear(),
          focusedDateData.value.year
        );
      }
      let earliestYear = focusedDateData.value.year + props.yearsRange[0];
      if (props.minDate && props.minDate.getFullYear() > earliestYear) {
        earliestYear = Math.min(
          props.minDate.getFullYear(),
          focusedDateData.value.year
        );
      }
      return Array.from(
        { length: latestYear - earliestYear + 1 || 1 },
        (value, index30) => earliestYear + index30
      ).reverse();
    });
    const showPrev = computed(() => {
      if (!props.minDate)
        return true;
      if (isTypeMonth.value)
        return focusedDateData.value.year > props.minDate.getFullYear();
      const dateToCheck = new Date(
        focusedDateData.value.year,
        focusedDateData.value.month
      );
      const date = new Date(
        props.minDate.getFullYear(),
        props.minDate.getMonth()
      );
      return dateToCheck > date;
    });
    function prev() {
      if (props.disabled)
        return;
      if (isTypeMonth.value) {
        focusedDateData.value.year -= 1;
      } else {
        if (focusedDateData.value.month > 0) {
          focusedDateData.value.month -= 1;
        } else {
          focusedDateData.value.month = 11;
          focusedDateData.value.year -= 1;
        }
      }
    }
    const showNext = computed(() => {
      if (!props.maxDate)
        return true;
      if (isTypeMonth.value)
        return focusedDateData.value.year < props.maxDate.getFullYear();
      const dateToCheck = new Date(
        focusedDateData.value.year,
        focusedDateData.value.month
      );
      const date = new Date(
        props.maxDate.getFullYear(),
        props.maxDate.getMonth()
      );
      return dateToCheck < date;
    });
    function next() {
      if (props.disabled)
        return;
      if (isTypeMonth.value) {
        focusedDateData.value.year += 1;
      } else {
        if (focusedDateData.value.month < 11) {
          focusedDateData.value.month += 1;
        } else {
          focusedDateData.value.month = 0;
          focusedDateData.value.year += 1;
        }
      }
    }
    function formatNative(value) {
      if (Array.isArray(value))
        value = value[0];
      const date = new Date(value);
      if (!value || !date || isNaN(date.getTime()))
        return null;
      if (isTypeMonth.value) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        return year + "-" + ((month < 10 ? "0" : "") + month);
      } else {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return year + "-" + ((month < 10 ? "0" : "") + month) + "-" + ((day < 10 ? "0" : "") + day);
      }
    }
    function onChange(value) {
      const date = props.dateParser(value, defaultDateParser);
      const isValid = isDate(date) || Array.isArray(date) && date.length === 2 && isDate(date[0]) && isDate(date[1]);
      vmodel.value = isValid ? date : null;
    }
    function onChangeNativePicker(value) {
      const s = value ? value.split("-") : [];
      if (s.length === 3) {
        const year = parseInt(s[0], 10);
        const month = parseInt(s[1]) - 1;
        const day = parseInt(s[2]);
        vmodel.value = new Date(year, month, day);
      } else {
        vmodel.value = null;
      }
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-dpck"],
      [
        "sizeClass",
        "o-dpck--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      ["mobileClass", "o-dpck--mobile", null, isMobile],
      ["expandedClass", "o-dpck--expanded", null, computed(() => props.expanded)]
    );
    const headerClasses = defineClasses(["headerClass", "o-dpck__header"]);
    const headerButtonsClasses = defineClasses(
      ["headerButtonsClass", "o-dpck__header__buttons"],
      [
        "headerButtonsSizeClass",
        "o-dpck__header__buttons--",
        computed(() => props.size),
        computed(() => !!props.size)
      ]
    );
    const prevButtonClasses = defineClasses([
      "prevButtonClass",
      "o-dpck__header__previous"
    ]);
    const nextButtonClasses = defineClasses([
      "nextButtonClass",
      "o-dpck__header__next"
    ]);
    const listsClasses = defineClasses(["listsClass", "o-dpck__header__list"]);
    const footerClasses = defineClasses(["footerClass", "o-dpck__footer"]);
    const dropdownClass = defineClasses([
      "dropdownClasses.rootClass",
      "o-tpck__dropdown"
    ]);
    const boxClasses = defineClasses(["boxClass", "o-dpck__box"]);
    const boxClassBind = computed(() => getActiveClasses(boxClasses.value));
    __expose({ focus: () => {
      var _a;
      return (_a = pickerRef.value) == null ? void 0 : _a.focus();
    } });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main11, {
        ref_key: "pickerRef",
        ref: pickerRef,
        active: isActive.value,
        "onUpdate:active": _cache[10] || (_cache[10] = ($event) => isActive.value = $event),
        "data-oruga": "datepicker",
        value: vmodel.value,
        picker: props,
        "formatted-value": formattedValue.value,
        "native-type": !isTypeMonth.value ? "date" : "month",
        "native-value": formatNative(vmodel.value),
        "native-max": formatNative(__props.maxDate),
        "native-min": formatNative(__props.minDate),
        "stay-open": __props.multiple,
        "dropdown-classes": unref(dropdownClass),
        "root-classes": unref(rootClasses),
        "box-class": boxClassBind.value,
        onChange,
        onNativeChange: onChangeNativePicker,
        onFocus: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("focus", $event)),
        onBlur: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("blur", $event)),
        onInvalid: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("invalid", $event)),
        onIconClick: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("icon-click", $event)),
        onIconRightClick: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("icon-right-click", $event))
      }, createSlots({
        default: withCtx(() => [
          createBaseVNode("header", {
            class: normalizeClass(unref(headerClasses))
          }, [
            renderSlot(_ctx.$slots, "header", {}, () => [
              createBaseVNode("div", {
                class: normalizeClass(unref(headerButtonsClasses))
              }, [
                !__props.disabled ? (openBlock(), createBlock(_sfc_main6, {
                  key: 0,
                  class: normalizeClass(unref(prevButtonClasses)),
                  disabled: !showPrev.value,
                  "aria-label": __props.ariaPreviousLabel,
                  "icon-pack": __props.iconPack,
                  "icon-left": __props.iconPrev,
                  outlined: "",
                  onClick: withModifiers(prev, ["prevent"]),
                  onKeydown: [
                    withKeys(withModifiers(prev, ["prevent"]), ["enter"]),
                    withKeys(withModifiers(prev, ["prevent"]), ["space"])
                  ]
                }, null, 8, ["class", "disabled", "aria-label", "icon-pack", "icon-left", "onKeydown"])) : createCommentVNode("", true),
                !__props.disabled ? (openBlock(), createBlock(_sfc_main6, {
                  key: 1,
                  class: normalizeClass(unref(nextButtonClasses)),
                  disabled: !showNext.value,
                  "aria-label": __props.ariaNextLabel,
                  "icon-pack": __props.iconPack,
                  "icon-left": __props.iconNext,
                  outlined: "",
                  onClick: withModifiers(next, ["prevent"]),
                  onKeydown: [
                    withKeys(withModifiers(next, ["prevent"]), ["enter"]),
                    withKeys(withModifiers(next, ["prevent"]), ["space"])
                  ]
                }, null, 8, ["class", "disabled", "aria-label", "icon-pack", "icon-left", "onKeydown"])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: normalizeClass(unref(listsClasses))
                }, [
                  !isTypeMonth.value ? (openBlock(), createBlock(_sfc_main10, mergeProps({
                    key: 0,
                    modelValue: focusedDateData.value.month,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => focusedDateData.value.month = $event),
                    disabled: __props.disabled,
                    size: __props.size
                  }, __props.selectClasses), {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(listOfMonths.value, (month) => {
                        return openBlock(), createElementBlock("option", {
                          key: month.name,
                          value: month.index,
                          disabled: month.disabled
                        }, toDisplayString(month.name), 9, _hoisted_19);
                      }), 128))
                    ]),
                    _: 1
                  }, 16, ["modelValue", "disabled", "size"])) : createCommentVNode("", true),
                  createVNode(_sfc_main10, mergeProps({
                    modelValue: focusedDateData.value.year,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => focusedDateData.value.year = $event),
                    disabled: __props.disabled,
                    size: __props.size
                  }, __props.selectClasses), {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(listOfYears.value, (year) => {
                        return openBlock(), createElementBlock("option", {
                          key: year,
                          value: year
                        }, toDisplayString(year), 9, _hoisted_25);
                      }), 128))
                    ]),
                    _: 1
                  }, 16, ["modelValue", "disabled", "size"])
                ], 2)
              ], 2)
            ])
          ], 2),
          renderSlot(_ctx.$slots, "body", {}, () => [
            isTypeMonth.value ? (openBlock(), createBlock(_sfc_main$13, {
              key: 0,
              modelValue: vmodel.value,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => vmodel.value = $event),
              "focused-date": focusedDateData.value,
              "onUpdate:focusedDate": _cache[3] || (_cache[3] = ($event) => focusedDateData.value = $event),
              "month-names": computedMonthNames.value,
              "picker-props": props,
              onRangeStart: _cache[4] || (_cache[4] = (date) => _ctx.$emit("range-start", date)),
              onRangeEnd: _cache[5] || (_cache[5] = (date) => _ctx.$emit("range-end", date))
            }, null, 8, ["modelValue", "focused-date", "month-names", "picker-props"])) : (openBlock(), createBlock(_sfc_main$2, {
              key: 1,
              modelValue: vmodel.value,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => vmodel.value = $event),
              "focused-date": focusedDateData.value,
              "onUpdate:focusedDate": _cache[7] || (_cache[7] = ($event) => focusedDateData.value = $event),
              "day-names": computedDayNames.value,
              "month-names": computedMonthNames.value,
              "picker-props": props,
              onRangeStart: _cache[8] || (_cache[8] = (date) => _ctx.$emit("range-start", date)),
              onRangeEnd: _cache[9] || (_cache[9] = (date) => _ctx.$emit("range-end", date))
            }, null, 8, ["modelValue", "focused-date", "day-names", "month-names", "picker-props"]))
          ]),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
            key: 0,
            class: normalizeClass(unref(footerClasses))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$slots.trigger ? {
          name: "trigger",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["active", "value", "picker", "formatted-value", "native-type", "native-value", "native-max", "native-min", "stay-open", "dropdown-classes", "root-classes", "box-class"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/datepicker.mjs
var index6 = {
  install(app) {
    registerComponent(app, _sfc_main12);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Timepicker.vue_vue_type_script_setup_true_lang-B7TreYFS.mjs
var AM = "AM";
var PM = "PM";
var HOUR_FORMAT_24 = "24";
var HOUR_FORMAT_12 = "12";
function useTimepickerMixins(props) {
  const localeOptions = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      hour: "numeric",
      minute: "numeric",
      second: props.enableSeconds ? "numeric" : void 0
    }).resolvedOptions()
  );
  const isHourFormat24 = computed(
    () => props.hourFormat && props.hourFormat === HOUR_FORMAT_24 || !props.hourFormat && !localeOptions.value.hour12
  );
  const dtf = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      hour: localeOptions.value.hour || "numeric",
      minute: localeOptions.value.minute || "numeric",
      second: props.enableSeconds ? localeOptions.value.second || "numeric" : void 0,
      hourCycle: !isHourFormat24.value ? "h12" : "h23"
    })
  );
  const sampleTime = computed(() => {
    const d = props.timeCreator();
    d.setHours(10);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setMilliseconds(0);
    return d;
  });
  const amString = computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = sampleTime.value;
      d.setHours(10);
      const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
      if (dayPeriod)
        return dayPeriod.value;
    }
    return AM;
  });
  const pmString = computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = sampleTime.value;
      d.setHours(20);
      const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
      if (dayPeriod) {
        return dayPeriod.value;
      }
    }
    return PM;
  });
  const meridiens = computed(() => [amString.value, pmString.value]);
  const hourLiteral = computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = sampleTime.value;
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "hour"
      );
      if (literal)
        return literal.value;
    }
    return ":";
  });
  const minuteLiteral = computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = sampleTime.value;
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "minute"
      );
      if (literal)
        return literal.value;
    }
    return ":";
  });
  const secondLiteral = computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = sampleTime.value;
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "second"
      );
      if (literal)
        return literal.value;
    }
    return void 0;
  });
  function defaultTimeFormatter(time) {
    return dtf.value.format(time);
  }
  function defaultTimeParser(time) {
    if (!time)
      return null;
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const formatRegex = dtf.value.formatToParts(sampleTime.value).map((part) => {
        if (part.type === "literal") {
          return part.value.replace(/ /g, "\\s?");
        } else if (part.type === "dayPeriod") {
          return `((?!=<${part.type}>)(${amString.value}|${pmString.value}|${AM}|${PM}|${AM.toLowerCase()}|${PM.toLowerCase()})?)`;
        }
        return `((?!=<${part.type}>)\\d+)`;
      }).join("");
      const timeGroups = matchWithGroups(formatRegex, time);
      timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
      timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
      timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;
      if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
        if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === pmString.value.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()) && timeGroups.hour < 12) {
          timeGroups.hour += 12;
        }
        const date2 = sampleTime.value;
        date2.setHours(timeGroups.hour);
        date2.setMinutes(timeGroups.minute);
        date2.setSeconds(timeGroups.second || 0);
        return date2;
      }
    }
    let am = false;
    if (props.hourFormat === HOUR_FORMAT_12) {
      const dateString12 = time.split(" ");
      time = dateString12[0];
      am = dateString12[1] === amString.value || dateString12[1] === AM;
    }
    const timeSplit = time.split(":");
    let hours = parseInt(timeSplit[0], 10);
    const minutes = parseInt(timeSplit[1], 10);
    const seconds = props.enableSeconds ? parseInt(timeSplit[2], 10) : 0;
    if (isNaN(hours) || hours < 0 || hours > 23 || props.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
      return null;
    }
    const date = sampleTime.value;
    date.setSeconds(seconds);
    date.setMinutes(minutes);
    if (props.hourFormat === HOUR_FORMAT_12) {
      if (am && hours === 12) {
        hours = 0;
      } else if (!am && hours !== 12) {
        hours += 12;
      }
    }
    date.setHours(hours);
    return new Date(date.getTime());
  }
  return {
    defaultTimeFormatter,
    defaultTimeParser,
    pmString,
    amString,
    meridiens,
    isHourFormat24,
    hourLiteral,
    minuteLiteral,
    secondLiteral
  };
}
var _hoisted_110 = ["value", "disabled"];
var _hoisted_26 = ["value", "disabled"];
var _hoisted_32 = ["value", "disabled"];
var _hoisted_4 = ["value", "disabled"];
var _sfc_main13 = defineComponent({
  ...{
    isOruga: true,
    name: "OTimepicker",
    configField: "timepicker"
  },
  __name: "Timepicker",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Date, default: void 0 },
    /** The active state of the dropdown */
    active: { type: Boolean, default: false },
    /** Min time to select */
    minTime: { type: Date, default: void 0 },
    /** Max time to select */
    maxTime: { type: Date, default: void 0 },
    /** Display datepicker inline */
    inline: { type: Boolean, default: false },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: false },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: false },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /**
     * Size of the button
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("timepicker.size")
    },
    hourFormat: {
      type: [String, Number],
      validator: (value) => ["12", "24", 12, 24, void 0].includes(value),
      default: void 0
    },
    incrementHours: { type: Number, default: 1 },
    incrementMinutes: { type: Number, default: 1 },
    incrementSeconds: { type: Number, default: 1 },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => getOption("timepicker.openOnFocus", true)
    },
    /** Close dropdown on click */
    closeOnClick: {
      type: Boolean,
      default: () => getOption("timepicker.closeOnClick", true)
    },
    enableSeconds: { type: Boolean, default: false },
    defaultMinutes: { type: Number, default: void 0 },
    defaultSeconds: { type: Number, default: void 0 },
    /** Date format locale */
    locale: {
      type: String,
      default: () => getOption("locale")
    },
    /** Custom function to format a date into a string */
    timeFormatter: {
      type: Function,
      default: (date, defaultFunction) => getOption("timepicker.timeFormatter", defaultFunction)(date)
    },
    /** Custom function to parse a string into a date */
    timeParser: {
      type: Function,
      default: (date, defaultFunction) => getOption("timepicker.timeParser", defaultFunction)(date)
    },
    /** time creator function, default is `new Date()` */
    timeCreator: {
      type: Function,
      default: () => getOption("timepicker.timeCreator", () => /* @__PURE__ */ new Date())()
    },
    /** Define a list of times which can not be selected */
    unselectableTimes: {
      type: [Array, Function],
      default: () => []
    },
    /** Reset the time inputs when meridian changes */
    resetOnMeridianChange: {
      type: Boolean,
      default: false
    },
    /** Dropdown trapFocus */
    trapFocus: {
      type: Boolean,
      default: () => getOption("timepicker.trapFocus", true)
    },
    /** Dropdown position */
    position: { type: String, default: void 0 },
    /** Enable dropdown mobile modal */
    mobileModal: {
      type: Boolean,
      default: () => getOption("timepicker.mobileModal", true)
    },
    /** Enable mobile native input if mobile agent */
    mobileNative: {
      type: Boolean,
      default: () => getOption("timepicker.mobileNative", true)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("timepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("timepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("timepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("timepicker.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("timepicker.teleport", false)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker component size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker component box where you choose the date */
    boxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker separator */
    separatorClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => getOption("timepicker.inputClasses", {})
    },
    /**
     * Class configuration for the internal dropdown component
     * @ignore
     */
    dropdownClasses: {
      type: Object,
      default: () => getOption("timepicker.dropdownClasses", {})
    },
    /**
     * Class configuration for the internal select component
     * @ignore
     */
    selectClasses: {
      type: Object,
      default: () => getOption("timepicker.selectClasses", {})
    }
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "update:active", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const {
      defaultTimeFormatter,
      defaultTimeParser,
      pmString,
      amString,
      meridiens,
      isHourFormat24,
      hourLiteral,
      minuteLiteral,
      secondLiteral
    } = useTimepickerMixins(props);
    const pickerRef = ref();
    const vmodel = useModel(__props, "modelValue");
    const isActive = useModel(__props, "active");
    const hoursSelected = ref();
    const minutesSelected = ref();
    const secondsSelected = ref();
    const meridienSelected = ref();
    watch(
      () => props.modelValue,
      (value) => {
        if (value) {
          hoursSelected.value = value.getHours();
          minutesSelected.value = value.getMinutes();
          secondsSelected.value = value.getSeconds();
          meridienSelected.value = value.getHours() >= 12 ? pmString.value : amString.value;
        } else {
          hoursSelected.value = null;
          minutesSelected.value = null;
          secondsSelected.value = null;
          meridienSelected.value = amString.value;
        }
      },
      { immediate: true }
    );
    const formattedValue = computed(
      () => props.timeFormatter(props.modelValue, defaultTimeFormatter)
    );
    const nativeStep = computed(() => props.enableSeconds ? "1" : null);
    watch(
      () => props.hourFormat,
      () => {
        if (hoursSelected.value !== null) {
          meridienSelected.value = hoursSelected.value >= 12 ? pmString.value : amString.value;
        }
      }
    );
    watch(
      () => props.locale,
      (value) => {
        if (!value)
          meridienSelected.value = amString.value;
      }
    );
    function formatNumber(value, prependZero) {
      return isHourFormat24.value || prependZero ? pad(value) : String(value);
    }
    function pad(value) {
      return (value < 10 ? "0" : "") + value;
    }
    const hours = computed(() => {
      if (!props.incrementHours || props.incrementHours < 1)
        throw new Error("Hour increment cannot be null or less than 1.");
      const hours2 = [];
      const numberOfHours = isHourFormat24.value ? 24 : 12;
      for (let i = 0; i < numberOfHours; i += props.incrementHours) {
        let value = i;
        let label = value;
        if (!isHourFormat24.value) {
          value = i + 1;
          label = value;
          if (meridienSelected.value === amString.value) {
            if (value === 12) {
              value = 0;
            }
          } else if (meridienSelected.value === pmString.value) {
            if (value !== 12) {
              value += 12;
            }
          }
        }
        hours2.push({
          label: formatNumber(label, false),
          value
        });
      }
      return hours2;
    });
    const minutes = computed(() => {
      if (!props.incrementMinutes || props.incrementMinutes < 1)
        throw new Error("Minute increment cannot be null or less than 1.");
      const minutes2 = [];
      for (let i = 0; i < 60; i += props.incrementMinutes) {
        minutes2.push({
          label: formatNumber(i, true),
          value: i
        });
      }
      return minutes2;
    });
    const seconds = computed(() => {
      if (!props.incrementSeconds || props.incrementSeconds < 1)
        throw new Error("Second increment cannot be null or less than 1.");
      const seconds2 = [];
      for (let i = 0; i < 60; i += props.incrementSeconds) {
        seconds2.push({
          label: formatNumber(i, true),
          value: i
        });
      }
      return seconds2;
    });
    function isHourDisabled(hour) {
      let disabled = false;
      if (props.minTime) {
        const minHours = props.minTime.getHours();
        const noMinutesAvailable = minutes.value.every((minute) => {
          return isMinuteDisabledForHour(hour, minute.value);
        });
        disabled = hour < minHours || noMinutesAvailable;
      }
      if (props.maxTime) {
        if (!disabled) {
          const maxHours = props.maxTime.getHours();
          disabled = hour > maxHours;
        }
      }
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hour);
          date.setMinutes(minutesSelected.value);
          date.setSeconds(secondsSelected.value);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            if (props.enableSeconds && secondsSelected.value !== null) {
              return time.getHours() === hour && time.getMinutes() === minutesSelected.value && time.getSeconds() === secondsSelected.value;
            } else if (minutesSelected.value !== null) {
              return time.getHours() === hour && time.getMinutes() === minutesSelected.value;
            }
            return false;
          });
          if (unselectable.length > 0) {
            disabled = true;
          } else {
            disabled = minutes.value.every((minute) => {
              return props.unselectableTimes.filter((time) => {
                return time.getHours() === hour && time.getMinutes() === minute.value;
              }).length > 0;
            });
          }
        }
      }
      return disabled;
    }
    function isMinuteDisabledForHour(hour, minute) {
      let disabled = false;
      if (props.minTime) {
        const minHours = props.minTime.getHours();
        const minMinutes = props.minTime.getMinutes();
        disabled = hour === minHours && minute < minMinutes;
      }
      if (props.maxTime) {
        if (!disabled) {
          const maxHours = props.maxTime.getHours();
          const maxMinutes = props.maxTime.getMinutes();
          disabled = hour === maxHours && minute > maxMinutes;
        }
      }
      return disabled;
    }
    function isMinuteDisabled(minute) {
      if (hoursSelected.value === null)
        return false;
      let disabled = isHourDisabled(hoursSelected.value) ? true : isMinuteDisabledForHour(hoursSelected.value, minute);
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hoursSelected.value);
          date.setMinutes(minute);
          date.setSeconds(secondsSelected.value);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            if (props.enableSeconds && secondsSelected.value !== null) {
              return time.getHours() === hoursSelected.value && time.getMinutes() === minute && time.getSeconds() === secondsSelected.value;
            } else {
              return time.getHours() === hoursSelected.value && time.getMinutes() === minute;
            }
          });
          disabled = unselectable.length > 0;
        }
      }
    }
    function isSecondDisabled(second) {
      if (minutesSelected.value == null)
        return false;
      let disabled = false;
      if (isMinuteDisabled(minutesSelected.value)) {
        disabled = true;
      } else {
        if (props.minTime) {
          const minHours = props.minTime.getHours();
          const minMinutes = props.minTime.getMinutes();
          const minSeconds = props.minTime.getSeconds();
          disabled = hoursSelected.value === minHours && minutesSelected.value === minMinutes && second < minSeconds;
        }
        if (props.maxTime) {
          if (!disabled) {
            const maxHours = props.maxTime.getHours();
            const maxMinutes = props.maxTime.getMinutes();
            const maxSeconds = props.maxTime.getSeconds();
            disabled = hoursSelected.value === maxHours && minutesSelected.value === maxMinutes && second > maxSeconds;
          }
        }
      }
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hoursSelected.value);
          date.setMinutes(minutesSelected.value);
          date.setSeconds(second);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            return time.getHours() === hoursSelected.value && time.getMinutes() === minutesSelected.value && time.getSeconds() === second;
          });
          disabled = unselectable.length > 0;
        }
      }
    }
    function isMeridienDisabled(meridienString) {
      const offset = meridienString == "AM" ? 0 : 12;
      for (let i = 0; i < 12; i++) {
        if (!isHourDisabled(i + offset))
          return false;
      }
      return true;
    }
    function updateDateSelected(hours2, minutes2, seconds2, meridiens2) {
      if (hours2 != null && minutes2 != null && (!isHourFormat24.value && meridiens2 !== null || isHourFormat24.value)) {
        let time = null;
        if (vmodel.value) {
          time = new Date(vmodel.value);
        } else {
          time = props.timeCreator();
          time.setMilliseconds(0);
        }
        time.setHours(hours2);
        time.setMinutes(minutes2);
        time.setSeconds(seconds2);
        if (!isNaN(time.getTime())) {
          vmodel.value = new Date(time.getTime());
        }
      }
    }
    function formatNative(value) {
      const date = new Date(value);
      if (!value || !date || isNaN(date.getTime()))
        return null;
      const hours2 = date.getHours();
      const minutes2 = date.getMinutes();
      const seconds2 = date.getSeconds();
      return formatNumber(hours2, true) + ":" + formatNumber(minutes2, true) + ":" + formatNumber(seconds2, true);
    }
    function onMeridienChange(value) {
      if (hoursSelected.value !== null && props.resetOnMeridianChange) {
        hoursSelected.value = null;
        minutesSelected.value = null;
        secondsSelected.value = null;
        vmodel.value = null;
      } else if (hoursSelected.value !== null) {
        if (value === pmString.value)
          hoursSelected.value += 12;
        else if (value === amString.value)
          hoursSelected.value -= 12;
      }
      updateDateSelected(
        hoursSelected.value,
        minutesSelected.value,
        props.enableSeconds ? secondsSelected.value : 0,
        value
      );
    }
    function onHoursChange(value) {
      if (!minutesSelected.value && typeof props.defaultMinutes !== "undefined")
        minutesSelected.value = props.defaultMinutes;
      if (!secondsSelected.value && typeof props.defaultSeconds !== "undefined")
        secondsSelected.value = props.defaultSeconds;
      updateDateSelected(
        parseInt(value, 10),
        minutesSelected.value,
        props.enableSeconds ? secondsSelected.value : 0,
        meridienSelected.value
      );
    }
    function onMinutesChange(value) {
      if (!secondsSelected.value && props.defaultSeconds)
        secondsSelected.value = props.defaultSeconds;
      updateDateSelected(
        hoursSelected.value,
        parseInt(value, 10),
        props.enableSeconds ? secondsSelected.value : 0,
        meridienSelected.value
      );
    }
    function onSecondsChange(value) {
      updateDateSelected(
        hoursSelected.value,
        minutesSelected.value,
        parseInt(value, 10),
        meridienSelected.value
      );
    }
    function onChange(value) {
      const date = props.timeParser(value, defaultTimeParser);
      vmodel.value = date ? date : null;
    }
    function onChangeNativePicker(date) {
      if (date) {
        let time = null;
        if (vmodel.value) {
          time = new Date(vmodel.value);
        } else {
          time = props.timeCreator();
          time.setMilliseconds(0);
        }
        const t = date.split(":");
        time.setHours(parseInt(t[0], 10));
        time.setMinutes(parseInt(t[1], 10));
        time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
        vmodel.value = new Date(time.getTime());
      } else {
        vmodel.value = null;
      }
    }
    const selectSelectClasses = defineClasses([
      "selectClasses.selectClass",
      "o-tpck__select"
    ]);
    const selectPlaceholderClasses = defineClasses([
      "selectClasses.placeholderClass",
      "o-tpck__select-placeholder"
    ]);
    const selectBind = computed(() => ({
      "select-class": getActiveClasses(selectSelectClasses.value),
      "placeholder-class": getActiveClasses(selectPlaceholderClasses.value),
      ...props.selectClasses
    }));
    const rootClasses = defineClasses(
      ["rootClass", "o-tpck"],
      [
        "sizeClass",
        "o-tpck--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      ["mobileClass", "o-tpck--mobile", null, isMobile]
    );
    const separatorClasses = defineClasses(["separatorClass", "o-tpck__separtor"]);
    const footerClasses = defineClasses(["footerClass", "o-tpck__footer"]);
    const dropdownClass = defineClasses([
      "dropdownClasses.rootClass",
      "o-tpck__dropdown"
    ]);
    const boxClasses = defineClasses(["boxClass", "o-tpck__box"]);
    const boxClassBind = computed(() => getActiveClasses(boxClasses.value));
    __expose({ focus: () => {
      var _a;
      return (_a = pickerRef.value) == null ? void 0 : _a.focus();
    } });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main11, {
        ref_key: "pickerRef",
        ref: pickerRef,
        active: isActive.value,
        "onUpdate:active": _cache[8] || (_cache[8] = ($event) => isActive.value = $event),
        "data-oruga": "timepicker",
        value: vmodel.value,
        picker: props,
        "formatted-value": formattedValue.value,
        "native-type": "time",
        "native-value": formatNative(vmodel.value),
        "native-max": formatNative(__props.maxTime),
        "native-min": formatNative(__props.minTime),
        "native-step": nativeStep.value,
        "dropdown-classes": unref(dropdownClass),
        "root-classes": unref(rootClasses),
        "box-class": boxClassBind.value,
        onChange,
        onNativeChange: onChangeNativePicker,
        onFocus: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("focus", $event)),
        onBlur: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("blur", $event)),
        onInvalid: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("invalid", $event)),
        onIconClick: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("icon-click", $event)),
        onIconRightClick: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("icon-right-click", $event))
      }, createSlots({
        default: withCtx(() => [
          createVNode(_sfc_main10, mergeProps(selectBind.value, {
            modelValue: hoursSelected.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => hoursSelected.value = $event),
            override: "",
            disabled: __props.disabled,
            placeholder: "00",
            onChange: _cache[1] || (_cache[1] = ($event) => onHoursChange($event.target.value))
          }), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(hours.value, (hour) => {
                return openBlock(), createElementBlock("option", {
                  key: hour.value,
                  value: hour.value,
                  disabled: isHourDisabled(hour.value)
                }, toDisplayString(hour.label), 9, _hoisted_110);
              }), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled"]),
          createBaseVNode("span", {
            class: normalizeClass(unref(separatorClasses))
          }, toDisplayString(unref(hourLiteral)), 3),
          createVNode(_sfc_main10, mergeProps(selectBind.value, {
            modelValue: minutesSelected.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => minutesSelected.value = $event),
            override: "",
            disabled: __props.disabled,
            placeholder: "00",
            onChange: _cache[3] || (_cache[3] = ($event) => onMinutesChange($event.target.value))
          }), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(minutes.value, (minute) => {
                return openBlock(), createElementBlock("option", {
                  key: minute.value,
                  value: minute.value,
                  disabled: isMinuteDisabled(minute.value)
                }, toDisplayString(minute.label), 9, _hoisted_26);
              }), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled"]),
          __props.enableSeconds ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(separatorClasses))
            }, toDisplayString(unref(minuteLiteral)), 3),
            createVNode(_sfc_main10, mergeProps(selectBind.value, {
              modelValue: secondsSelected.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => secondsSelected.value = $event),
              override: "",
              disabled: __props.disabled,
              placeholder: "00",
              onChange: _cache[5] || (_cache[5] = ($event) => onSecondsChange($event.target.value))
            }), {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(seconds.value, (second) => {
                  return openBlock(), createElementBlock("option", {
                    key: second.value,
                    value: second.value,
                    disabled: isSecondDisabled(second.value)
                  }, toDisplayString(second.label), 9, _hoisted_32);
                }), 128))
              ]),
              _: 1
            }, 16, ["modelValue", "disabled"]),
            createBaseVNode("span", {
              class: normalizeClass(unref(separatorClasses))
            }, toDisplayString(unref(secondLiteral)), 3)
          ], 64)) : createCommentVNode("", true),
          !unref(isHourFormat24) ? (openBlock(), createBlock(_sfc_main10, mergeProps({ key: 1 }, selectBind.value, {
            modelValue: meridienSelected.value,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => meridienSelected.value = $event),
            override: "",
            disabled: __props.disabled,
            onChange: _cache[7] || (_cache[7] = ($event) => onMeridienChange($event.target.value))
          }), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(meridiens), (meridien) => {
                return openBlock(), createElementBlock("option", {
                  key: meridien,
                  value: meridien,
                  disabled: isMeridienDisabled(meridien)
                }, toDisplayString(meridien), 9, _hoisted_4);
              }), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled"])) : createCommentVNode("", true),
          _ctx.$slots.default ? (openBlock(), createElementBlock("footer", {
            key: 2,
            class: normalizeClass(unref(footerClasses))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$slots.trigger ? {
          name: "trigger",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["active", "value", "picker", "formatted-value", "native-value", "native-max", "native-min", "native-step", "dropdown-classes", "root-classes", "box-class"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/datetimepicker.mjs
var AM2 = "AM";
var PM2 = "PM";
var HOUR_FORMAT_242 = "24";
var _sfc_main14 = defineComponent({
  ...{
    isOruga: true,
    name: "ODatetimepicker",
    configField: "datetimepicker",
    inheritAttrs: false
  },
  __name: "Datetimepicker",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Date, default: void 0 },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /** Define props for the underlying datepicker component */
    datepicker: {
      type: Object,
      default: void 0
    },
    /** Define props for the underlying timepicker component */
    timepicker: {
      type: Object,
      default: void 0
    },
    /** Min date to select */
    minDatetime: { type: Date, default: void 0 },
    /** Max date to select */
    maxDatetime: { type: Date, default: void 0 },
    /**
     * Size of the input control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("datetimepicker.size")
    },
    expanded: { type: Boolean, default: false },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: false },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: false },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Display datetimepicker inline */
    inline: { type: Boolean, default: false },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => getOption("datetimepicker.openOnFocus", true)
    },
    /** Date format locale */
    locale: {
      type: String,
      default: () => getOption("locale")
    },
    /** Custom function to format a date into a string */
    datetimeFormatter: {
      type: Function,
      default: (date, defaultFunction) => getOption("datetimepicker.dateFormatter", defaultFunction)(date)
    },
    /** Custom function to parse a string into a date */
    datetimeParser: {
      type: Function,
      default: (date, defaultFunction) => getOption("datetimepicker.dateParser", defaultFunction)(date)
    },
    /** Date creator function, default is `new Date()` */
    datetimeCreator: {
      type: Function,
      default: (date) => getOption(
        "datetimepicker.datetimeCreator",
        (d) => new Date(d)
      )(date)
    },
    /** Dropdown position */
    position: { type: String, default: void 0 },
    /** Enable mobile native input if mobile agent */
    mobileNative: {
      type: Boolean,
      default: () => getOption("datetimepicker.mobileNative", true)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("datetimepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("datetimepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => getOption("datetimepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: false },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("datetimepicker.teleport", false)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the Datepicker wrapper */
    datepickerWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker wrapper */
    timepickerWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {},
    "modelValue": { default: void 0 },
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:active", "update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const datepickerRef = ref();
    const timepickerRef = ref();
    const nativeInputRef = ref();
    const timepickerProps = ref(props.timepicker);
    watch(
      () => props.timepicker,
      (value) => timepickerProps.value = value,
      { deep: true }
    );
    const datepickerProps = ref(props.datepicker);
    watch(
      () => props.datepicker,
      (value) => datepickerProps.value = value,
      { deep: true }
    );
    const isMobileNative = computed(
      () => props.mobileNative && isMobileAgent.any()
    );
    const elementRef = computed(
      () => isMobileNative.value ? nativeInputRef.value : datepickerRef.value
    );
    const { setFocus, onBlur, onFocus, onInvalid } = useInputHandler(
      elementRef,
      emits,
      props
    );
    watch([() => isMobileNative.value, () => props.inline], () => {
      if (datepickerRef.value)
        datepickerRef.value.$forceUpdate();
    });
    const isActive = useModel(__props, "active");
    const vmodel = useModel(__props, "modelValue");
    function updateVModel(value) {
      if (!value) {
        vmodel.value = void 0;
        return;
      }
      if (Array.isArray(value)) {
        updateVModel(value[0]);
        return;
      }
      let date = new Date(value.getTime());
      if (!props.modelValue) {
        date = props.datetimeCreator(value);
      } else {
        if ((value.getDate() !== props.modelValue.getDate() || value.getMonth() !== props.modelValue.getMonth() || value.getFullYear() !== props.modelValue.getFullYear()) && value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0) {
          date.setHours(
            props.modelValue.getHours(),
            props.modelValue.getMinutes(),
            props.modelValue.getSeconds(),
            0
          );
        }
      }
      if (props.minDatetime && date < props.minDatetime) {
        date = props.minDatetime;
      } else if (props.maxDatetime && date > props.maxDatetime) {
        date = props.maxDatetime;
      }
      vmodel.value = new Date(date.getTime());
    }
    const minDate = computed(() => {
      if (!props.minDatetime)
        return datepickerProps.value ? datepickerProps.value.minDate : null;
      return new Date(
        props.minDatetime.getFullYear(),
        props.minDatetime.getMonth(),
        props.minDatetime.getDate(),
        0,
        0,
        0,
        0
      );
    });
    const maxDate = computed(() => {
      if (!props.maxDatetime)
        return datepickerProps.value ? datepickerProps.value.maxDate : null;
      return new Date(
        props.maxDatetime.getFullYear(),
        props.maxDatetime.getMonth(),
        props.maxDatetime.getDate(),
        0,
        0,
        0,
        0
      );
    });
    const minTime = computed(() => {
      if (!props.minDatetime || vmodel.value === null || typeof vmodel.value === "undefined" || vmodel.value.getFullYear() != props.minDatetime.getFullYear() || vmodel.value.getMonth() != props.minDatetime.getMonth() || vmodel.value.getDate() != props.minDatetime.getDate()) {
        return timepickerProps.value ? timepickerProps.value.minTime : null;
      }
      return props.minDatetime;
    });
    const maxTime = computed(() => {
      if (!props.maxDatetime || vmodel.value === null || typeof vmodel.value === "undefined" || vmodel.value.getFullYear() != props.maxDatetime.getFullYear() || vmodel.value.getMonth() != props.maxDatetime.getMonth() || vmodel.value.getDate() != props.maxDatetime.getDate()) {
        return timepickerProps.value ? timepickerProps.value.maxTime : null;
      }
      return props.maxDatetime;
    });
    const datepickerSize = computed(
      () => {
        var _a;
        return ((_a = datepickerProps.value) == null ? void 0 : _a.size) ? datepickerProps.value.size : props.size;
      }
    );
    const timepickerSize = computed(
      () => {
        var _a;
        return ((_a = timepickerProps.value) == null ? void 0 : _a.size) ? timepickerProps.value.size : props.size;
      }
    );
    const timepickerDisabled = computed(
      () => {
        var _a;
        return ((_a = timepickerProps.value) == null ? void 0 : _a.disabled) ? timepickerProps.value.disabled : props.disabled;
      }
    );
    function formatNative(value) {
      const date = new Date(value);
      if (value && !isNaN(date.getTime())) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        return year + "-" + ((month < 10 ? "0" : "") + month) + "-" + ((day < 10 ? "0" : "") + day) + "T" + ((hours < 10 ? "0" : "") + hours) + ":" + ((minutes < 10 ? "0" : "") + minutes) + ":" + ((seconds < 10 ? "0" : "") + seconds);
      }
      return "";
    }
    const enableSeconds = computed(
      () => {
        var _a;
        return ((_a = timepickerRef.value) == null ? void 0 : _a.enableSeconds) ? timepickerRef.value.enableSeconds : false;
      }
    );
    const localeOptions = computed(
      () => new Intl.DateTimeFormat(props.locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: enableSeconds.value ? "numeric" : void 0
      }).resolvedOptions()
    );
    const isHourFormat24 = computed(
      () => {
        var _a, _b;
        return ((_a = timepickerProps.value) == null ? void 0 : _a.hourFormat) && timepickerProps.value.hourFormat === HOUR_FORMAT_242 || !((_b = timepickerProps.value) == null ? void 0 : _b.hourFormat) && !localeOptions.value.hour12;
      }
    );
    const dtf = computed(
      () => new Intl.DateTimeFormat(props.locale, {
        year: localeOptions.value.year || "numeric",
        month: localeOptions.value.month || "numeric",
        day: localeOptions.value.day || "numeric",
        hour: localeOptions.value.hour || "numeric",
        minute: localeOptions.value.minute || "numeric",
        second: enableSeconds.value ? localeOptions.value.second || "numeric" : void 0,
        hourCycle: !isHourFormat24.value ? "h12" : "h23"
      })
    );
    const amString = computed(() => {
      if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
        const d = props.datetimeCreator(/* @__PURE__ */ new Date());
        d.setHours(10);
        const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
        if (dayPeriod)
          return dayPeriod.value;
      }
      return AM2;
    });
    const pmString = computed(() => {
      if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
        const d = props.datetimeCreator(/* @__PURE__ */ new Date());
        d.setHours(20);
        const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
        if (dayPeriod)
          return dayPeriod.value;
      }
      return PM2;
    });
    function defaultDatetimeParser(value) {
      function defaultParser(date2) {
        if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
          const dayPeriods = [AM2, PM2, AM2.toLowerCase(), PM2.toLowerCase()];
          if (timepickerRef.value) {
            dayPeriods.push(amString.value);
            dayPeriods.push(pmString.value);
          }
          const parts = dtf.value.formatToParts(/* @__PURE__ */ new Date());
          const formatRegex = parts.map((part, idx) => {
            if (part.type === "literal") {
              if (idx + 1 < parts.length && parts[idx + 1].type === "hour") {
                return `[^\\d]+`;
              }
              return part.value.replace(/ /g, "\\s?");
            } else if (part.type === "dayPeriod") {
              return `((?!=<${part.type}>)(${dayPeriods.join(
                "|"
              )})?)`;
            }
            return `((?!=<${part.type}>)\\d+)`;
          }).join("");
          const datetimeGroups = matchWithGroups(formatRegex, date2);
          if (datetimeGroups.year && datetimeGroups.year.length === 4 && datetimeGroups.month && datetimeGroups.month <= 12 && datetimeGroups.day && datetimeGroups.day <= 31 && datetimeGroups.hour && datetimeGroups.hour >= 0 && datetimeGroups.hour < 24 && datetimeGroups.minute && datetimeGroups.minute >= 0 && datetimeGroups.minute <= 59) {
            const d = new Date(
              datetimeGroups.year,
              datetimeGroups.month - 1,
              datetimeGroups.day,
              datetimeGroups.hour,
              datetimeGroups.minute,
              datetimeGroups.second || 0
            );
            return d;
          }
        }
        return new Date(Date.parse(date2));
      }
      const date = props.datetimeParser(value, defaultParser);
      return date;
    }
    function defaultDatetimeFormatter(date) {
      return props.datetimeFormatter(
        date,
        (date2) => date2 ? dtf.value.format(date2) : ""
      );
    }
    function onChangeNativePicker(event) {
      const date = event.target.value;
      const s = date ? date.split(/\D/) : [];
      if (s.length >= 5) {
        const year = parseInt(s[0], 10);
        const month = parseInt(s[1], 10) - 1;
        const day = parseInt(s[2], 10);
        const hours = parseInt(s[3], 10);
        const minutes = parseInt(s[4], 10);
        updateVModel(new Date(year, month, day, hours, minutes));
      } else {
        updateVModel(null);
      }
    }
    const datepickerWrapperClasses = defineClasses([
      "datepickerWrapperClass",
      "o-dtpck__date"
    ]);
    const timepickerWrapperClasses = defineClasses([
      "timepickerWrapperClass",
      "o-dtpck__time"
    ]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return !isMobileNative.value || __props.inline ? (openBlock(), createBlock(_sfc_main12, mergeProps({
        key: 0,
        ref_key: "datepickerRef",
        ref: datepickerRef
      }, { ..._ctx.$attrs, ...__props.datepicker }, {
        active: isActive.value,
        "onUpdate:active": _cache[1] || (_cache[1] = ($event) => isActive.value = $event),
        "model-value": vmodel.value,
        "data-oruga": "datetimepicker",
        class: unref(datepickerWrapperClasses),
        rounded: __props.rounded,
        "open-on-focus": __props.openOnFocus,
        position: __props.position,
        inline: __props.inline,
        readonly: __props.readonly,
        expanded: __props.expanded,
        "close-on-click": false,
        "date-formatter": defaultDatetimeFormatter,
        "date-parser": defaultDatetimeParser,
        "min-date": minDate.value,
        "max-date": maxDate.value,
        icon: __props.icon,
        "icon-right": __props.iconRight,
        "icon-right-clickable": __props.iconRightClickable,
        "icon-pack": __props.iconPack,
        size: datepickerSize.value,
        placeholder: __props.placeholder,
        range: false,
        disabled: __props.disabled,
        "mobile-native": isMobileNative.value,
        locale: __props.locale,
        teleport: __props.teleport,
        "onUpdate:modelValue": updateVModel,
        onFocus: unref(onFocus),
        onBlur: unref(onBlur),
        onChangeMonth: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("change-month", $event)),
        onChangeYear: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("change-year", $event)),
        onIconClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("icon-click", $event)),
        onIconRightClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("icon-right-click", $event))
      }), {
        footer: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(unref(timepickerWrapperClasses))
          }, [
            createVNode(_sfc_main13, mergeProps({
              ref_key: "timepickerRef",
              ref: timepickerRef
            }, __props.timepicker, {
              modelValue: vmodel.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
              inline: "",
              readonly: __props.readonly,
              "min-time": minTime.value,
              "max-time": maxTime.value,
              size: timepickerSize.value,
              disabled: timepickerDisabled.value,
              "mobile-native": isMobileNative.value,
              locale: __props.locale
            }), null, 16, ["modelValue", "readonly", "min-time", "max-time", "size", "disabled", "mobile-native", "locale"])
          ], 2),
          _ctx.$slots.footer !== void 0 ? renderSlot(_ctx.$slots, "footer", { key: 0 }) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["active", "model-value", "class", "rounded", "open-on-focus", "position", "inline", "readonly", "expanded", "min-date", "max-date", "icon", "icon-right", "icon-right-clickable", "icon-pack", "size", "placeholder", "disabled", "mobile-native", "locale", "teleport", "onFocus", "onBlur"])) : (openBlock(), createBlock(_sfc_main2, mergeProps({ key: 1 }, _ctx.$attrs, {
        ref_key: "nativeInputRef",
        ref: nativeInputRef,
        type: "datetime-local",
        autocomplete: "off",
        value: formatNative(vmodel.value),
        max: formatNative(maxDate.value),
        min: formatNative(minDate.value),
        placeholder: __props.placeholder,
        size: datepickerSize.value,
        "icon-pack": __props.iconPack,
        icon: __props.icon,
        rounded: __props.rounded,
        disabled: __props.disabled,
        readonly: false,
        "use-html5-validation": false,
        onChange: onChangeNativePicker,
        onFocus: unref(onFocus),
        onBlur: unref(onBlur),
        onInvalid: unref(onInvalid)
      }), null, 16, ["value", "max", "min", "placeholder", "size", "icon-pack", "icon", "rounded", "disabled", "onFocus", "onBlur", "onInvalid"]));
    };
  }
});
var index7 = {
  install(app) {
    registerComponent(app, _sfc_main14);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/dropdown.mjs
var index8 = {
  install(app) {
    registerComponent(app, _sfc_main$1);
    registerComponent(app, _sfc_main4);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Field.vue_vue_type_script_setup_true_lang-wrMEoJ1V.mjs
var _hoisted_111 = ["for"];
var _hoisted_27 = ["for"];
var _sfc_main15 = defineComponent({
  ...{
    isOruga: true,
    name: "OField",
    configField: "field"
  },
  __name: "Field",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /**
     * Color of the field and help message, also adds a matching icon.
     * Used by Input, Select and Autocomplete.
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: { type: String, default: void 0 },
    /** Field label */
    label: { type: String, default: void 0 },
    /**
     * Vertical size of input
     * @values small, medium, large
     */
    labelSize: {
      type: String,
      default: () => getOption("field.labelsize")
    },
    /** Same as native for set on the label */
    labelFor: { type: String, default: void 0 },
    /** Help message text */
    message: { type: String, default: void 0 },
    messageTag: {
      type: [String, Object, Function],
      default: () => getOption("field.messageTag", "p")
    },
    /**
     * Direct child components/elements of Field will be grouped horizontally
     * (see which ones at the top of the page).
     */
    grouped: { type: Boolean, default: false },
    /** Allow controls to fill up multiple lines, making it responsive */
    groupMultiline: { type: Boolean, default: false },
    /** Group label and control on the same line for horizontal forms */
    horizontal: { type: Boolean, default: false },
    /** Field automatically attach controls together */
    addons: { type: Boolean, default: true },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("field.mobileBreakpoint")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class to align label and control in horizontal forms */
    horizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when fields are grouped together */
    groupedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when fields fill up multiple lines */
    groupMultilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label size */
    labelSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label when horizontal */
    labelHorizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field body */
    bodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** "Class for field body when horizontal */
    bodyHorizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for components automatically attached together when inside a field */
    addonsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the field message */
    messageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the message field variant */
    variantMessageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the label field variant */
    variantLabelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of file component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the focused field */
    focusedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the filled field */
    filledClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const inputId = ref(props.labelFor);
    watch(
      () => props.labelFor,
      (v) => inputId.value = v
    );
    const fieldVariant = ref(props.variant);
    watch(
      () => props.variant,
      (v) => fieldVariant.value = v
    );
    const fieldMessage = ref(props.message);
    watch(
      () => props.message,
      (v) => fieldMessage.value = v
    );
    watch(
      () => fieldMessage.value,
      (value) => {
        var _a;
        if ((_a = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a.hasInnerField) {
          if (!parentField.value.fieldVariant)
            parentField.value.setVariant(fieldVariant.value);
          if (!parentField.value.fieldMessage)
            parentField.value.setMessage(value);
        }
      }
    );
    const isFocused = ref(false);
    const isFilled = ref(false);
    const hasInnerField = ref(false);
    const { parentField } = injectField();
    if (parentField == null ? void 0 : parentField.value)
      parentField.value.addInnerField();
    const slots = useSlots();
    const hasLabel = computed(() => props.label || !!slots.label);
    const hasMessage = computed(() => !!fieldMessage.value || !!slots.message);
    const isGrouped = computed(
      () => props.grouped || props.groupMultiline || hasInnerField.value || hasAddons.value
    );
    const hasAddons = computed(
      () => props.addons && !props.horizontal && !!slots.default
    );
    function getInnerContent(vnode) {
      const slot = vnode();
      return slot.length === 1 && Array.isArray(slot[0].children) ? slot[0].children : slot;
    }
    const rootRef = ref();
    function addInnerField() {
      hasInnerField.value = true;
    }
    function setFocus(value) {
      isFocused.value = value;
    }
    function setFilled(value) {
      isFilled.value = value;
    }
    function setVariant(value) {
      fieldVariant.value = value;
    }
    function setMessage(value) {
      fieldMessage.value = value;
    }
    function setInputId(value) {
      inputId.value = value;
    }
    const provideData = computed(() => ({
      $el: rootRef.value,
      props,
      hasInnerField: hasInnerField.value,
      hasMessage: hasMessage.value,
      fieldVariant: fieldVariant.value,
      fieldMessage: fieldMessage.value,
      addInnerField,
      setInputId,
      setFocus,
      setFilled,
      setVariant,
      setMessage
    }));
    provideField(provideData);
    const rootClasses = defineClasses(
      ["rootClass", "o-field"],
      [
        "horizontalClass",
        "o-field--horizontal",
        null,
        computed(() => !!props.horizontal)
      ],
      ["mobileClass", "o-field--mobile", null, isMobile],
      ["focusedClass", "o-field--focused", null, isFocused],
      ["filledClass", "o-field--filled", null, isFilled]
    );
    const messageClasses = defineClasses(
      ["messageClass", "o-field__message"],
      [
        "variantMessageClass",
        "o-field__message-",
        fieldVariant,
        computed(() => !!fieldVariant.value)
      ]
    );
    const labelClasses = defineClasses(
      ["labelClass", "o-field__label"],
      [
        "labelSizeClass",
        "o-field__label-",
        computed(() => props.labelSize),
        computed(() => !!props.labelSize)
      ],
      [
        "variantLabelClass",
        "o-field__label-",
        fieldVariant,
        computed(() => !!fieldVariant.value)
      ]
    );
    const labelHorizontalClasses = defineClasses([
      "labelHorizontalClass",
      "o-field__horizontal-label"
    ]);
    const bodyClasses = defineClasses(["bodyClass", "o-field__body"]);
    const bodyHorizontalClasses = defineClasses([
      "bodyHorizontalClass",
      "o-field__horizontal-body"
    ]);
    const innerFieldClasses = defineClasses(
      ["rootClass", "o-field"],
      [
        "groupMultilineClass",
        "o-field--grouped-multiline",
        null,
        computed(() => props.groupMultiline)
      ],
      ["groupedClass", "o-field--grouped", null, computed(() => props.grouped)],
      [
        "addonsClass",
        "o-field--addons",
        null,
        computed(() => !props.grouped && hasAddons.value)
      ]
    );
    return (_ctx, _cache) => {
      const _component_OField = resolveComponent("OField");
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        "data-oruga": "field",
        class: normalizeClass(unref(rootClasses))
      }, [
        __props.horizontal ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(labelHorizontalClasses))
        }, [
          hasLabel.value ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: inputId.value,
            class: normalizeClass(unref(labelClasses))
          }, [
            renderSlot(_ctx.$slots, "label", { label: __props.label }, () => [
              createTextVNode(toDisplayString(__props.label), 1)
            ])
          ], 10, _hoisted_111)) : createCommentVNode("", true)
        ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          hasLabel.value ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: inputId.value,
            class: normalizeClass(unref(labelClasses))
          }, [
            renderSlot(_ctx.$slots, "label", { label: __props.label }, () => [
              createTextVNode(toDisplayString(__props.label), 1)
            ])
          ], 10, _hoisted_27)) : createCommentVNode("", true)
        ], 64)),
        __props.horizontal ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(unref(bodyHorizontalClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(getInnerContent(_ctx.$slots.default), (element, index30) => {
            return openBlock(), createElementBlock(Fragment, { key: index30 }, [
              unref(isVNodeEmpty)(element) ? (openBlock(), createBlock(resolveDynamicComponent(element), { key: 0 })) : (openBlock(), createBlock(_component_OField, {
                key: 1,
                variant: fieldVariant.value,
                addons: false,
                "message-tag": __props.messageTag,
                "message-class": __props.messageClass
              }, createSlots({
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(element)))
                ]),
                _: 2
              }, [
                index30 === 0 ? {
                  name: "message",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "message", { message: fieldMessage.value }, () => [
                      createTextVNode(toDisplayString(fieldMessage.value), 1)
                    ])
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["variant", "message-tag", "message-class"]))
            ], 64);
          }), 128))
        ], 2)) : isGrouped.value ? (openBlock(), createElementBlock("div", {
          key: 3,
          class: normalizeClass(unref(bodyClasses))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(unref(innerFieldClasses))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ], 2)) : renderSlot(_ctx.$slots, "default", { key: 4 }),
        hasMessage.value && !__props.horizontal ? (openBlock(), createBlock(resolveDynamicComponent(__props.messageTag), {
          key: 5,
          class: normalizeClass(unref(messageClasses))
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "message", { message: fieldMessage.value }, () => [
              createTextVNode(toDisplayString(fieldMessage.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["class"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/field.mjs
var index9 = {
  install(app) {
    registerComponent(app, _sfc_main15);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/icon.mjs
var index10 = {
  install(app) {
    registerComponent(app, _sfc_main);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/input.mjs
var index11 = {
  install(app) {
    registerComponent(app, _sfc_main2);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/useProgrammatic-C7Risz_2.mjs
function useProgrammaticComponent(elementRef, props, emits, options = { cancelOptions: ["escape", "outside"] }) {
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useProgrammaticComponent must be called within a component setup function."
    );
  const isActive = usePropBinding("active", props, emits);
  const cancelOptions = computed(
    () => typeof props.cancelable === "boolean" ? props.cancelable ? options.cancelOptions : [] : props.cancelable
  );
  function getElement() {
    return typeof elementRef === "function" ? elementRef() : elementRef.value;
  }
  const container = computed(
    () => typeof props.container === "string" ? document.querySelector(props.container) : props.container || document.body
  );
  onMounted(() => {
    if (props.programmatic) {
      if (props.programmatic.instances) {
        props.programmatic.instances.add(vm);
      }
      const el = getElement();
      container.value.appendChild(el);
      isActive.value = true;
    }
  });
  if (isClient)
    useEventListener("keyup", onKeyPress, container.value);
  function onKeyPress(event) {
    if (isActive.value && (event.key === "Escape" || event.key === "Esc")) {
      cancel("escape");
    }
  }
  function cancel(method) {
    if (!props.cancelable || !isActive.value)
      return;
    if (cancelOptions.value.indexOf(method) < 0)
      return;
    props.onCancel.apply(null);
    close({ action: "cancel", method });
  }
  function close(...args) {
    vm.emit("close");
    props.onClose.apply(null, args);
    if (props.programmatic) {
      if (props.programmatic.instances)
        props.programmatic.instances.remove(vm);
      if (props.programmatic.resolve)
        props.programmatic.resolve.apply(null, args);
      setTimeout(() => {
        vm.props.active = false;
        vm.emit("update:active", false);
        if (typeof options.destroyOnHide === "undefined" || options.destroyOnHide)
          if (isClient)
            window.requestAnimationFrame(() => {
              const el = getElement();
              if (el)
                removeElement(el);
            });
          else {
            const el = getElement();
            if (el)
              removeElement(el);
          }
      });
    } else {
      vm.props.active = false;
      vm.emit("update:active", false);
    }
  }
  return { close, cancel, isActive, container };
}

// node_modules/@oruga-ui/oruga-next/dist/esm/Loading.vue_vue_type_script_setup_true_lang-eJaXDfED.mjs
var _sfc_main16 = defineComponent({
  ...{
    isOruga: true,
    name: "OLoading",
    configField: "loading",
    inheritAttrs: false
  },
  __name: "Loading",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether loading is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /** Loader will overlay the full page. */
    fullPage: { type: Boolean, default: true },
    /** Notification label, unnecessary when default slot is used. */
    label: { type: String, default: void 0 },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("loading.animation", "fade")
    },
    /** Is Loading cancable by pressing escape or clicking outside. */
    cancelable: { type: Boolean, default: false },
    /** Callback function to call after user canceled (pressed escape / clicked outside). */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled). */
    onClose: { type: Function, default: () => {
    } },
    /** Icon name to show, unnecessary when default slot is used. */
    icon: {
      type: String,
      default: () => getOption("loading.icon", "loading")
    },
    /** Enable spin effect on icon */
    iconSpin: {
      type: Boolean,
      default: () => getOption("loading.iconSpin", true)
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => getOption("loading.iconSize", "medium")
    },
    /**
     * DOM element where the loading component will be created on (for programmatic usage).
     * Note that this also changes fullPage to false.
     */
    container: {
      type: [Object, String],
      default: () => getOption("loading.container", "body")
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element when fullpage */
    fullPageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the loading overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the loading icon */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the loading label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "update:fullPage", "close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = ref();
    const displayInFullPage = usePropBinding("fullPage", props, emits);
    const { isActive, close, cancel } = useProgrammaticComponent(
      rootRef,
      props,
      emits,
      {
        cancelOptions: ["escape", "outside"]
      }
    );
    onMounted(() => {
      if (props.programmatic && props.container)
        displayInFullPage.value = false;
    });
    const rootClasses = defineClasses(
      ["rootClass", "o-load"],
      ["fullPageClass", "o-load--fullpage", null, displayInFullPage]
    );
    const overlayClasses = defineClasses(["overlayClass", "o-load__overlay"]);
    const iconClasses = defineClasses(["iconClass", "o-load__icon"]);
    const labelClasses = defineClasses(["labelClass", "o-load__label"]);
    __expose({ close, promise: props.promise });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: __props.animation }, {
        default: withCtx(() => [
          unref(isActive) ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "rootRef",
            ref: rootRef,
            "data-oruga": "loading",
            role: "dialog",
            class: normalizeClass(unref(rootClasses))
          }, [
            createBaseVNode("div", {
              class: normalizeClass(unref(overlayClasses)),
              tabindex: -1,
              "aria-hidden": "true",
              onClick: _cache[0] || (_cache[0] = ($event) => unref(cancel)("outside"))
            }, null, 2),
            renderSlot(_ctx.$slots, "default", { close: unref(close) }, () => [
              createVNode(_sfc_main, {
                icon: __props.icon,
                spin: __props.iconSpin,
                size: __props.iconSize,
                class: normalizeClass(unref(iconClasses)),
                both: ""
              }, null, 8, ["icon", "spin", "size", "class"]),
              __props.label ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(labelClasses))
              }, toDisplayString(__props.label), 3)) : createCommentVNode("", true)
            ])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name"]);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/InstanceRegistry-gfFoD3QZ.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var InstanceRegistry = class {
  constructor() {
    __publicField(this, "entries");
    this.entries = [];
  }
  add(entry) {
    this.entries.push(entry);
  }
  remove(entry) {
    const index30 = this.entries.indexOf(entry);
    this.entries.splice(index30, 1);
  }
  walk(callback) {
    this.entries = [...this.entries].filter((e) => {
      const ret = callback(e);
      return !(ret === true);
    });
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/loading.mjs
var instances = new InstanceRegistry();
var LoadingProgrammatic = {
  open(params) {
    const componentParams = typeof params === "string" ? {
      label: params
    } : { ...params };
    let slot;
    if (Array.isArray(componentParams.label)) {
      slot = componentParams.label;
      delete componentParams.label;
    }
    const defaultParams = {
      programmatic: { instances },
      active: true
      // set the active state to true
    };
    const propsData = merge(defaultParams, componentParams);
    propsData.promise = new Promise((p1, p2) => {
      propsData.programmatic.resolve = p1;
      propsData.programmatic.reject = p2;
    });
    const defaultSlot = () => slot;
    const app = VueInstance;
    const vnode = createVNode(_sfc_main16, propsData, defaultSlot);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.exposed;
  },
  closeAll(...args) {
    instances.walk((entry) => entry.exposed.close(...args));
  }
};
var LoadingProgrammatic$1 = LoadingProgrammatic;
var index12 = {
  install(app) {
    registerComponent(app, _sfc_main16);
    registerComponentProgrammatic(app, "loading", LoadingProgrammatic$1);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/menu.mjs
var _hoisted_1$13 = ["role"];
var _sfc_main$14 = defineComponent({
  ...{
    isOruga: true,
    name: "OMenu",
    configField: "menu"
  },
  __name: "Menu",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Menu label */
    label: { type: String, default: void 0 },
    /** If sub menu items are collapsible */
    accordion: { type: Boolean, default: true },
    /** If the menu items are clickable */
    activable: { type: Boolean, default: true },
    /**
     * Role attribute to be passed to the list container for better accessibility.
     * Use menu only in situations where your dropdown is related to a navigation menu.
     * @values list, menu, dialog
     */
    ariaRole: {
      type: String,
      default: getOption("menu.ariaRole", "menu"),
      validator: (value) => ["menu", "list", "dialog"].indexOf(value) > -1
    },
    /** Icon to be shown */
    icon: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("menu.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => getOption("menu.iconSize")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu list */
    listClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu list label */
    listLabelClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const rootRef = ref();
    const provideData = computed(() => ({
      activable: props.activable,
      accordion: props.accordion,
      resetMenu
    }));
    const { childItems } = useProviderParent(rootRef, {
      data: provideData
    });
    function resetMenu(excludedItems = []) {
      childItems.value.forEach((item) => {
        if (!excludedItems.map((i) => i == null ? void 0 : i.identifier).includes(item.identifier))
          item.data.reset();
      });
    }
    const rootClasses = defineClasses(["rootClass", "o-menu"]);
    const listClasses = defineClasses(["listClass", "o-menu__list"]);
    const labelClasses = defineClasses(["listLabelClass", "o-menu__label"]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        "data-oruga": "menu",
        class: normalizeClass(unref(rootClasses))
      }, [
        __props.label || _ctx.$slots.label ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(labelClasses))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            __props.icon ? (openBlock(), createBlock(_sfc_main, {
              key: 0,
              icon: __props.icon,
              pack: __props.iconPack,
              size: __props.iconSize
            }, null, 8, ["icon", "pack", "size"])) : createCommentVNode("", true),
            createBaseVNode("span", null, toDisplayString(__props.label), 1)
          ])
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("ul", {
          class: normalizeClass(unref(listClasses)),
          role: __props.ariaRole
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_1$13)
      ], 2);
    };
  }
});
var _hoisted_112 = ["role", "data-id"];
var _sfc_main17 = defineComponent({
  ...{
    isOruga: true,
    name: "OMenuItem",
    configField: "menu",
    inheritAttrs: false
  },
  __name: "MenuItem",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** The active state of the menu item, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /** Menu item label */
    label: { type: String, default: void 0 },
    /** Menu item will be expanded */
    expanded: { type: Boolean, default: false },
    /** Menu item will be disabled */
    disabled: { type: Boolean, default: false },
    /** Icon to be shown */
    icon: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("menu.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => getOption("menu.iconSize")
    },
    /** Transition name to apply on menu list */
    animation: {
      type: String,
      default: () => getOption("menu.animation", "slide")
    },
    /** Menu item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => getOption("menu.menuTag", "button")
    },
    /**
     * Role attribute to be passed to the list item for better accessibility.
     * @values listitem, menuitem
     */
    ariaRole: {
      type: String,
      default: getOption("menu.itemAriaRole", "menuitem")
    },
    // class props (will not be displayed in the docs)
    /** Class of the menu item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the active menu item */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the disabled menu item */
    itemDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon of menu item */
    itemIconTextClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu item when is a submenu */
    itemSubmenuClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element of menu item */
    itemWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {},
    "expanded": { type: Boolean, ...{ default: false } },
    "expandedModifiers": {}
  }),
  emits: mergeModels(["update:active", "update:expanded"], ["update:active", "update:expanded"]),
  setup(__props) {
    const props = __props;
    const providedData = computed(() => ({
      reset
    }));
    const { parent, item } = useProviderChild({
      data: providedData
    });
    const providedItem = useProviderChild({
      key: "menu-item",
      needParent: false
    });
    const itemParent = computed(() => {
      var _a;
      return (_a = providedItem.parent) == null ? void 0 : _a.value;
    });
    const isActive = useModel(__props, "active");
    const isExpanded = useModel(__props, "expanded");
    const identifier = computed(
      () => itemParent.value ? `menu-item-${providedItem.item.value.identifier}` : `menu-${item.value.identifier}`
    );
    function onClick() {
      if (props.disabled)
        return;
      triggerReset();
      if (parent.value.accordion)
        isExpanded.value = !isExpanded.value;
      if (parent.value.activable)
        isActive.value = !isActive.value;
    }
    function triggerReset(child) {
      var _a;
      if (typeof ((_a = itemParent.value) == null ? void 0 : _a.triggerReset) === "function") {
        itemParent.value.triggerReset(toRaw(item.value));
      } else if (typeof parent.value.resetMenu === "function") {
        parent.value.resetMenu([toRaw(item.value), child]);
      }
    }
    function reset() {
      if (parent.value.accordion)
        isExpanded.value = false;
      if (parent.value.activable)
        isActive.value = false;
    }
    const rootRef = ref();
    const provideData = computed(() => ({
      triggerReset
    }));
    useProviderParent(rootRef, { key: "menu-item", data: provideData });
    const wrapperClasses = defineClasses([
      "itemWrapperClass",
      "o-menu__item__wrapper"
    ]);
    const itemClasses = defineClasses(
      ["itemClass", "o-menu__item"],
      ["itemActiveClass", "o-menu__item--active", null, isActive],
      [
        "itemDisabledClass",
        "o-menu__item--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "itemIconTextClass",
        "o-menu__item--icon-text",
        null,
        computed(() => !!props.icon)
      ]
    );
    const submenuClasses = defineClasses([
      "itemSubmenuClass",
      "o-menu__item__submenu"
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", {
        ref_key: "rootRef",
        ref: rootRef,
        role: __props.ariaRole,
        class: normalizeClass(unref(wrapperClasses)),
        "data-id": identifier.value,
        "data-oruga": "menu-item",
        "aria-roledescription": "item"
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(__props.tag), mergeProps(_ctx.$attrs, {
          class: unref(itemClasses),
          role: "button",
          disabled: __props.disabled,
          onKeyup: _cache[0] || (_cache[0] = withKeys(($event) => onClick(), ["enter"])),
          onClick: _cache[1] || (_cache[1] = ($event) => onClick())
        }), {
          default: withCtx(() => [
            __props.icon ? (openBlock(), createBlock(_sfc_main, {
              key: 0,
              icon: __props.icon,
              pack: __props.iconPack,
              size: __props.iconSize
            }, null, 8, ["icon", "pack", "size"])) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "label", {
              expanded: isExpanded.value,
              active: isActive.value
            }, () => [
              createBaseVNode("span", null, toDisplayString(__props.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["class", "disabled"])),
        _ctx.$slots.default ? (openBlock(), createBlock(Transition, {
          key: 0,
          name: __props.animation
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("ul", {
              class: normalizeClass(unref(submenuClasses))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2), [
              [vShow, isExpanded.value]
            ])
          ]),
          _: 3
        }, 8, ["name"])) : createCommentVNode("", true)
      ], 10, _hoisted_112);
    };
  }
});
var index13 = {
  install(app) {
    registerComponent(app, _sfc_main$14);
    registerComponent(app, _sfc_main17);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/modal.mjs
var _hoisted_113 = ["role", "aria-label", "aria-modal"];
var _hoisted_28 = { key: 0 };
var _sfc_main18 = defineComponent({
  ...{
    isOruga: true,
    name: "OModal",
    configField: "modal",
    inheritAttrs: false
  },
  __name: "Modal",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether modal is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: false },
    /** Display modal as full screen */
    fullScreen: { type: Boolean, default: false },
    /** Text content, unnecessary when default slot is used */
    content: { type: String, default: void 0 },
    /** Width of the Modal */
    width: {
      type: [String, Number],
      default: () => getOption("modal.width", 960)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("modal.animation", "zoom-out")
    },
    /**
     * Is Modal cancleable by clicking 'X', pressing escape or clicking outside
     * @values escape, x, outside, button, true, false
     */
    cancelable: {
      type: [Array, Boolean],
      default: () => getOption("modal.cancelable", ["escape", "x", "outside", "button"])
    },
    /** Callback function to call after user canceled (clicked 'X' / pressed escape / clicked outside) */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled) */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Use `clip` to remove the body scrollbar, `keep` to have a non scrollable scrollbar to avoid shifting background,
     * but will set body to position fixed, might break some layouts.
     * @values keep, clip
     */
    scroll: {
      type: String,
      default: () => getOption("modal.scroll", "keep"),
      validator: (value) => ["keep", "clip"].indexOf(value) >= 0
    },
    /** Trap focus inside the modal */
    trapFocus: {
      type: Boolean,
      default: () => getOption("modal.trapFocus", true)
    },
    /**
     * Role attribute to be passed to the div wrapper for better accessibility.
     * @values dialog, alertdialog
     */
    ariaRole: {
      type: String,
      default: () => getOption("modal.ariaRole"),
      validator: (value) => ["dialog", "alertdialog"].indexOf(value) >= 0
    },
    /** Accessibility aria-label to be passed to the div wrapper element */
    ariaLabel: { type: String, default: () => getOption("modal.ariaLabel") },
    /** Destroy modal on hide - default `true` for programmatic usage */
    destroyOnHide: {
      type: Boolean,
      default: () => getOption("modal.destroyOnHide", false)
    },
    /** Automatically focus modal when active */
    autoFocus: {
      type: Boolean,
      default: () => getOption("modal.autoFocus", true)
    },
    /** Close icon name */
    closeIcon: {
      type: String,
      default: () => getOption("modal.closeIcon", "close")
    },
    /**
     * Size of close icon
     * @values small, medium, large
     */
    closeIconSize: {
      type: String,
      default: () => getOption("modal.closeIconSize", "medium")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("modal.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("modal.teleport", false)
    },
    /**
     * Component to be injected, used to open a component modal programmatically.
     * Close modal within the component by emitting a 'close' event  emits('close')
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component */
    events: { type: Object, default: () => ({}) },
    /** DOM element where the modal component will be created on (for programmatic usage) */
    container: {
      type: [Object, String],
      default: () => getOption("modal.container", "body")
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of modal component when its active */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when fullscreen */
    fullScreenClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of modal component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when scroll is clip */
    scrollClipClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when scroll is not clip */
    noScrollClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = ref();
    const { isActive, close, cancel } = useProgrammaticComponent(
      rootRef,
      props,
      emits,
      {
        destroyOnHide: props.destroyOnHide,
        cancelOptions: getOption("modal.cancelable", [
          "escape",
          "x",
          "outside",
          "button"
        ])
      }
    );
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const _teleport = computed(
      () => typeof props.teleport === "boolean" ? { to: "body", disabled: !props.teleport } : { to: props.teleport, disabled: false }
    );
    const savedScrollTop = ref(null);
    const isAnimating = ref(!props.active);
    watch(isActive, (value) => {
      handleScroll();
      if (value && rootRef.value && props.autoFocus)
        nextTick(() => rootRef.value.focus());
      if (!value && props.destroyOnHide)
        setTimeout(() => removeElement(rootRef.value));
    });
    const showX = computed(
      () => Array.isArray(props.cancelable) ? props.cancelable.indexOf("x") >= 0 : props.cancelable
    );
    const customStyle = computed(
      () => !props.fullScreen ? { maxWidth: toCssDimension(props.width) } : null
    );
    onBeforeUnmount(() => {
      if (isClient) {
        const scrollto = savedScrollTop.value ? savedScrollTop.value : document.documentElement.scrollTop;
        if (scrollClass.value) {
          document.body.classList.remove(...scrollClass.value);
          document.documentElement.classList.remove(...scrollClass.value);
        }
        document.documentElement.scrollTop = scrollto;
        document.body.style.top = null;
      }
    });
    function handleScroll() {
      if (!isClient)
        return;
      if (props.scroll === "clip") {
        if (scrollClass.value) {
          if (isActive.value)
            document.documentElement.classList.add(...scrollClass.value);
          else
            document.documentElement.classList.remove(...scrollClass.value);
        }
        return;
      }
      savedScrollTop.value = savedScrollTop.value ? savedScrollTop.value : document.documentElement.scrollTop;
      if (scrollClass.value) {
        if (isActive.value)
          document.body.classList.add(...scrollClass.value);
        else
          document.body.classList.remove(...scrollClass.value);
      }
      if (isActive.value) {
        document.body.style.top = `-${savedScrollTop.value}px`;
        return;
      }
      document.documentElement.scrollTop = savedScrollTop.value;
      document.body.style.top = null;
      savedScrollTop.value = null;
    }
    function afterEnter() {
      isAnimating.value = false;
    }
    function beforeLeave() {
      isAnimating.value = true;
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-modal"],
      ["mobileClass", "o-modal--mobile", null, isMobile],
      ["activeClass", "o-modal--active", null, isActive]
    );
    const overlayClasses = defineClasses(["overlayClass", "o-modal__overlay"]);
    const contentClasses = defineClasses(
      ["contentClass", "o-modal__content"],
      [
        "fullScreenClass",
        "o-modal__content--full-screen",
        null,
        computed(() => props.fullScreen)
      ]
    );
    const closeClasses = defineClasses(["closeClass", "o-modal__close"]);
    const scrollClasses = defineClasses(["scrollClipClass", "o-clipped"]);
    const noScrollClasses = defineClasses(["noScrollClass", "o-noscroll"]);
    const scrollClass = computed(
      () => getActiveClasses(
        props.scroll === "clip" ? scrollClasses.value : noScrollClasses.value
      )
    );
    scrollClass.value;
    __expose({ close, promise: props.promise });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: _teleport.value.to,
        disabled: _teleport.value.disabled
      }, [
        createVNode(Transition, {
          name: __props.animation,
          onAfterEnter: afterEnter,
          onBeforeLeave: beforeLeave
        }, {
          default: withCtx(() => [
            withDirectives((openBlock(), createElementBlock("div", mergeProps(_ctx.$attrs, {
              ref_key: "rootRef",
              ref: rootRef,
              "data-oruga": "modal",
              class: unref(rootClasses),
              tabindex: -1,
              role: __props.ariaRole,
              "aria-label": __props.ariaLabel,
              "aria-modal": unref(isActive)
            }), [
              createBaseVNode("div", {
                class: normalizeClass(unref(overlayClasses)),
                tabindex: "-1",
                "aria-hidden": "true",
                onClick: _cache[0] || (_cache[0] = ($event) => unref(cancel)("outside"))
              }, null, 2),
              createBaseVNode("div", {
                class: normalizeClass(unref(contentClasses)),
                style: normalizeStyle(customStyle.value)
              }, [
                __props.component ? (openBlock(), createBlock(resolveDynamicComponent(__props.component), mergeProps({ key: 0 }, _ctx.$props.props, toHandlers(_ctx.$props.events), { onClose: unref(close) }), null, 16, ["onClose"])) : renderSlot(_ctx.$slots, "default", {
                  key: 1,
                  close: unref(close)
                }, () => [
                  __props.content ? (openBlock(), createElementBlock("div", _hoisted_28, toDisplayString(__props.content), 1)) : createCommentVNode("", true)
                ]),
                showX.value ? withDirectives((openBlock(), createBlock(_sfc_main, {
                  key: 2,
                  clickable: "",
                  both: "",
                  class: normalizeClass(unref(closeClasses)),
                  icon: __props.closeIcon,
                  size: __props.closeIconSize,
                  onClick: _cache[1] || (_cache[1] = ($event) => unref(cancel)("x"))
                }, null, 8, ["class", "icon", "size"])), [
                  [vShow, !isAnimating.value]
                ]) : createCommentVNode("", true)
              ], 6)
            ], 16, _hoisted_113)), [
              [vShow, unref(isActive)],
              [unref(vTrapFocus), __props.trapFocus]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 8, ["to", "disabled"]);
    };
  }
});
var instances2 = new InstanceRegistry();
var ModalProgrammatic = {
  open(params) {
    const componentParams = typeof params === "string" ? {
      content: params
    } : { ...params };
    let slot;
    if (Array.isArray(componentParams.content)) {
      slot = componentParams.content;
      delete componentParams.content;
    }
    const defaultParams = {
      programmatic: { instances: instances2 },
      active: true,
      // set the active state to true
      destroyOnHide: true
      // set destroy on hide true
    };
    const propsData = merge(defaultParams, componentParams);
    propsData.promise = new Promise((p1, p2) => {
      propsData.programmatic.resolve = p1;
      propsData.programmatic.reject = p2;
    });
    const defaultSlot = () => slot;
    const app = VueInstance;
    const vnode = createVNode(_sfc_main18, propsData, defaultSlot);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.exposed;
  },
  closeAll(...args) {
    instances2.walk((entry) => entry.exposed.close(...args));
  }
};
var ModalProgrammatic$1 = ModalProgrammatic;
var index14 = {
  install(app) {
    registerComponent(app, _sfc_main18);
    registerComponentProgrammatic(app, "modal", ModalProgrammatic$1);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/notification.mjs
var _hoisted_114 = ["aria-label"];
var _hoisted_29 = ["innerHTML"];
var _sfc_main$15 = defineComponent({
  ...{
    isOruga: true,
    name: "ONotification",
    configField: "notification",
    inheritAttrs: false
  },
  __name: "Notification",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether modal is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: true },
    /**
     * Type (color) of the notification
     * @values info, success, warning, danger
     */
    type: {
      type: String,
      default: void 0,
      validator: (value) => ["info", "success", "warning", "danger", void 0].indexOf(value) > -1
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("notification.variant")
    },
    /**
     * Which position the notification will appear when programmatically
     * @values top-right, top, top-left, bottom-right, bottom, bottom-left
     */
    position: {
      type: String,
      default: () => getOption("notification.position", "top"),
      validator: (value) => [
        "top-right",
        "top",
        "top-left",
        "bottom-right",
        "bottom",
        "bottom-left"
      ].indexOf(value) > -1
    },
    /** Message text (can contain HTML), unnecessary when default slot is used */
    message: {
      type: [String, Array],
      default: void 0
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("notification.animation", "fade")
    },
    /** Accessibility label for the close button */
    ariaCloseLabel: {
      type: String,
      default: () => getOption("notification.ariaCloseLabel", "Close")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("notification.iconPack")
    },
    /** Icon name to use */
    icon: { type: String, default: void 0 },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => getOption("notification.iconSize", "large")
    },
    /** Add close button to the item that closes the notification */
    closable: { type: Boolean, default: false },
    /** Close icon name */
    closeIcon: {
      type: String,
      default: () => getOption("notification.closeIcon", "close")
    },
    /**
     * Size of close icon
     * @values small, medium, large
     */
    closeIconSize: {
      type: String,
      default: () => getOption("notification.closeIconSize")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button container */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the content element */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon on the left */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the element when positioned */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the notification variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the wrapper element */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isActive = usePropBinding("active", props, emits, {
      passive: true
    });
    const computedIcon = computed(() => {
      if (props.icon)
        return props.icon;
      switch (props.type) {
        case "info":
          return "information";
        case "success":
          return "check-circle";
        case "warning":
          return "alert";
        case "danger":
          return "alert-circle";
        default:
          return null;
      }
    });
    function close(...args) {
      isActive.value = false;
      emits("close", ...args);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-notification"],
      [
        "variantClass",
        "o-notification--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "positionClass",
        "o-notification--",
        computed(() => props.position),
        computed(() => !!props.position)
      ]
    );
    const wrapperClasses = defineClasses([
      "wrapperClass",
      "o-notification__wrapper"
    ]);
    const iconClasses = defineClasses(["iconClass", "o-notification__icon"]);
    const contentClasses = defineClasses([
      "contentClass",
      "o-notification__content"
    ]);
    const closeClasses = defineClasses(["closeClass", "o-notification__close"]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: __props.animation }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("article", mergeProps(_ctx.$attrs, {
            class: unref(rootClasses),
            "data-oruga": "notification"
          }), [
            __props.closable ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: normalizeClass(unref(closeClasses)),
              type: "button",
              "aria-label": __props.ariaCloseLabel,
              onClick: _cache[0] || (_cache[0] = ($event) => close({ action: "close", method: "x" }))
            }, [
              createVNode(_sfc_main, {
                clickable: "",
                pack: __props.iconPack,
                both: "",
                icon: __props.closeIcon,
                size: __props.closeIconSize
              }, null, 8, ["pack", "icon", "size"])
            ], 10, _hoisted_114)) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "inner", { close }),
            _ctx.$slots.default || __props.message ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(wrapperClasses))
            }, [
              computedIcon.value ? (openBlock(), createBlock(_sfc_main, {
                key: 0,
                icon: computedIcon.value,
                pack: __props.iconPack,
                class: normalizeClass(unref(iconClasses)),
                both: "",
                size: __props.iconSize,
                "aria-hidden": ""
              }, null, 8, ["icon", "pack", "class", "size"])) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass(unref(contentClasses))
              }, [
                renderSlot(_ctx.$slots, "default", { close }, () => [
                  __props.message ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    innerHTML: __props.message
                  }, null, 8, _hoisted_29)) : createCommentVNode("", true)
                ])
              ], 2)
            ], 2)) : createCommentVNode("", true)
          ], 16), [
            [vShow, unref(isActive)]
          ])
        ]),
        _: 3
      }, 8, ["name"]);
    };
  }
});
var _sfc_main19 = defineComponent({
  ...{
    isOruga: true,
    name: "ONotificationNotice",
    configField: "notification",
    inheritAttrs: false
  },
  __name: "NotificationNotice",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether notification is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: true },
    /**
     * Which position the notification will appear when programmatically.
     * @values top-right, top, top-left, bottom-right, bottom, bottom-left
     */
    position: {
      type: String,
      default: () => getOption("notification.position", "top"),
      validator: (value) => [
        "top-right",
        "top",
        "top-left",
        "bottom-right",
        "bottom",
        "bottom-left"
      ].indexOf(value) > -1
    },
    /** Hide notification after duration (in miliseconds) */
    duration: {
      type: Number,
      default: () => getOption("notification.duration", 2e3)
    },
    /** Show the Notification infinitely until it is dismissed. */
    infinite: { type: Boolean, default: false },
    /** If notice should queue with others notices (snackbar/toast/notification). */
    queue: {
      type: Boolean,
      default: () => getOption("notification.queue")
    },
    /** Callback function to call after user canceled (pressed escape / clicked outside). */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled). */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Component to be injected.
     * Close notification within the component by emitting a 'close' event  $emit('close').
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component. */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component. */
    events: { type: Object, default: () => ({}) },
    /**
     * DOM element the toast will be created on (for programmatic usage).
     * Note that this also changes the position of the toast from fixed to absolute.
     * Meaning that the container should be fixed.
     */
    container: {
      type: [Object, String],
      default: () => getOption("notification.container", "body")
    },
    /**
     * Props passed to the internal notification component.
     * @ignore
     */
    notification: {
      type: Object,
      default: () => ({})
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Root class of the notice */
    noticeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the notice when positioned */
    noticePositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the custom container element */
    noticeCustomContainerClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const notificationRef = ref();
    const { isActive, close, container } = useProgrammaticComponent(
      () => notificationRef.value.$el,
      props,
      emits,
      {
        cancelOptions: ["escape", "x"]
      }
    );
    const parentTop = ref(null);
    const parentBottom = ref(null);
    const timer = ref();
    watch(
      () => isActive,
      (value) => {
        if (value)
          setAutoClose();
        else if (timer.value)
          clearTimeout(timer.value);
      }
    );
    onBeforeMount(() => {
      if (noticeClasses.value && positionBottomClasses.value && positionTopClasses.value) {
        const rootClasses = getActiveClasses(noticeClasses.value);
        const topClasses = getActiveClasses(positionTopClasses.value);
        const bottomClasses = getActiveClasses(positionBottomClasses.value);
        parentTop.value = container.value.querySelector(
          `.${rootClasses.join(".")}.${topClasses.join(".")}`
        );
        parentBottom.value = container.value.querySelector(
          `.${rootClasses.join(".")}.${bottomClasses.join(".")}`
        );
        if (parentTop.value && parentBottom.value)
          return;
        if (!parentTop.value) {
          parentTop.value = document.createElement("div");
          parentTop.value.className = `${rootClasses.join(
            " "
          )} ${topClasses.join(" ")}`;
        }
        if (!parentBottom.value) {
          parentBottom.value = document.createElement("div");
          parentBottom.value.className = `${rootClasses.join(
            " "
          )} ${bottomClasses.join(" ")}`;
        }
        container.value.appendChild(parentTop.value);
        container.value.appendChild(parentBottom.value);
        if (container.value.tagName !== "BODY") {
          const classes = getActiveClasses(
            noticeCustomContainerClasses.value
          );
          if (classes == null ? void 0 : classes.length)
            classes.filter((c) => !!c).forEach((c) => {
              parentTop.value.classList.add(c);
              parentBottom.value.classList.add(c);
            });
        }
      }
    });
    onMounted(() => {
      showNotice();
      setAutoClose();
    });
    const correctParent = computed(() => {
      switch (props.position) {
        case "top-right":
        case "top":
        case "top-left":
          return parentTop.value;
        case "bottom-right":
        case "bottom":
        case "bottom-left":
          return parentBottom.value;
        default:
          return null;
      }
    });
    const shouldQueue = computed(
      () => props.queue ? parentTop.value.childElementCount > 0 || parentBottom.value.childElementCount > 0 : false
    );
    function showNotice() {
      if (shouldQueue.value)
        correctParent.value.innerHTML = "";
      correctParent.value.insertAdjacentElement(
        "afterbegin",
        notificationRef.value.$el
      );
      isActive.value = true;
    }
    function setAutoClose() {
      if (!props.infinite) {
        if (timer.value)
          clearTimeout(timer.value);
        timer.value = setTimeout(() => {
          if (isActive.value)
            handleClose({ action: "close", method: "timeout" });
        }, props.duration);
      }
    }
    function handleClose(...args) {
      clearTimeout(timer.value);
      close(...args);
    }
    const noticeClasses = defineClasses(["noticeClass", "o-notices"]);
    const positionTopClasses = defineClasses([
      "noticePositionClass",
      "o-notices--",
      "top"
    ]);
    const positionBottomClasses = defineClasses([
      "noticePositionClass",
      "o-notices--",
      "bottom"
    ]);
    const noticeCustomContainerClasses = defineClasses([
      "noticeCustomContainerClass",
      "o-notices__custom-container"
    ]);
    __expose({ close: handleClose, promise: props.promise });
    return (_ctx, _cache) => {
      const _component_o_notification = resolveComponent("o-notification");
      return openBlock(), createBlock(_component_o_notification, mergeProps(__props.notification, {
        ref_key: "notificationRef",
        ref: notificationRef,
        active: unref(isActive),
        "onUpdate:active": _cache[0] || (_cache[0] = ($event) => isRef(isActive) ? isActive.value = $event : null),
        position: __props.position,
        onClose: handleClose
      }), {
        inner: withCtx(({ close: close2 }) => [
          __props.component ? (openBlock(), createBlock(resolveDynamicComponent(__props.component), mergeProps({ key: 0 }, _ctx.$props.props, toHandlers(_ctx.$props.events), { onClose: close2 }), null, 16, ["onClose"])) : createCommentVNode("", true)
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["active", "position"]);
    };
  }
});
var instances3 = new InstanceRegistry();
var NotificationProgrammatic = {
  open(params) {
    const componentParams = typeof params === "string" ? {
      message: params
    } : { ...params };
    let slot;
    if (Array.isArray(componentParams.message)) {
      slot = componentParams.message;
      delete componentParams.message;
    }
    const defaultParams = {
      programmatic: { instances: instances3 },
      active: true,
      // set the active state to true
      position: getOption("notification.position", "top-right")
    };
    const notificationParams = componentParams.notification ? componentParams.notification : componentParams;
    const propsData = merge(defaultParams, componentParams);
    propsData.notification = merge({}, notificationParams);
    propsData.promise = new Promise((p1, p2) => {
      propsData.programmatic.resolve = p1;
      propsData.programmatic.reject = p2;
    });
    const defaultSlot = () => slot;
    const app = VueInstance;
    const vnode = createVNode(_sfc_main19, propsData, defaultSlot);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.exposed;
  },
  closeAll(...args) {
    instances3.walk((entry) => entry.exposed.close(...args));
  }
};
var NotificationProgrammatic$1 = NotificationProgrammatic;
var index15 = {
  install(app) {
    registerComponent(app, _sfc_main$15);
    registerComponentProgrammatic(
      app,
      "notification",
      NotificationProgrammatic$1
    );
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Pagination.vue_vue_type_script_setup_true_lang-DOjx2YR8.mjs
var _sfc_main$16 = defineComponent({
  ...{
    isOruga: true,
    name: "OPaginationButton",
    configField: "pagination"
  },
  __name: "PaginationButton",
  props: {
    number: { type: Number, default: void 0 },
    isCurrent: { type: Boolean, default: false },
    click: {
      type: Function,
      required: true
    },
    ariaLabel: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false },
    tag: {
      type: [String, Object, Function],
      default: "button"
    },
    class: { type: String, default: void 0 },
    linkClass: {
      type: Array,
      required: true
    },
    linkCurrentClass: {
      type: Array,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const linkClasses = computed(() => [
      ...props.linkClass,
      props.class,
      ...props.isCurrent ? props.linkCurrentClass : []
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), mergeProps({
        role: "button",
        tabindex: __props.disabled ? null : 0,
        disabled: __props.disabled,
        class: linkClasses.value
      }, _ctx.$attrs, {
        "aria-label": __props.ariaLabel,
        "aria-current": __props.isCurrent,
        onClick: withModifiers(__props.click, ["prevent"]),
        onKeydown: withKeys(withModifiers(__props.click, ["prevent"]), ["enter"])
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.number), 1)
          ])
        ]),
        _: 3
      }, 16, ["tabindex", "disabled", "class", "aria-label", "aria-current", "onClick", "onKeydown"]);
    };
  }
});
var _sfc_main20 = defineComponent({
  ...{
    isOruga: true,
    name: "OPagination",
    configField: "pagination",
    inheritAttrs: false
  },
  __name: "Pagination",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Total count of items */
    total: { type: Number, default: void 0 },
    /** Items count for each page */
    perPage: {
      type: [Number, String],
      default: () => getOption("pagination.perPage", 20)
    },
    /** Current page number, use v-model:current to make it two-way binding. */
    current: { type: Number, default: 1 },
    /** Number of pagination items to show before current page. */
    rangeBefore: { type: Number, default: 1 },
    /** Number of pagination items to show after current page. */
    rangeAfter: { type: Number, default: 1 },
    /**
     * Pagination size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("pagination.size")
    },
    /** Simple style */
    simple: {
      type: Boolean,
      default: () => getOption("pagination.simple", false)
    },
    /** Rounded button style */
    rounded: {
      type: Boolean,
      default: () => getOption("pagination.rounded", false)
    },
    /**
     * Buttons order
     * @values centered, right, left
     */
    order: {
      type: String,
      default: () => getOption("pagination.order", "right"),
      validator: (value) => ["centered", "right", "left"].indexOf(value) >= 0
    },
    /** Pagination button tag name */
    buttonTag: {
      type: [String, Object, Function],
      default: () => getOption("pagination.buttonTag", "button")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("pagination.iconPack")
    },
    /** Icon to use for previous button */
    iconPrev: {
      type: String,
      default: () => getOption("pagination.iconPrev", "chevron-left")
    },
    /** Icon to use for next button */
    iconNext: {
      type: String,
      default: () => getOption("pagination.iconNext", "chevron-right")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("pagination.mobileBreakpoint")
    },
    /** Accessibility label for the next page button. */
    ariaNextLabel: {
      type: String,
      default: () => getOption("pagination.ariaNextLabel", "Next page")
    },
    /** Accessibility label for the previous page button. */
    ariaPreviousLabel: {
      type: String,
      default: () => getOption("pagination.ariaPreviousLabel", "Previous page")
    },
    /** Accessibility label for the page button. */
    ariaPageLabel: {
      type: String,
      default: () => getOption("pagination.ariaPageLabel", "page")
    },
    /** Accessibility label for the current page button. */
    ariaCurrentLabel: {
      type: String,
      default: () => getOption("pagination.ariaCurrentLabel", "Current page")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the prev button */
    prevButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the next button */
    nextButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination list */
    listClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination list items */
    listItemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the link button */
    linkClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the current link */
    linkCurrentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination ellipsis */
    ellipsisClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the info in `simple` mode */
    infoClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination order */
    orderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination in `simple` mode */
    simpleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the disabled link */
    linkDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the pagination size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of pagination component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:current", "change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const current = usePropBinding("current", props, emits);
    const pageCount = computed(
      () => Math.ceil(props.total / Number(props.perPage))
    );
    watch(
      () => pageCount.value,
      (value) => {
        if (props.current > value)
          last();
      }
    );
    const firstItem = computed(() => {
      const perPage = Number(props.perPage);
      const firstItem2 = props.current * perPage - perPage + 1;
      return firstItem2 >= 0 ? firstItem2 : 0;
    });
    const hasPrev = computed(() => props.current > 1);
    const hasFirst = computed(() => props.current >= 2 + props.rangeBefore);
    const hasFirstEllipsis = computed(() => props.current >= props.rangeBefore + 4);
    const hasLast = computed(
      () => props.current <= pageCount.value - (1 + props.rangeAfter)
    );
    const hasLastEllipsis = computed(
      () => props.current < pageCount.value - (2 + props.rangeAfter)
    );
    const hasNext = computed(() => props.current < pageCount.value);
    const pagesInRange = computed(() => {
      if (props.simple)
        return;
      let left = Math.max(1, props.current - props.rangeBefore);
      if (left - 1 === 2) {
        left--;
      }
      let right = Math.min(props.current + props.rangeAfter, pageCount.value);
      if (pageCount.value - right === 2) {
        right++;
      }
      const pages = [];
      for (let i = left; i <= right; i++) {
        pages.push(getPage(i));
      }
      return pages;
    });
    function getPage(num, ariaLabel) {
      return {
        number: num,
        isCurrent: props.current === num,
        click: (event) => changePage(num, event),
        ariaLabel: ariaLabel || getAriaPageLabel(num, props.current === num),
        tag: props.buttonTag
      };
    }
    function getAriaPageLabel(pageNumber, isCurrent) {
      if (props.ariaPageLabel && (!isCurrent || !props.ariaCurrentLabel))
        return props.ariaPageLabel + " " + pageNumber + ".";
      else if (props.ariaPageLabel && isCurrent && props.ariaCurrentLabel)
        return props.ariaCurrentLabel + ", " + props.ariaPageLabel + " " + pageNumber + ".";
      return null;
    }
    function prev(event) {
      changePage(props.current - 1, event);
    }
    function next(event) {
      changePage(props.current + 1, event);
    }
    function first(event) {
      changePage(1, event);
    }
    function last(event) {
      changePage(pageCount.value, event);
    }
    function changePage(page, event) {
      if (props.current === page || page < 1 || page > pageCount.value)
        return;
      emits("change", page);
      current.value = page;
      if (event && event.target)
        nextTick(() => event.target.focus());
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-pag"],
      [
        "orderClass",
        "o-pag--",
        computed(() => props.order),
        computed(() => !!props.order)
      ],
      [
        "sizeClass",
        "o-pag--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      ["simpleClass", "o-pag--simple", null, computed(() => props.simple)],
      ["mobileClass", "o-pag--mobile", null, isMobile]
    );
    const prevBtnClasses = defineClasses(
      ["prevButtonClass", "o-pag__previous"],
      [
        "linkDisabledClass",
        "o-pag__link--disabled",
        null,
        computed(() => !hasPrev.value)
      ]
    );
    const nextBtnClasses = defineClasses(
      ["nextButtonClass", "o-pag__next"],
      [
        "linkDisabledClass",
        "o-pag__link--disabled",
        null,
        computed(() => !hasNext.value)
      ]
    );
    const infoClasses = defineClasses(["infoClass", "o-pag__info"]);
    const ellipsisClasses = defineClasses(["ellipsisClass", "o-pag__ellipsis"]);
    const listClasses = defineClasses(["listClass", "o-pag__list"]);
    const linkClasses = defineClasses(
      ["linkClass", "o-pag__link"],
      [
        "roundedClass",
        "o-pag__link--rounded",
        null,
        computed(() => props.rounded)
      ]
    );
    const linkCurrentClasses = defineClasses([
      "linkCurrentClass",
      "o-pag__link--current"
    ]);
    const listItemClasses = defineClasses(["listItemClass", "o-pag__item"]);
    __expose({ last, first, prev, next });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("nav", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "pagination"
      }, [
        renderSlot(_ctx.$slots, "previous", normalizeProps(guardReactiveProps(getPage(unref(current) - 1, __props.ariaPreviousLabel))), () => [
          createVNode(_sfc_main$16, mergeProps(getPage(unref(current) - 1, __props.ariaPreviousLabel), {
            class: unref(prevBtnClasses),
            "link-class": unref(linkClasses),
            "link-current-class": unref(linkCurrentClasses)
          }), {
            default: withCtx(() => [
              createVNode(_sfc_main, {
                icon: __props.iconPrev,
                pack: __props.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8, ["icon", "pack"])
            ]),
            _: 1
          }, 16, ["class", "link-class", "link-current-class"])
        ]),
        renderSlot(_ctx.$slots, "next", normalizeProps(guardReactiveProps(getPage(unref(current) + 1, __props.ariaNextLabel))), () => [
          createVNode(_sfc_main$16, mergeProps(getPage(unref(current) + 1, __props.ariaNextLabel), {
            class: unref(nextBtnClasses),
            "link-class": unref(linkClasses),
            "link-current-class": unref(linkCurrentClasses)
          }), {
            default: withCtx(() => [
              createVNode(_sfc_main, {
                icon: __props.iconNext,
                pack: __props.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8, ["icon", "pack"])
            ]),
            _: 1
          }, 16, ["class", "link-class", "link-current-class"])
        ]),
        __props.simple ? (openBlock(), createElementBlock("small", {
          key: 0,
          class: normalizeClass(unref(infoClasses))
        }, [
          __props.perPage == 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(firstItem.value) + " / " + toDisplayString(__props.total), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(firstItem.value) + "-" + toDisplayString(Math.min(unref(current) * Number(__props.perPage), __props.total)) + " / " + toDisplayString(__props.total), 1)
          ], 64))
        ], 2)) : (openBlock(), createElementBlock("ul", {
          key: 1,
          class: normalizeClass(unref(listClasses))
        }, [
          hasFirst.value ? (openBlock(), createElementBlock("li", {
            key: 0,
            class: normalizeClass(unref(listItemClasses))
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(getPage(1))), () => [
              createVNode(_sfc_main$16, mergeProps(getPage(1), {
                "link-class": unref(linkClasses),
                "link-current-class": unref(linkCurrentClasses)
              }), null, 16, ["link-class", "link-current-class"])
            ])
          ], 2)) : createCommentVNode("", true),
          hasFirstEllipsis.value ? (openBlock(), createElementBlock("li", {
            key: 1,
            class: normalizeClass(unref(listItemClasses))
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ellipsisClasses))
            }, "", 2)
          ], 2)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(pagesInRange.value, (page) => {
            return openBlock(), createElementBlock("li", {
              key: page.number,
              class: normalizeClass(unref(listItemClasses))
            }, [
              renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(page)), () => [
                createVNode(_sfc_main$16, mergeProps(page, {
                  "link-class": unref(linkClasses),
                  "link-current-class": unref(linkCurrentClasses)
                }), null, 16, ["link-class", "link-current-class"])
              ])
            ], 2);
          }), 128)),
          hasLastEllipsis.value ? (openBlock(), createElementBlock("li", {
            key: 2,
            class: normalizeClass(unref(listItemClasses))
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ellipsisClasses))
            }, "", 2)
          ], 2)) : createCommentVNode("", true),
          hasLast.value ? (openBlock(), createElementBlock("li", {
            key: 3,
            class: normalizeClass(unref(listItemClasses))
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(getPage(pageCount.value))), () => [
              createVNode(_sfc_main$16, mergeProps(getPage(pageCount.value), {
                "link-class": unref(linkClasses),
                "link-current-class": unref(linkCurrentClasses)
              }), null, 16, ["link-class", "link-current-class"])
            ])
          ], 2)) : createCommentVNode("", true)
        ], 2))
      ], 2);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/pagination.mjs
var index16 = {
  install(app) {
    registerComponent(app, _sfc_main20);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/radio.mjs
var _hoisted_115 = ["aria-checked"];
var _hoisted_210 = ["disabled", "required", "name", "autocomplete", "value"];
var _sfc_main21 = defineComponent({
  ...{
    isOruga: true,
    name: "ORadio",
    configField: "radio",
    inheritAttrs: false
  },
  __name: "Radio",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("radio.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("radio.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Same as native required */
    required: { type: Boolean, default: false },
    /** Same as native name */
    name: { type: String, default: void 0 },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("radio.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when radio is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element when checked */
    checkedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "focus", "blur", "invalid"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const inputRef = ref();
    const { onBlur, onFocus, onInvalid, setFocus } = useInputHandler(
      inputRef,
      emits,
      props
    );
    const vmodel = useVModelBinding(props, emits);
    const isChecked = computed(() => vmodel.value === props.nativeValue);
    function onInput(event) {
      emits("input", vmodel.value, event);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-radio"],
      ["checkedClass", "o-radio--checked", null, isChecked],
      [
        "sizeClass",
        "o-radio--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "disabledClass",
        "o-radio--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "variantClass",
        "o-radio--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    const inputClasses = defineClasses(
      ["inputClass", "o-radio__input"],
      ["inputCheckedClass", "o-radio__input--checked", null, isChecked]
    );
    const labelClasses = defineClasses(["labelClass", "o-radio__label"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        ref: "label",
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "radio",
        role: "radio",
        "aria-checked": isChecked.value,
        onClick: _cache[5] || (_cache[5] = withModifiers(
          //@ts-ignore
          (...args) => unref(setFocus) && unref(setFocus)(...args),
          ["stop"]
        )),
        onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(
          //@ts-ignore
          (...args) => unref(setFocus) && unref(setFocus)(...args),
          ["prevent"]
        ), ["enter"]))
      }, [
        withDirectives(createBaseVNode("input", mergeProps(_ctx.$attrs, {
          ref_key: "inputRef",
          ref: inputRef,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(vmodel) ? vmodel.value = $event : null),
          type: "radio",
          "data-oruga-input": "radio",
          class: unref(inputClasses),
          disabled: __props.disabled,
          required: __props.required,
          name: __props.name,
          autocomplete: __props.autocomplete,
          value: __props.nativeValue,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          onBlur: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput
        }), null, 16, _hoisted_210), [
          [vModelRadio, unref(vmodel)]
        ]),
        __props.label || _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(unref(labelClasses))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 2)) : createCommentVNode("", true)
      ], 42, _hoisted_115);
    };
  }
});
var index17 = {
  install(app) {
    registerComponent(app, _sfc_main21);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/select.mjs
var index18 = {
  install(app) {
    registerComponent(app, _sfc_main10);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/skeleton.mjs
var _sfc_main22 = defineComponent({
  ...{
    isOruga: true,
    name: "OSkeleton",
    configField: "skeleton"
  },
  __name: "Skeleton",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Show or hide loader	 */
    active: { type: Boolean, default: true },
    /** Show a loading animation */
    animated: {
      type: Boolean,
      default: () => getOption("skeleton.animated", true)
    },
    /** Custom width */
    width: { type: [Number, String], default: void 0 },
    /** Custom height */
    height: { type: [Number, String], default: void 0 },
    /** Show a circle shape */
    circle: { type: Boolean, default: false },
    /** Enable rounded style */
    rounded: {
      type: Boolean,
      default: () => getOption("skeleton.rounded", true)
    },
    /** Number of shapes to display */
    count: { type: Number, default: 1 },
    /**
     * Size of skeleton
     * @values small, medium, large
     */
    size: { type: String, default: void 0 },
    /**
     * Skeleton position in relation to the element
     * @values left, centered, right
     */
    position: {
      type: String,
      default: "left",
      validator: (value) => ["left", "centered", "right"].indexOf(value) > -1
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton animation */
    animationClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton item rounded */
    itemRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const itemStyle = computed(() => ({
      height: toCssDimension(props.height),
      width: toCssDimension(props.width),
      borderRadius: props.circle ? "50%" : null
    }));
    const rootClasses = defineClasses(
      ["rootClass", "o-sklt"],
      [
        "positionClass",
        "o-sklt--",
        computed(() => props.position),
        computed(() => !!props.position)
      ]
    );
    const itemClasses = defineClasses(
      ["itemClass", "o-sklt__item"],
      [
        "itemRoundedClass",
        "o-sklt__item--rounded",
        null,
        computed(() => props.rounded)
      ],
      [
        "animationClass",
        "o-sklt__item--animated",
        null,
        computed(() => props.animated)
      ],
      [
        "sizeClass",
        "o-sklt__item--",
        computed(() => props.size),
        computed(() => !!props.size)
      ]
    );
    return (_ctx, _cache) => {
      return __props.active ? (openBlock(), createElementBlock("div", {
        key: 0,
        "data-oruga": "skeleton",
        class: normalizeClass(unref(rootClasses))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.count, (i) => {
          return openBlock(), createElementBlock("div", {
            key: i,
            class: normalizeClass(unref(itemClasses)),
            style: normalizeStyle(itemStyle.value)
          }, null, 6);
        }), 128))
      ], 2)) : createCommentVNode("", true);
    };
  }
});
var index19 = {
  install(app) {
    registerComponent(app, _sfc_main22);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/sidebar.mjs
var _sfc_main23 = defineComponent({
  ...{
    isOruga: true,
    name: "OSidebar",
    configField: "sidebar",
    inheritAttrs: false
  },
  __name: "Sidebar",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether siedbar is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: false },
    /**
     * Color of the sidebar
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("sidebar.variant")
    },
    /** Show an overlay like modal */
    overlay: { type: Boolean, default: getOption("sidebar.overlay", false) },
    /** Display the Sidebear inline */
    inline: { type: Boolean, default: false },
    /**
     * Sidebar position
     * @values top, right, bottom, left
     */
    position: {
      type: String,
      default: () => getOption("sidebar.position", "left")
    },
    /** Show sidebar in fullheight */
    fullheight: {
      type: Boolean,
      default: getOption("sidebar.fullheight", false)
    },
    /** Show sidebar in fullwidth */
    fullwidth: {
      type: Boolean,
      default: getOption("sidebar.fullwidth", false)
    },
    /** Show a small sidebar */
    reduce: { type: Boolean, default: getOption("sidebar.reduce", false) },
    /**
     * Custom layout on mobile
     * @values fullwidth, reduced, hidden
     */
    mobile: {
      type: String,
      default: getOption("sidebar.mobile"),
      validator: (value) => ["fullwidth", "reduced", "hidden"].indexOf(value) >= 0
    },
    /** Expand sidebar on hover when reduced or mobile is reduce */
    expandOnHover: {
      type: Boolean,
      default: getOption("sidebar.expandOnHover", false)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => getOption("sidebar.animation")
    },
    /**
     * Is Sidebar cancleable by pressing escape or clicking outside.
     * @values escape, outside, true, false
     */
    cancelable: {
      type: [Array, Boolean],
      default: () => getOption("sidebar.cancelable", ["escape", "outside"])
    },
    /** Callback function to call after user canceled (pressed escape / clicked outside) */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled) */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Use `clip` to remove the body scrollbar, `keep` to have a non scrollable scrollbar to avoid shifting background,
     * but will set body to position fixed, might break some layouts.
     * @values keep, clip
     */
    scroll: {
      type: String,
      default: () => getOption("sidebar.scroll", "clip"),
      validator: (value) => ["clip", "keep"].indexOf(value) >= 0
    },
    /** Destroy sidebar on hide */
    destroyOnHide: {
      type: Boolean,
      default: () => getOption("sidebar.destroyOnHide", false)
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("sidebar.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("sidebar.teleport", false)
    },
    /**
     * Component to be injected, used to open a component sidebar programmatically.
     * Close sidebar within the component by emitting a 'close' event  emits('close')
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component. */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component. */
    events: { type: Object, default: () => ({}) },
    /** DOM element where the sidebar component will be created on (for programmatic usage). */
    container: {
      type: [Object, String],
      default: () => getOption("sidebar.container", "body")
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar component when its active */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar when teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when is fullheight */
    fullheightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when is fullwidth */
    fullwidthClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when its inlined */
    inlineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when reduced */
    reduceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when expanded on hover */
    expandOnHoverClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the body when sidebar clipped */
    crollClipClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the body when sidebar is not clipped */
    noScrollClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content when sidebar is hidden */
    hiddenClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content when sidebar is visible */
    visibleClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = ref();
    const sidebarContent = ref();
    const { isActive, close, cancel } = useProgrammaticComponent(
      rootRef,
      props,
      emits,
      {
        destroyOnHide: props.destroyOnHide,
        cancelOptions: getOption("sidebar.cancelable", ["escape", "outside"])
      }
    );
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const savedScrollTop = ref(null);
    const isAnimating = ref(!props.active);
    watch(isActive, (value) => {
      if (props.overlay)
        handleScroll();
      if (value)
        addHandler();
      else
        removeHandler();
    });
    const _teleport = computed(
      () => typeof props.teleport === "boolean" ? { to: "body", disabled: !props.teleport } : { to: props.teleport, disabled: false }
    );
    const transitionName = computed(() => {
      if (props.animation)
        return props.animation;
      const vertical = props.position === "top" || props.position === "bottom";
      const right = props.position === "right";
      const open = right ? !isActive.value : isActive.value;
      return open ? vertical ? "slide-down" : "slide-next" : vertical ? "slide-up" : "slide-prev";
    });
    const hideOnMobile = computed(
      () => props.mobile === "hidden" && isMobile.value
    );
    onMounted(() => {
      if (props.active)
        addHandler();
    });
    onBeforeUnmount(() => {
      removeHandler();
      if (isClient) {
        if (props.overlay) {
          const scrollto = savedScrollTop.value ? savedScrollTop.value : document.documentElement.scrollTop;
          if (scrollClass.value) {
            document.body.classList.remove(...scrollClass.value);
            document.documentElement.classList.remove(...scrollClass.value);
          }
          document.documentElement.scrollTop = scrollto;
          document.body.style.top = null;
        }
      }
    });
    let removeOutsideListener = null;
    function addHandler() {
      if (isClient && !props.overlay) {
        removeOutsideListener = useClickOutside(sidebarContent, clickedOutside);
      }
    }
    function removeHandler() {
      if (removeOutsideListener !== null)
        removeOutsideListener();
    }
    function clickedOutside(event) {
      if (props.inline || !isActive.value || isAnimating.value)
        return;
      if (props.overlay || !event.composedPath().includes(sidebarContent.value))
        event.preventDefault();
      cancel("outside");
    }
    function handleScroll() {
      var _a;
      if (!isClient)
        return;
      if (props.scroll === "clip") {
        if ((_a = scrollClass.value) == null ? void 0 : _a.length) {
          if (isActive.value) {
            document.documentElement.classList.add(...scrollClass.value);
          } else {
            document.documentElement.classList.remove(...scrollClass.value);
          }
        }
        return;
      }
      savedScrollTop.value = savedScrollTop.value ? savedScrollTop.value : document.documentElement.scrollTop;
      if (scrollClass.value) {
        if (isActive.value)
          document.body.classList.add(...scrollClass.value);
        else
          document.body.classList.remove(...scrollClass.value);
      }
      if (isActive.value) {
        document.body.style.top = `-${savedScrollTop.value}px`;
        return;
      }
      document.documentElement.scrollTop = savedScrollTop.value;
      document.body.style.top = null;
      savedScrollTop.value = null;
    }
    function afterEnter() {
      isAnimating.value = false;
    }
    function beforeLeave() {
      isAnimating.value = true;
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-side"],
      ["mobileClass", "o-side--mobile", null, isMobile],
      ["activeClass", "o-side--active", null, isActive],
      [
        "teleportClass",
        "o-side--teleport",
        null,
        computed(() => !!props.teleport)
      ],
      ["inlineClass", "o-side--inline", null, computed(() => props.inline)]
    );
    const overlayClasses = defineClasses(["overlayClass", "o-side__overlay"]);
    const contentClasses = defineClasses(
      ["contentClass", "o-side__content"],
      [
        "variantClass",
        "o-side__content--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "positionClass",
        "o-side__content--",
        computed(() => props.position),
        computed(() => !!props.position)
      ],
      [
        "fullheightClass",
        "o-side__content--fullheight",
        null,
        computed(() => props.fullheight)
      ],
      [
        "fullwidthClass",
        "o-side__content--fullwidth",
        null,
        computed(
          () => props.fullwidth || props.mobile === "fullwidth" && isMobile.value
        )
      ],
      [
        "reduceClass",
        "o-side__content--reduced",
        null,
        computed(
          () => props.reduce || props.mobile === "reduced" && isMobile.value
        )
      ],
      [
        "expandOnHoverClass",
        "o-side__content--reduced-expand",
        null,
        computed(
          () => props.expandOnHover && (!isMobile.value || props.mobile !== "fullwidth")
        )
      ],
      ["visibleClass", "o-side__content--visible", null, isActive],
      [
        "hiddenClass",
        "o-side__content--hidden",
        null,
        computed(() => !isActive.value)
      ]
    );
    const scrollClasses = defineClasses(["scrollClipClass", "o-clipped"]);
    const noScrollClasses = defineClasses(["noScrollClass", "o-noscroll"]);
    const scrollClass = computed(
      () => getActiveClasses(
        props.scroll === "clip" ? scrollClasses.value : noScrollClasses.value
      )
    );
    scrollClass.value;
    __expose({ close, promise: props.promise });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: _teleport.value.to,
        disabled: _teleport.value.disabled
      }, [
        withDirectives(createBaseVNode("div", mergeProps({
          ref_key: "rootRef",
          ref: rootRef
        }, _ctx.$attrs, {
          class: unref(rootClasses),
          "data-oruga": "sidebar"
        }), [
          __props.overlay && unref(isActive) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(overlayClasses)),
            tabindex: -1,
            "aria-hidden": "true",
            onClick: _cache[0] || (_cache[0] = (evt) => clickedOutside(evt))
          }, null, 2)) : createCommentVNode("", true),
          createVNode(Transition, {
            name: transitionName.value,
            onAfterEnter: afterEnter,
            onBeforeLeave: beforeLeave
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("div", {
                ref_key: "sidebarContent",
                ref: sidebarContent,
                class: normalizeClass(unref(contentClasses))
              }, [
                renderSlot(_ctx.$slots, "default", { close: unref(close) }, () => [
                  __props.component ? (openBlock(), createBlock(resolveDynamicComponent(__props.component), mergeProps({ key: 0 }, _ctx.$props.props, toHandlers(_ctx.$props.events), { onClose: unref(close) }), null, 16, ["onClose"])) : createCommentVNode("", true)
                ])
              ], 2), [
                [vShow, unref(isActive)]
              ])
            ]),
            _: 3
          }, 8, ["name"])
        ], 16), [
          [vShow, !hideOnMobile.value]
        ])
      ], 8, ["to", "disabled"]);
    };
  }
});
var instances4 = new InstanceRegistry();
var SidebarProgrammatic = {
  open(params) {
    const defaultParams = {
      programmatic: { instances: instances4 },
      active: true
      // set the active state to true
    };
    const propsData = merge(defaultParams, params);
    propsData.promise = new Promise((p1, p2) => {
      propsData.programmatic.resolve = p1;
      propsData.programmatic.reject = p2;
    });
    const app = VueInstance;
    const vnode = createVNode(_sfc_main23, propsData);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.exposed;
  },
  closeAll(...args) {
    instances4.walk((entry) => entry.exposed.close(...args));
  }
};
var SidebarProgrammatic$1 = SidebarProgrammatic;
var index20 = {
  install(app) {
    registerComponent(app, _sfc_main23);
    registerComponentProgrammatic(app, "sidebar", SidebarProgrammatic$1);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Tooltip.vue_vue_type_script_setup_true_lang-C1GHI2GD.mjs
var _sfc_main24 = defineComponent({
  ...{
    isOruga: true,
    name: "OTooltip",
    configField: "tooltip"
  },
  __name: "Tooltip",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether tooltip is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: false },
    /** Tooltip text, unnecessary when content slot is used */
    label: { type: String, default: void 0 },
    /**
     * Color of the tooltip
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("tooltip.variant")
    },
    /**
     * Position of the Tooltip relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      default: () => getOption("tooltip.position", "auto"),
      validator: (value) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(value) > -1
    },
    /** Tooltip will be always active */
    always: { type: Boolean, default: false },
    /** Tooltip will be disabled */
    disabled: { type: Boolean, default: false },
    /** Tooltip default animation */
    animation: {
      type: String,
      default: () => getOption("tooltip.animation", "fade")
    },
    /** Tooltip will be multilined */
    multiline: { type: Boolean, default: false },
    /** Tooltip trigger tag name */
    triggerTag: {
      type: [String, Object, Function],
      default: () => getOption("tooltip.triggerTag", "div")
    },
    /**
     * Tooltip trigger events
     * @values hover, click, focus, contextmenu
     */
    triggers: {
      type: Array,
      default: () => getOption("tooltip.triggers", ["hover"]),
      validator: (values) => values.filter(
        (value) => ["click", "hover", "contextmenu", "focus"].indexOf(value) > -1
      ).length === values.length
    },
    /** Tooltip delay before it appears (number in ms) */
    delay: { type: Number, default: void 0 },
    /**
     * Tooltip auto close options (pressing escape, clicking the content or outside)
     * @values true, false, content, outside, escape
     */
    closeable: {
      type: [Array, Boolean],
      default: () => getOption("tooltip.closeable", ["escape", "outside", "content"])
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("dropdown.teleport", false)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the dropdown is teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip content when is multiline */
    multilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger when is always visible */
    alwaysClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip arrow */
    arrowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip arrow position */
    arrowPositionClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close", "open"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isActive = usePropBinding("active", props, emits, {
      passive: true
    });
    watch(isActive, (value) => {
      if (value)
        emits("open");
      else
        emits("close");
    });
    const timer = ref();
    const autoPosition = ref(props.position);
    watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const contentRef = ref();
    const triggerRef = ref();
    const eventCleanups = ref([]);
    watch(isActive, (value) => {
      if (value && isClient) {
        setTimeout(() => {
          if (cancelOptions.value.indexOf("outside") >= 0) {
            eventCleanups.value.push(
              useClickOutside(contentRef, onClickedOutside, [triggerRef])
            );
          }
          if (cancelOptions.value.indexOf("escape") >= 0) {
            eventCleanups.value.push(
              useEventListener("keyup", onKeyPress, document, {
                immediate: true
              })
            );
          }
        });
      } else if (!value) {
        eventCleanups.value.forEach((fn) => fn());
        eventCleanups.value.length = 0;
      }
    });
    const cancelOptions = computed(
      () => typeof props.closeable === "boolean" ? props.closeable ? ["escape", "outside", "content"] : [] : props.closeable
    );
    function onClickedOutside() {
      if (!isActive.value || props.always)
        return;
      if (cancelOptions.value.indexOf("outside") < 0)
        return;
      isActive.value = false;
    }
    function onKeyPress(event) {
      if (isActive.value && (event.key === "Escape" || event.key === "Esc")) {
        if (cancelOptions.value.indexOf("escape") < 0)
          return;
        isActive.value = false;
      }
    }
    function onClick() {
      if (props.triggers.indexOf("click") < 0)
        return;
      nextTick(() => setTimeout(() => open()));
    }
    function onContextMenu(event) {
      if (props.triggers.indexOf("contextmenu") < 0)
        return;
      event.preventDefault();
      open();
    }
    function onFocus() {
      if (props.triggers.indexOf("focus") < 0)
        return;
      open();
    }
    function onHover() {
      if (props.triggers.indexOf("hover") < 0)
        return;
      open();
    }
    function open() {
      if (props.disabled)
        return;
      if (props.delay) {
        timer.value = setTimeout(() => {
          isActive.value = true;
          timer.value = null;
        }, props.delay);
      } else {
        isActive.value = true;
      }
    }
    function onClose() {
      if (cancelOptions.value.indexOf("content") < 0)
        return;
      isActive.value = !props.closeable;
      if (timer.value && props.closeable)
        clearTimeout(timer.value);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-tip"],
      [
        "teleportClass",
        "o-tip--teleport",
        null,
        computed(() => !!props.teleport)
      ]
    );
    const triggerClasses = defineClasses(["triggerClass", "o-tip__trigger"]);
    const arrowClasses = defineClasses(
      ["arrowClass", "o-tip__arrow"],
      [
        "arrowPositionClass",
        "o-tip__arrow--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "variantArrowClass",
        "o-tip__arrow--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    const contentClasses = defineClasses(
      ["contentClass", "o-tip__content"],
      [
        "positionClass",
        "o-tip__content--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "variantClass",
        "o-tip__content--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "multilineClass",
        "o-tip__content--multiline",
        null,
        computed(() => props.multiline)
      ],
      [
        "alwaysClass",
        "o-tip__content--always",
        null,
        computed(() => props.always)
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "tooltip"
      }, [
        createVNode(_sfc_main3, {
          position: autoPosition.value,
          "onUpdate:position": _cache[0] || (_cache[0] = ($event) => autoPosition.value = $event),
          teleport: __props.teleport,
          class: normalizeClass(unref(rootClasses)),
          trigger: triggerRef.value,
          "default-position": "top",
          disabled: !unref(isActive)
        }, {
          default: withCtx(({ setContent }) => [
            createVNode(Transition, { name: __props.animation }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref: (el) => contentRef.value = setContent(el),
                  class: normalizeClass(unref(contentClasses))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(arrowClasses))
                  }, null, 2),
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    createTextVNode(toDisplayString(__props.label), 1)
                  ])
                ], 2), [
                  [vShow, unref(isActive) || __props.always && !__props.disabled]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled"]),
        (openBlock(), createBlock(resolveDynamicComponent(__props.triggerTag), {
          ref_key: "triggerRef",
          ref: triggerRef,
          class: normalizeClass(unref(triggerClasses)),
          "aria-haspopup": "true",
          onClick,
          onContextmenu: onContextMenu,
          onMouseenter: onHover,
          onFocusCapture: onFocus,
          onBlurCapture: onClose,
          onMouseleave: onClose
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { active: unref(isActive) })
          ]),
          _: 3
        }, 40, ["class"]))
      ], 2);
    };
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/slider.mjs
var _hoisted_116 = ["tabindex", "aria-label", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-disabled", "onKeydown"];
var _hoisted_211 = { key: 0 };
var _sfc_main$22 = defineComponent({
  ...{
    isOruga: true,
    name: "OSliderThumb",
    configField: "slider",
    inheritAttrs: false
  },
  __name: "SliderThumb",
  props: {
    /** parent slider component props  */
    sliderProps: { type: Object, required: true },
    modelValue: { type: Number, required: true },
    sliderSize: { type: Function, required: true },
    thumbWrapperClasses: {
      type: Array,
      required: true
    },
    thumbClasses: {
      type: Array,
      required: true
    }
  },
  emits: ["update:modelValue", "change", "dragstart", "dragend"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slider = computed(() => props.sliderProps);
    const isFocused = ref(false);
    const dragging = ref(false);
    const startX = ref(0);
    const startPosition = ref(0);
    const newPosition = ref(null);
    const oldValue = ref(props.modelValue);
    const tooltip = computed(() => slider.value.tooltip);
    const tooltipAlways = computed(() => slider.value.tooltipAlways);
    const disabled = computed(() => slider.value.disabled);
    const max = computed(() => slider.value.max);
    const min = computed(() => slider.value.min);
    const step = computed(() => slider.value.step);
    const indicator = computed(() => slider.value.indicator);
    const ariaLabel = computed(
      () => Array.isArray(slider.value.ariaLabel) ? slider.value.ariaLabel[0] : slider.value.ariaLabel
    );
    const precision = computed(() => {
      const precisions = [min.value, max.value, step.value].map((item) => {
        const decimal = ("" + item).split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max(...precisions);
    });
    const computedTooltipVariant = computed(
      () => slider.value.tooltipVariant ? slider.value.tooltipVariant : slider.value.variant
    );
    const currentPosition = computed(
      () => `${(props.modelValue - min.value) / (max.value - min.value) * 100}%`
    );
    const wrapperStyle = computed(() => ({ left: currentPosition.value }));
    const formattedValue = computed(() => {
      if (typeof slider.value.customFormatter !== "undefined")
        return slider.value.customFormatter(props.modelValue);
      if (slider.value.format === "percent")
        return new Intl.NumberFormat(slider.value.locale, {
          style: "percent"
        }).format((props.modelValue - min.value) / (max.value - min.value));
      return new Intl.NumberFormat(slider.value.locale).format(props.modelValue);
    });
    function onFocus() {
      isFocused.value = true;
    }
    function onBlur() {
      isFocused.value = false;
    }
    function onButtonDown(event) {
      if (disabled.value)
        return;
      event.preventDefault();
      onDragStart(event);
      if (isClient) {
        document.addEventListener("mousemove", onDragging);
        document.addEventListener("touchmove", onDragging);
        document.addEventListener("mouseup", onDragEnd);
        document.addEventListener("touchend", onDragEnd);
        document.addEventListener("contextmenu", onDragEnd);
      }
    }
    function onLeftKeyDown() {
      if (disabled.value || props.modelValue === min.value)
        return;
      newPosition.value = parseFloat(currentPosition.value) - step.value / (max.value - min.value) * 100;
      setPosition(newPosition.value);
      emits("change");
    }
    function onRightKeyDown() {
      if (disabled.value || props.modelValue === max.value)
        return;
      newPosition.value = parseFloat(currentPosition.value) + step.value / (max.value - min.value) * 100;
      setPosition(newPosition.value);
      emits("change");
    }
    function onHomeKeyDown() {
      if (disabled.value || props.modelValue === min.value)
        return;
      newPosition.value = 0;
      setPosition(newPosition.value);
      emits("change");
    }
    function onEndKeyDown() {
      if (disabled.value || props.modelValue === max.value)
        return;
      newPosition.value = 100;
      setPosition(newPosition.value);
      emits("change");
    }
    function onDragStart(event) {
      dragging.value = true;
      emits("dragstart");
      if (event.type === "touchstart")
        event.clientX = event.touches[0].clientX;
      startX.value = event.clientX;
      startPosition.value = parseFloat(currentPosition.value);
      newPosition.value = startPosition.value;
    }
    function onDragging(event) {
      if (dragging.value) {
        if (event.type === "touchmove")
          event.clientX = event.touches[0].clientX;
        const diff = (event.clientX - startX.value) / props.sliderSize() * 100;
        newPosition.value = startPosition.value + diff;
        setPosition(newPosition.value);
      }
    }
    function onDragEnd() {
      dragging.value = false;
      emits("dragend");
      if (props.modelValue !== oldValue.value)
        emits("change");
      setPosition(newPosition.value);
      if (isClient) {
        document.removeEventListener("mousemove", onDragging);
        document.removeEventListener("touchmove", onDragging);
        document.removeEventListener("mouseup", onDragEnd);
        document.removeEventListener("touchend", onDragEnd);
        document.removeEventListener("contextmenu", onDragEnd);
      }
    }
    function setPosition(percent) {
      if (percent === null || isNaN(percent))
        return;
      if (percent < 0)
        percent = 0;
      else if (percent > 100)
        percent = 100;
      const stepLength = 100 / ((max.value - min.value) / step.value);
      const steps = Math.round(percent / stepLength);
      let value = steps * stepLength / 100 * (max.value - min.value) + min.value;
      value = parseFloat(value.toFixed(precision.value));
      emits("update:modelValue", value);
      if (!dragging.value && value !== oldValue.value)
        oldValue.value = value;
    }
    __expose({ setPosition });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(__props.thumbWrapperClasses),
        style: normalizeStyle(wrapperStyle.value),
        "data-oruga": "slider-thumb"
      }, [
        createVNode(_sfc_main24, {
          label: formattedValue.value,
          variant: computedTooltipVariant.value,
          disabled: disabled.value || !tooltip.value,
          always: tooltipAlways.value || dragging.value || isFocused.value
        }, {
          default: withCtx(() => [
            createBaseVNode("div", mergeProps(_ctx.$attrs, {
              class: __props.thumbClasses,
              tabindex: disabled.value ? null : 0,
              role: "slider",
              "aria-label": ariaLabel.value,
              "aria-valuenow": __props.modelValue,
              "aria-valuemin": min.value,
              "aria-valuemax": max.value,
              "aria-disabled": disabled.value,
              "aria-orientation": "horizontal",
              onMousedown: onButtonDown,
              onTouchstart: onButtonDown,
              onFocus,
              onBlur,
              onKeydown: [
                withKeys(withModifiers(onLeftKeyDown, ["prevent"]), ["left"]),
                withKeys(withModifiers(onRightKeyDown, ["prevent"]), ["right"]),
                withKeys(withModifiers(onLeftKeyDown, ["prevent"]), ["down"]),
                withKeys(withModifiers(onRightKeyDown, ["prevent"]), ["up"]),
                withKeys(withModifiers(onHomeKeyDown, ["prevent"]), ["home"]),
                withKeys(withModifiers(onEndKeyDown, ["prevent"]), ["end"])
              ]
            }), [
              indicator.value ? (openBlock(), createElementBlock("span", _hoisted_211, toDisplayString(formattedValue.value), 1)) : createCommentVNode("", true)
            ], 16, _hoisted_116)
          ]),
          _: 1
        }, 8, ["label", "variant", "disabled", "always"])
      ], 6);
    };
  }
});
var _sfc_main$17 = defineComponent({
  ...{
    isOruga: true,
    name: "OSliderTick",
    configField: "slider"
  },
  __name: "SliderTick",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Value of single tick */
    value: { type: Number, required: true },
    /** Tick label */
    label: { type: String, default: void 0 },
    tickClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class when slider tick is hidden */
    tickHiddenClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class of tick label */
    tickLabelClass: {
      type: [String, Function, Array],
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const { parent } = useProviderChild();
    const position = computed(() => {
      const pos = (props.value - parent.value.min) / (parent.value.max - parent.value.min) * 100;
      return pos >= 0 && pos <= 100 ? pos : 0;
    });
    const hidden = computed(
      () => props.value === parent.value.min || props.value === parent.value.max
    );
    const tickStyle = computed(() => ({ left: position.value + "%" }));
    const rootClasses = defineClasses(
      ["tickClass", "o-slide__tick"],
      ["tickHiddenClass", "o-slide__tick--hidden", null, hidden]
    );
    const tickLabelClasses = defineClasses([
      "tickLabelClass",
      "o-slide__tick-label"
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        style: normalizeStyle(tickStyle.value),
        "data-oruga": "slider-tick"
      }, [
        _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(unref(tickLabelClasses))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 2)) : createCommentVNode("", true)
      ], 6);
    };
  }
});
var _sfc_main25 = defineComponent({
  ...{
    isOruga: true,
    name: "OSlider",
    configField: "slider"
  },
  __name: "Slider",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    /** Minimum value */
    min: { type: Number, default: 0 },
    /** Maximum  value */
    max: { type: Number, default: 100 },
    /** Step interval of ticks */
    step: { type: Number, default: 1 },
    /**
     * Color of the slider
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("slider.variant")
    },
    /**
     * Vertical size of slider
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("slider.size")
    },
    /** Show tick marks */
    ticks: { type: Boolean, default: false },
    /** Show tooltip when thumb is being dragged */
    tooltip: {
      type: Boolean,
      default: () => getOption("slider.tooltip", true)
    },
    /**
     * Color of the tooltip
     * @values primary, info, success, warning, danger, and any other custom color
     */
    tooltipVariant: {
      type: String,
      default: () => getOption("slider.tooltipVariant")
    },
    /** Tooltip displays always */
    tooltipAlways: { type: Boolean, default: false },
    /** Rounded thumb */
    rounded: {
      type: Boolean,
      default: () => getOption("slider.rounded", false)
    },
    /** Slider will be disabled */
    disabled: { type: Boolean, default: false },
    /** Update v-model only when dragging is finished */
    lazy: { type: Boolean, default: false },
    /** Function to format the tooltip label for display */
    customFormatter: { type: Function, default: void 0 },
    /** Increases slider size on focus */
    biggerSliderFocus: { type: Boolean, default: false },
    /** Show indicators */
    indicator: { type: Boolean, default: false },
    /**
     * Define v-model format
     * @values row, percent
     */
    format: {
      type: String,
      default: () => getOption("slider.format", "raw"),
      validator: (value) => ["raw", "percent"].indexOf(value) >= 0
    },
    /** Date format locale */
    locale: {
      type: [String, Array],
      default: () => getOption("locale")
    },
    /** Accessibility aria-label to to be passed to the slider thumb element. */
    ariaLabel: {
      type: [String, Array],
      default: () => getOption("slider.ariaLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the vertical slider size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the slider track */
    trackClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the filled part of the slider */
    fillClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the slider is rounded */
    thumbRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the thumb gets dragged */
    thumbDraggingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when slider is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the thumb wrapper */
    thumbWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the thumb */
    thumbClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the slider variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider tick */
    tickClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class when slider tick is hidden */
    tickHiddenClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class of tick label */
    tickLabelClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class to display on the wrapper element when the slider is dragged */
    thumbWrapperDraggingClass: {
      type: [String, Function, Array],
      default: void 0
    }
  },
  emits: ["update:modelValue", "change", "dragging", "dragstart", "dragend"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    function emitValue(event) {
      const val = isRange.value ? [minValue.value, maxValue.value] : valueStart.value || 0;
      emits(event, val);
    }
    const provideData = computed(() => ({
      max: props.max,
      min: props.min
    }));
    useProviderParent(void 0, { data: provideData });
    const sliderRef = ref();
    const thumbStartRef = ref();
    const thumbEndRef = ref();
    const valueStart = ref(null);
    const valueEnd = ref(null);
    const dragging = ref(false);
    const isRange = ref(false);
    const isThumbReversed = ref();
    const isTrackClickDisabled = ref();
    setValues(props.modelValue);
    watch([valueStart, valueEnd], () => onInternalValueUpdate());
    watch(
      [() => props.min, () => props.max, () => props.modelValue],
      () => setValues(props.modelValue)
    );
    const tickValues = computed(() => {
      if (!props.ticks || props.min > props.max || props.step === 0)
        return [];
      const result = [];
      for (let i = props.min + props.step; i < props.max; i = i + props.step) {
        result.push(i);
      }
      return result;
    });
    const minValue = computed(() => Math.min(valueStart.value, valueEnd.value));
    const maxValue = computed(() => Math.max(valueStart.value, valueEnd.value));
    const barSize = computed(
      () => isRange.value ? `${100 * (maxValue.value - minValue.value) / (props.max - props.min)}%` : `${100 * (valueStart.value - props.min) / (props.max - props.min)}%`
    );
    const barStart = computed(
      () => isRange.value ? `${100 * (minValue.value - props.min) / (props.max - props.min)}%` : "0%"
    );
    const barStyle = computed(() => ({
      width: barSize.value,
      left: barStart.value
    }));
    function setValues(newValue) {
      if (props.min > props.max)
        return;
      if (Array.isArray(newValue)) {
        isRange.value = true;
        const smallValue = typeof newValue[0] !== "number" || isNaN(newValue[0]) ? props.min : Math.min(Math.max(props.min, newValue[0]), props.max);
        const largeValue = typeof newValue[1] !== "number" || isNaN(newValue[1]) ? props.max : Math.max(Math.min(props.max, newValue[1]), props.min);
        valueStart.value = isThumbReversed.value ? largeValue : smallValue;
        valueEnd.value = isThumbReversed.value ? smallValue : largeValue;
      } else {
        isRange.value = false;
        valueStart.value = isNaN(newValue) ? props.min : Math.min(props.max, Math.max(props.min, newValue));
        valueEnd.value = null;
      }
    }
    function onInternalValueUpdate() {
      if (isRange.value)
        isThumbReversed.value = valueStart.value > valueEnd.value;
      if (!props.lazy || !dragging.value)
        emitValue("update:modelValue");
      if (dragging.value)
        emitValue("dragging");
    }
    function sliderSize() {
      return sliderRef.value.getBoundingClientRect().width;
    }
    function onSliderClick(event) {
      if (props.disabled || isTrackClickDisabled.value)
        return;
      const sliderOffsetLeft = sliderRef.value.getBoundingClientRect().left;
      const percent = (event.clientX - sliderOffsetLeft) / sliderSize() * 100;
      const targetValue = props.min + percent * (props.max - props.min) / 100;
      const diffFirst = Math.abs(targetValue - valueStart.value);
      if (!isRange.value) {
        if (diffFirst < props.step / 2)
          return;
        thumbStartRef.value.setPosition(percent);
      } else {
        const diffSecond = Math.abs(targetValue - valueEnd.value);
        if (diffFirst <= diffSecond) {
          if (diffFirst < props.step / 2)
            return;
          thumbStartRef.value.setPosition(percent);
        } else {
          if (diffSecond < props.step / 2)
            return;
          thumbEndRef.value.setPosition(percent);
        }
      }
      emitValue("change");
    }
    function onDragStart() {
      dragging.value = true;
      emits("dragstart");
    }
    function onDragEnd() {
      isTrackClickDisabled.value = true;
      setTimeout(() => isTrackClickDisabled.value = false);
      dragging.value = false;
      emits("dragend");
      if (props.lazy)
        emitValue("update:modelValue");
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-slide"],
      [
        "sizeClass",
        "o-slide--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "disabledClass",
        "o-slide--disabled",
        null,
        computed(() => props.disabled)
      ]
    );
    const trackClasses = defineClasses(["trackClass", "o-slide__track"]);
    const fillClasses = defineClasses(
      ["fillClass", "o-slide__fill"],
      [
        "variantClass",
        "o-slide__fill--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    const thumbClasses = defineClasses(
      ["thumbClass", "o-slide__thumb"],
      ["thumbDraggingClass", "o-slide__thumb--dragging", null, dragging],
      [
        "thumbRoundedClass",
        "o-slide__thumb--rounded",
        null,
        computed(() => props.rounded)
      ]
    );
    const thumbWrapperClasses = defineClasses(
      ["thumbWrapperClass", "o-slide__thumb-wrapper"],
      [
        "thumbWrapperDraggingClass",
        "o-slide__thumb-wrapper--dragging",
        null,
        dragging
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "slider",
        onClick: onSliderClick
      }, [
        createBaseVNode("div", {
          ref_key: "sliderRef",
          ref: sliderRef,
          class: normalizeClass(unref(trackClasses))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(unref(fillClasses)),
            style: normalizeStyle(barStyle.value)
          }, null, 6),
          __props.ticks ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(tickValues.value, (val, key) => {
            return openBlock(), createBlock(_sfc_main$17, {
              key,
              value: val,
              "tick-class": __props.tickClass,
              "tick-hidden-class": __props.tickHiddenClass,
              "tick-label-class": __props.tickLabelClass
            }, null, 8, ["value", "tick-class", "tick-hidden-class", "tick-label-class"]);
          }), 128)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default"),
          createVNode(_sfc_main$22, {
            ref_key: "thumbStartRef",
            ref: thumbStartRef,
            modelValue: valueStart.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => valueStart.value = $event),
            "slider-props": props,
            "slider-size": sliderSize,
            "thumb-classes": unref(thumbClasses),
            "thumb-wrapper-classes": unref(thumbWrapperClasses),
            onChange: _cache[1] || (_cache[1] = ($event) => emitValue("change")),
            onDragstart: onDragStart,
            onDragend: onDragEnd
          }, null, 8, ["modelValue", "slider-props", "thumb-classes", "thumb-wrapper-classes"]),
          isRange.value ? (openBlock(), createBlock(_sfc_main$22, {
            key: 1,
            ref_key: "thumbEndRef",
            ref: thumbEndRef,
            modelValue: valueEnd.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => valueEnd.value = $event),
            "slider-props": props,
            "slider-size": sliderSize,
            "thumb-classes": unref(thumbClasses),
            "thumb-wrapper-classes": unref(thumbWrapperClasses),
            onChange: _cache[3] || (_cache[3] = ($event) => emitValue("change")),
            onDragstart: onDragStart,
            onDragend: onDragEnd
          }, null, 8, ["modelValue", "slider-props", "thumb-classes", "thumb-wrapper-classes"])) : createCommentVNode("", true)
        ], 2)
      ], 2);
    };
  }
});
var index21 = {
  install(app) {
    registerComponent(app, _sfc_main25);
    registerComponent(app, _sfc_main$17);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/steps.mjs
var _hoisted_1$14 = ["aria-current"];
var _hoisted_212 = { key: 1 };
var _sfc_main$18 = defineComponent({
  ...{
    isOruga: true,
    name: "OSteps",
    configField: "steps"
  },
  __name: "Steps",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("steps.variant")
    },
    /**
     * Step size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("steps.size")
    },
    /** Show step in vertical layout */
    vertical: { type: Boolean, default: false },
    /**
     * Position of the step
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (value) => ["left", "centered", "right"].indexOf(value) >= 0
    },
    /**
     * Icon pack to use for the navigation
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("steps.iconPack")
    },
    /** Icon to use for navigation button */
    iconPrev: {
      type: String,
      default: () => getOption("steps.iconPrev", "chevron-left")
    },
    /** Icon to use for navigation button */
    iconNext: {
      type: String,
      default: () => getOption("steps.iconNext", "chevron-right")
    },
    /**
     * Next and previous buttons below the component. You can use this property if you want to use your own custom navigation items.
     */
    hasNavigation: { type: Boolean, default: true },
    /** Destroy stepItem on hide */
    destroyOnHide: { type: Boolean, default: false },
    /** Step navigation is animated */
    animated: {
      type: Boolean,
      default: () => getOption("steps.animated", true)
    },
    /**
     * Transition animation name
     * @values [next, prev], [right, left, down, up]
     */
    animation: {
      type: Array,
      default: () => getOption("steps.animation", [
        "slide-next",
        "slide-prev",
        "slide-down",
        "slide-up"
      ]),
      validator: (value) => value.length === 2 || value.length === 4
    },
    /** Apply animation on the initial render */
    animateInitially: {
      type: Boolean,
      default: () => getOption("steps.animateInitially", false)
    },
    /**
     * Position of the marker label
     * @values bottom, right, left
     */
    labelPosition: {
      type: String,
      default: () => getOption("steps.labelPosition", "bottom"),
      validator: (value) => ["bottom", "right", "left"].indexOf(value) > -1
    },
    /** Rounded step markers */
    rounded: { type: Boolean, default: true },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("steps.mobileBreakpoint")
    },
    /** Accessibility next button aria label */
    ariaNextLabel: {
      type: String,
      default: () => getOption("steps.ariaNextLabel")
    },
    /** Accessibility previous button aria label  */
    ariaPreviousLabel: {
      type: String,
      default: () => getOption("steps.ariaPreviousLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Size of the steps */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger */
    verticalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component when is vertical and its position changes */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the steps container */
    stepsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Steps component when animation gets triggered */
    animatedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps markers trigger when are rounded */
    stepMarkerRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component dividers */
    stepDividerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component marker */
    stepMarkerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component content */
    stepContentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component content when transition is happening */
    stepContentTransitioningClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component navigation element */
    stepNavigationClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component link */
    stepLinkClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component link when clickable */
    stepLinkClickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Step component link label */
    stepLinkLabelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Step component link label when positioned */
    stepLinkLabelPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of steps component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "change"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const rootRef = ref();
    const provideData = computed(() => ({
      activeValue: vmodel.value,
      vertical: props.vertical,
      animated: props.animated,
      animation: props.animation,
      animateInitially: props.animateInitially,
      destroyOnHide: props.destroyOnHide
    }));
    const { sortedItems } = useProviderParent(rootRef, {
      data: provideData
    });
    const items = computed(
      () => sortedItems.value.map((column) => ({
        index: column.index,
        identifier: column.identifier,
        ...toValue(column.data)
      }))
    );
    const vmodel = useModel(__props, "modelValue");
    watch(
      () => props.modelValue,
      (value) => {
        if (vmodel.value !== value)
          performAction(value);
      }
    );
    const activeItem = computed(
      () => isDefined(vmodel.value) ? items.value.find((item) => item.value === vmodel.value) || items.value[0] : items.value[0]
    );
    const isTransitioning = computed(
      () => items.value.some((item) => item.isTransitioning)
    );
    const hasPrev = computed(() => !!prevItem.value);
    const hasNext = computed(() => !!nextItem.value);
    const prevItem = computed(() => {
      if (!activeItem.value)
        return null;
      let prevItem2 = null;
      for (let idx = items.value.indexOf(activeItem.value) - 1; idx >= 0; idx--) {
        if (items.value[idx].visible) {
          prevItem2 = items.value[idx];
          break;
        }
      }
      return prevItem2;
    });
    const nextItem = computed(() => {
      let nextItem2 = null;
      let idx = activeItem.value ? items.value.indexOf(activeItem.value) + 1 : 0;
      for (; idx < items.value.length; idx++) {
        if (items.value[idx].visible) {
          nextItem2 = items.value[idx];
          break;
        }
      }
      return nextItem2;
    });
    function isItemClickable(item) {
      var _a;
      if (item.clickable === void 0)
        return item.index < ((_a = activeItem.value) == null ? void 0 : _a.index);
      return item.clickable;
    }
    function prev() {
      if (hasPrev.value)
        itemClick(prevItem.value);
    }
    function next() {
      if (hasNext.value)
        itemClick(nextItem.value);
    }
    function itemClick(item) {
      if (vmodel.value !== item.value)
        performAction(item.value);
    }
    function performAction(newId) {
      const oldId = activeItem.value.value;
      const oldItem = activeItem.value;
      const newItem = items.value.find((item) => item.value === newId) || items.value[0];
      if (oldItem && newItem) {
        oldItem.deactivate(newItem.index);
        newItem.activate(oldItem.index);
      }
      nextTick(() => {
        vmodel.value = newId;
        emits("change", newId, oldId);
      });
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-steps__wrapper"],
      [
        "sizeClass",
        "o-steps--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "verticalClass",
        "o-steps__wrapper-vertical",
        null,
        computed(() => props.vertical)
      ],
      [
        "positionClass",
        "o-steps__wrapper-position-",
        computed(() => props.position),
        computed(() => props.position && props.vertical)
      ],
      ["mobileClass", "o-steps--mobile", null, isMobile]
    );
    const wrapperClasses = defineClasses(
      ["stepsClass", "o-steps"],
      [
        "animatedClass",
        "o-steps--animated",
        null,
        computed(() => props.animated)
      ]
    );
    const stepDividerClasses = defineClasses([
      "stepDividerClass",
      "o-steps__divider"
    ]);
    const stepMarkerClasses = defineClasses(
      ["stepMarkerClass", "o-steps__marker"],
      [
        "stepMarkerRoundedClass",
        "o-steps__marker--rounded",
        null,
        computed(() => props.rounded)
      ]
    );
    const stepContentClasses = defineClasses(
      ["stepContentClass", "o-steps__content"],
      [
        "stepContentTransitioningClass",
        "o-steps__content-transitioning",
        null,
        isTransitioning
      ]
    );
    const stepNavigationClasses = defineClasses([
      "stepNavigationClass",
      "o-steps__navigation"
    ]);
    const stepLinkLabelClasses = defineClasses([
      "stepLinkLabelClass",
      "o-steps__title"
    ]);
    function stepLinkClasses(childItem) {
      const classes = defineClasses(
        ["stepLinkClass", "o-steps__link"],
        [
          "stepLinkLabelPositionClass",
          "o-steps__link-label-",
          props.labelPosition,
          !!props.labelPosition
        ],
        [
          "stepLinkClickableClass",
          "o-steps__link-clickable",
          null,
          isItemClickable(childItem)
        ]
      );
      return classes.value;
    }
    function itemClasses(childItem) {
      const classes = defineClasses(
        ["itemHeaderClass", "o-steps__nav-item"],
        [
          "itemHeaderVariantClass",
          "o-steps__nav-item--",
          childItem.variant || props.variant,
          !!childItem.variant || !!props.variant
        ],
        [
          "itemHeaderActiveClass",
          "o-steps__nav-item-active",
          null,
          childItem.value === activeItem.value.value
        ],
        [
          "itemHeaderPreviousClass",
          "o-steps__nav-item-previous",
          null,
          activeItem.value.index > childItem.index
        ]
      );
      const headerClass = { [childItem.headerClass || ""]: true };
      return [headerClass, ...classes.value];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "steps"
      }, [
        createBaseVNode("ol", {
          class: normalizeClass(unref(wrapperClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (childItem, index210) => {
            return withDirectives((openBlock(), createElementBlock("li", {
              key: childItem.value,
              "aria-current": childItem.value === activeItem.value.value ? "step" : void 0,
              class: normalizeClass(itemClasses(childItem))
            }, [
              index210 > 0 ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(unref(stepDividerClasses))
              }, null, 2)) : createCommentVNode("", true),
              (openBlock(), createBlock(resolveDynamicComponent(childItem.tag), {
                role: "button",
                tabindex: isItemClickable(childItem) ? 0 : null,
                class: normalizeClass(stepLinkClasses(childItem)),
                onClick: ($event) => isItemClickable(childItem) && itemClick(childItem),
                onKeydown: withKeys(($event) => isItemClickable(childItem) && itemClick(childItem), ["enter"])
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(stepMarkerClasses))
                  }, [
                    childItem.icon ? (openBlock(), createBlock(_sfc_main, {
                      key: 0,
                      icon: childItem.icon,
                      pack: childItem.iconPack,
                      size: __props.size
                    }, null, 8, ["icon", "pack", "size"])) : childItem.step ? (openBlock(), createElementBlock("span", _hoisted_212, toDisplayString(childItem.step), 1)) : createCommentVNode("", true)
                  ], 2),
                  createBaseVNode("div", {
                    class: normalizeClass(unref(stepLinkLabelClasses))
                  }, toDisplayString(childItem.label), 3)
                ]),
                _: 2
              }, 1064, ["tabindex", "class", "onClick", "onKeydown"]))
            ], 10, _hoisted_1$14)), [
              [vShow, childItem.visible]
            ]);
          }), 128))
        ], 2),
        createBaseVNode("section", {
          class: normalizeClass(unref(stepContentClasses))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2),
        renderSlot(_ctx.$slots, "navigation", {
          previous: { disabled: !hasPrev.value, action: prev },
          next: { disabled: !hasNext.value, action: next }
        }, () => [
          __props.hasNavigation ? (openBlock(), createElementBlock("nav", {
            key: 0,
            class: normalizeClass(unref(stepNavigationClasses))
          }, [
            createVNode(_sfc_main6, {
              role: "button",
              "icon-left": __props.iconPrev,
              "icon-pack": __props.iconPack,
              "icon-both": "",
              disabled: !hasPrev.value,
              "aria-label": __props.ariaPreviousLabel,
              onClick: withModifiers(prev, ["prevent"])
            }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"]),
            createVNode(_sfc_main6, {
              role: "button",
              "icon-left": __props.iconNext,
              "icon-pack": __props.iconPack,
              "icon-both": "",
              disabled: !hasNext.value,
              "aria-label": __props.ariaNextLabel,
              onClick: withModifiers(next, ["prevent"])
            }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"])
          ], 2)) : createCommentVNode("", true)
        ])
      ], 2);
    };
  }
});
var _hoisted_117 = ["data-id", "tabindex", "role"];
var _sfc_main26 = defineComponent({
  ...{
    isOruga: true,
    name: "OStepItem",
    configField: "steps",
    inheritAttrs: false
  },
  __name: "StepItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Item value (it will be used as v-model of wrapper component) */
    value: { type: [String, Number], default: () => uuid() },
    /** Item label */
    label: { type: String, default: void 0 },
    /** Step marker content (when there is no icon) */
    step: { type: [String, Number], default: void 0 },
    /**
     * Default style for the step.
     * This will override parent type.
     * Could be used to set a completed step to "success" for example
     */
    variant: { type: String, default: void 0 },
    /**
     * Item can be used directly to navigate.
     * If undefined, previous steps are clickable while the others are not
     */
    clickable: { type: Boolean, default: void 0 },
    /** Show/hide item */
    visible: { type: Boolean, default: true },
    /** Icon on the left */
    icon: {
      type: String,
      default: () => getOption("steps.icon")
    },
    /** Icon pack */
    iconPack: {
      type: String,
      default: () => getOption("steps.iconPack")
    },
    /** Step item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => getOption("steps.itemTag", "button")
    },
    /** Role attribute to be passed to the div wrapper for better accessibility */
    ariaRole: {
      type: String,
      default: () => getOption("steps.ariaRole", "tab")
    },
    /** Sets a class to the item header */
    headerClass: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the content item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item when active */
    itemHeaderActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item behind the active one */
    itemHeaderPreviousClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item with variant (default value by parent steps component) */
    itemHeaderVariantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["activate", "deactivate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const providedData = computed(() => ({
      ...props,
      $slots: slots,
      isTransitioning: isTransitioning.value,
      activate,
      deactivate
    }));
    const { parent, item } = useProviderChild({
      data: providedData
    });
    const transitionName = ref();
    const isActive = computed(() => isEqual(props.value, parent.value.activeValue));
    const isTransitioning = ref(false);
    const nextAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 2 : 0;
      return parent.value.animation[idx];
    });
    const prevAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 3 : 1;
      return parent.value.animation[idx];
    });
    function activate(oldIndex) {
      transitionName.value = item.value.index < oldIndex ? nextAnimation.value : prevAnimation.value;
      emits("activate");
    }
    function deactivate(newIndex) {
      transitionName.value = newIndex < item.value.index ? nextAnimation.value : prevAnimation.value;
      emits("deactivate");
    }
    function afterEnter() {
      isTransitioning.value = true;
    }
    function beforeLeave() {
      isTransitioning.value = true;
    }
    const elementClasses = defineClasses(["itemClass", "o-steps__item"]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        css: unref(parent).animated,
        name: transitionName.value,
        appear: unref(parent).animateInitially,
        onAfterEnter: afterEnter,
        onBeforeLeave: beforeLeave
      }, {
        default: withCtx(() => [
          !unref(parent).destroyOnHide || isActive.value && __props.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: "rootRef"
          }, _ctx.$attrs, {
            class: unref(elementClasses),
            "data-id": `steps-${unref(item).identifier}`,
            "data-oruga": "steps-item",
            tabindex: isActive.value ? 0 : -1,
            role: __props.ariaRole,
            "aria-roledescription": "item"
          }), [
            renderSlot(_ctx.$slots, "default")
          ], 16, _hoisted_117)), [
            [vShow, isActive.value && __props.visible]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["css", "name", "appear"]);
    };
  }
});
var index22 = {
  install(app) {
    registerComponent(app, _sfc_main$18);
    registerComponent(app, _sfc_main26);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/switch.mjs
var _hoisted_118 = ["aria-checked"];
var _hoisted_213 = ["disabled", "required", "name", "autocomplete", "value", "true-value", "false-value"];
var _sfc_main27 = defineComponent({
  ...{
    isOruga: true,
    name: "OSwitch",
    configField: "switch",
    inheritAttrs: false
  },
  __name: "Switch",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("switch.variant")
    },
    /**
     * Color of the switch when is passive
     * @values primary, info, success, warning, danger, and any other custom color
     */
    passiveVariant: {
      type: String,
      default: () => getOption("switch.passiveVariant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("switch.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Same as native required */
    required: { type: Boolean, default: false },
    /** Name attribute on native checkbox */
    name: { type: String, default: void 0 },
    /** Overrides the returned value when it's checked */
    trueValue: { type: [String, Number, Boolean], default: true },
    /** Overrides the returned value when it's not checked */
    falseValue: { type: [String, Number, Boolean], default: false },
    /** Rounded style */
    rounded: { type: Boolean, default: true },
    /** Label position */
    position: { type: String, default: "right" },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("switch.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when switch is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the outer switch check */
    switchClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the outer switch check when checked */
    switchCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the inner switch check */
    switchCheckClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch passive variant */
    passiveVariantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of switch label position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Root class of the native input checkbox */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "focus", "blur", "invalid"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const inputRef = ref();
    const { onBlur, onFocus, onInvalid, setFocus } = useInputHandler(
      inputRef,
      emits,
      props
    );
    const vmodel = useVModelBinding(props, emits, {
      passive: true
    });
    const isChecked = computed(
      () => vmodel.value === props.trueValue || Array.isArray(vmodel.value) && vmodel.value.includes(props.nativeValue)
    );
    function onInput(event) {
      emits("input", vmodel.value, event);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-switch"],
      [
        "sizeClass",
        "o-switch--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "disabledClass",
        "o-switch--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "variantClass",
        "o-switch--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "positionClass",
        "o-switch--",
        computed(() => props.position),
        computed(() => !!props.position)
      ],
      [
        "passiveVariantClass",
        "o-switch--",
        computed(() => props.passiveVariant + "-passive"),
        computed(() => !!props.passiveVariant)
      ]
    );
    const inputClasses = defineClasses(
      ["inputClass", "o-switch__input"],
      ["inputCheckedClass", "o-switch__input--checked", null, isChecked]
    );
    const switchClasses = defineClasses(
      ["switchClass", "o-switch__check"],
      ["switchCheckedClass", "o-switch__check--checked", null, isChecked],
      ["roundedClass", "o-switch--rounded", null, computed(() => props.rounded)]
    );
    const switchCheckClasses = defineClasses(
      ["switchCheckClass", "o-switch__check-switch"],
      ["roundedClass", "o-switch--rounded", null, computed(() => props.rounded)]
    );
    const labelClasses = defineClasses(["labelClass", "o-switch__label"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        ref: "label",
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "switch",
        role: "switch",
        "aria-checked": isChecked.value,
        onClick: _cache[5] || (_cache[5] = //@ts-ignore
        (...args) => unref(setFocus) && unref(setFocus)(...args)),
        onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers(
          //@ts-ignore
          (...args) => unref(setFocus) && unref(setFocus)(...args),
          ["prevent"]
        ), ["enter"]))
      }, [
        withDirectives(createBaseVNode("input", mergeProps(_ctx.$attrs, {
          ref_key: "inputRef",
          ref: inputRef,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(vmodel) ? vmodel.value = $event : null),
          type: "checkbox",
          role: "switch",
          "data-oruga-input": "switch",
          class: unref(inputClasses),
          disabled: __props.disabled,
          required: __props.required,
          name: __props.name,
          autocomplete: __props.autocomplete,
          value: __props.nativeValue,
          "true-value": __props.trueValue,
          "false-value": __props.falseValue,
          onClick: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          onBlur: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput
        }), null, 16, _hoisted_213), [
          [vModelCheckbox, unref(vmodel)]
        ]),
        createBaseVNode("span", {
          class: normalizeClass(unref(switchClasses))
        }, [
          createBaseVNode("span", {
            class: normalizeClass(unref(switchCheckClasses))
          }, null, 2)
        ], 2),
        __props.label || _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(unref(labelClasses))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 2)) : createCommentVNode("", true)
      ], 42, _hoisted_118);
    };
  }
});
var index23 = {
  install(app) {
    registerComponent(app, _sfc_main27);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/SlotComponent-DVvAAvO3.mjs
var OSlotComponent = defineComponent({
  name: "OSlotComponent",
  props: {
    /** Component to be get the slot from */
    component: { type: Object, required: true },
    /** Slot name */
    name: { type: String, default: "default" },
    /** Props passed to the slot */
    props: { type: Object, default: () => {
    } },
    /** Tag name of the slot wrapper element */
    tag: {
      type: [String, Object, Function],
      default: "div"
    }
  },
  render() {
    const slot = this.component.$slots[this.name] ? this.component.$slots[this.name](this.props) : {};
    return h(this.tag, {}, slot);
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/table.mjs
var _hoisted_1$22 = ["value"];
var _sfc_main$32 = defineComponent({
  ...{
    isOruga: true,
    name: "OTableMobileSort",
    configField: "table"
  },
  __name: "TableMobileSort",
  props: {
    currentSortColumn: {
      type: Object,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    placeholder: { type: String, default: void 0 },
    iconPack: { type: String, default: void 0 },
    sortIcon: { type: String, default: "arrow-up" },
    sortIconSize: { type: String, default: "small" },
    isAsc: { type: Boolean, default: false },
    mobileSortClasses: { type: Array, required: true }
  },
  emits: ["sort"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const mobileSort = ref(
      getValueByPath(props.currentSortColumn, "identifier")
    );
    const showPlaceholder = computed(
      () => !props.columns || !props.columns.some(
        (column) => getValueByPath(column, "identifier") === mobileSort.value
      )
    );
    const sortableColumns = computed(
      () => props.columns ? props.columns.filter((c) => c.sortable) : []
    );
    const isCurrentSort = computed(
      () => getValueByPath(props.currentSortColumn, "identifier") === mobileSort.value
    );
    watch(mobileSort, (value) => {
      if (props.currentSortColumn.identifier === value)
        return;
      sort();
    });
    watch(
      () => props.currentSortColumn,
      (column) => {
        mobileSort.value = getValueByPath(column, "identifier");
      }
    );
    function sort(event) {
      const column = sortableColumns.value.filter(
        (c) => getValueByPath(c, "identifier") === mobileSort.value
      )[0];
      emits("sort", column, event);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(__props.mobileSortClasses)
      }, [
        createVNode(_sfc_main15, null, {
          default: withCtx(() => [
            createVNode(_sfc_main10, {
              modelValue: mobileSort.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => mobileSort.value = $event),
              expanded: ""
            }, {
              default: withCtx(() => [
                __props.placeholder ? withDirectives((openBlock(), createElementBlock("option", {
                  key: 0,
                  value: {},
                  selected: "",
                  disabled: "",
                  hidden: ""
                }, toDisplayString(__props.placeholder), 513)), [
                  [vShow, showPlaceholder.value]
                ]) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(sortableColumns.value, (column, index210) => {
                  return openBlock(), createElementBlock("option", {
                    key: index210,
                    value: column.identifier
                  }, toDisplayString(column.label), 9, _hoisted_1$22);
                }), 128))
              ]),
              _: 1
            }, 8, ["modelValue"]),
            createVNode(_sfc_main6, {
              onClick: _cache[1] || (_cache[1] = ($event) => sort($event))
            }, {
              default: withCtx(() => [
                withDirectives(createVNode(_sfc_main, {
                  icon: __props.sortIcon,
                  pack: __props.iconPack,
                  size: __props.sortIconSize,
                  both: "",
                  rotation: !__props.isAsc ? 180 : 0
                }, null, 8, ["icon", "pack", "size", "rotation"]), [
                  [vShow, isCurrentSort.value]
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
var _hoisted_1$15 = ["data-id"];
var _sfc_main$23 = defineComponent({
  ...{
    isOruga: true,
    name: "OTableColumn",
    configField: "table"
  },
  __name: "TableColumn",
  props: {
    /** Define the column label */
    label: { type: String, default: void 0 },
    /** Define an object property key if data is an object */
    field: { type: String, default: void 0 },
    /** Define a column sub heading  */
    subheading: { type: String, default: void 0 },
    /** Add addtional meta information for the column for custom purpose*/
    meta: {
      type: [String, Number, Boolean, Function, Object, Array],
      default: void 0
    },
    /** Column fixed width */
    width: { type: [Number, String], default: void 0 },
    /** Define column value as number */
    numeric: { type: Boolean, default: false },
    /**
     * Position of the column content
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (value) => ["left", "centered", "right"].indexOf(value) > -1
    },
    /** Enable an additional searchbar below the column header */
    searchable: { type: Boolean, default: false },
    /** Enable column sortability */
    sortable: { type: Boolean, default: false },
    /** Define whether the column is visible or not */
    visible: { type: Boolean, default: true },
    /** Define a custom sort function */
    customSort: {
      type: Function,
      default: void 0
    },
    /** Define a custom funtion for the filter search */
    customSearch: {
      type: Function,
      default: void 0
    },
    /** Whether the column is sticky or not */
    sticky: { type: Boolean, default: false },
    /** Make header selectable */
    headerSelectable: { type: Boolean, default: false },
    /**
     * Adds native attributes to th
     * @deprecated will be moved to table component in v0.9
     */
    thAttrs: {
      type: Function,
      default: () => ({})
    },
    /**
     * Adds native attributes to td
     * @deprecated will be moved to table component in v0.9
     */
    tdAttrs: {
      type: Function,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => ({
      width: toCssDimension(props.width)
    }));
    const isHeaderUnselectable = computed(
      () => !props.headerSelectable && props.sortable
    );
    const vm = getCurrentInstance();
    const providedData = computed(() => ({
      ...toRaw(props),
      // TODO: remove toRaw when tdAttrs/thAttrs are moved to table component
      label: props.label,
      field: props.field,
      subheading: props.subheading,
      meta: props.meta,
      width: props.width,
      numeric: props.numeric,
      position: props.position,
      searchable: props.searchable,
      sortable: props.sortable,
      visible: props.visible,
      customSort: props.customSort,
      customSearch: props.customSearch,
      sticky: props.sticky,
      headerSelectable: props.headerSelectable,
      $el: vm.proxy,
      $slots: vm.slots,
      style: style.value,
      isHeaderUnselectable: isHeaderUnselectable.value
    }));
    const { item } = useProviderChild({ data: providedData });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        "data-id": unref(item).identifier,
        "data-oruga": "table-column"
      }, [
        createTextVNode(toDisplayString(__props.label) + " ", 1),
        createCommentVNode("", true)
      ], 8, _hoisted_1$15);
    };
  }
});
var _sfc_main$19 = defineComponent({
  ...{
    isOruga: true,
    name: "OTablePagination",
    configField: "table"
  },
  __name: "TablePagination",
  props: {
    current: { type: Number, default: void 0 },
    paginated: { type: Boolean, default: false },
    rootClass: {
      type: [String, Array, Object],
      default: void 0
    }
  },
  emits: ["update:current", "change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const currentPage = usePropBinding("current", props, emits);
    function pageChanged(page) {
      const newPage = page > 0 ? page : 1;
      currentPage.value = newPage;
      emits("change", newPage);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(__props.rootClass)
      }, [
        createBaseVNode("div", null, [
          renderSlot(_ctx.$slots, "default")
        ]),
        createBaseVNode("div", null, [
          __props.paginated ? (openBlock(), createBlock(_sfc_main20, mergeProps({ key: 0 }, _ctx.$attrs, {
            current: unref(currentPage),
            onChange: pageChanged
          }), null, 16, ["current"])) : createCommentVNode("", true)
        ])
      ], 2);
    };
  }
});
var _hoisted_119 = ["tabindex"];
var _hoisted_214 = { key: 0 };
var _hoisted_33 = { key: 1 };
var _hoisted_42 = ["draggable", "onClick", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"];
var _hoisted_5 = { key: 1 };
var _hoisted_6 = { key: 0 };
var _hoisted_7 = { key: 1 };
var _hoisted_8 = { key: 2 };
var _hoisted_9 = { key: 1 };
var _hoisted_10 = { key: 1 };
var _hoisted_11 = { key: 2 };
var _hoisted_122 = ["draggable", "onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"];
var _hoisted_132 = ["colspan"];
var _hoisted_142 = { key: 0 };
var _hoisted_152 = ["colspan"];
var _hoisted_162 = { key: 2 };
var _hoisted_172 = ["colspan"];
var _sfc_main28 = defineComponent({
  ...{
    isOruga: true,
    name: "OTable",
    configField: "table",
    inheritAttrs: false
  },
  __name: "Table",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Table data */
    data: { type: Array, default: () => [] },
    /** Table columns */
    columns: { type: Array, default: () => [] },
    /** Border to all cells */
    bordered: {
      type: Boolean,
      default: () => getOption("table.bordered", false)
    },
    /** Whether table is striped */
    striped: {
      type: Boolean,
      default: () => getOption("table.striped", false)
    },
    /** Makes the cells narrower */
    narrowed: {
      type: Boolean,
      default: () => getOption("table.narrowed", false)
    },
    /** Rows are highlighted when hovering */
    hoverable: {
      type: Boolean,
      default: () => getOption("table.hoverable", false)
    },
    /** Enable loading state */
    loading: { type: Boolean, default: false },
    /** Allow row details  */
    detailed: { type: Boolean, default: false },
    /** Rows can be checked (multiple) */
    checkable: { type: Boolean, default: false },
    /** Show check/uncheck all checkbox in table header when checkable */
    headerCheckable: { type: Boolean, default: true },
    /**
     * Position of the checkbox when checkable
     * @values left, right
     */
    checkboxPosition: {
      type: String,
      default: () => getOption("table.checkboxPosition", "left"),
      validator: (value) => ["left", "right"].indexOf(value) >= 0
    },
    /**
     * Color of the checkbox when checkable
     * @values primary, info, success, warning, danger, and any other custom color
     */
    checkboxVariant: {
      type: String,
      default: () => getOption("table.checkboxVariant")
    },
    /** Set which row is selected, use v-model:selected to make it two-way binding */
    selected: { type: Object, default: void 0 },
    /** Custom method to verify if a row is selectable, works when is selected. */
    isRowSelectable: { type: Function, default: () => true },
    /** Table can be focused and user can navigate with keyboard arrows (require selected) and rows are highlighted when hovering */
    focusable: { type: Boolean, default: false },
    /** Custom method to verify if row is checked, works when is checkable. Useful for backend pagination */
    customIsChecked: {
      type: Function,
      default: void 0
    },
    /** Custom method to verify if a row is checkable, works when is checkable */
    isRowCheckable: {
      type: Function,
      default: (row) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getOption("table.isRowCheckable", (row2) => true)(row)
      )
    },
    /** Set which rows are checked, use v-model:checkedRows to make it two-way binding */
    checkedRows: { type: Array, default: () => [] },
    /** Rows appears as cards on mobile (collapse rows) */
    mobileCards: {
      type: Boolean,
      default: () => getOption("table.mobileCards", true)
    },
    /** Sets the default sort column and order  e.g. ['first_name', 'desc'] */
    defaultSort: {
      type: [String, Array],
      default: () => getOption("table.defaultSort")
    },
    /**
     * Sets the default sort column direction on the first click
     * @values asc, desc
     */
    defaultSortDirection: {
      type: String,
      default: () => getOption("table.defaultSortDirection", "asc")
    },
    /** Sets the header sorting icon */
    sortIcon: {
      type: String,
      default: () => getOption("table.sortIcon", "arrow-up")
    },
    /**
     * Sets the size of the sorting icon
     * @values small, medium, large
     */
    sortIconSize: {
      type: String,
      default: () => getOption("table.sortIconSize", "small")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("table.iconPack")
    },
    /** Columns won't be sorted with Javascript, use with sort event to sort in your backend */
    backendSorting: {
      type: Boolean,
      default: () => getOption("table.backendSorting", false)
    },
    /** Columns won't be filtered with Javascript, use with searchable prop to the columns to filter in your backend */
    backendFiltering: {
      type: Boolean,
      default: () => getOption("table.backendFiltering", false)
    },
    /** Add a class to row based on the return */
    rowClass: {
      type: Function,
      default: (row, index210) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getOption("table.rowClass", (row2, index222) => "")(row, index210)
      )
    },
    /** Allow pre-defined opened details. Ideal to open details via vue-router. (A unique key is required; check detail-key prop) */
    openedDetailed: { type: Array, default: () => [] },
    /** Controls the visibility of the trigger that toggles the detailed rows. */
    hasDetailedVisible: {
      type: Function,
      default: (row) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        getOption("table.hasDetailedVisible", (row2) => true)(row)
      )
    },
    /** Use a unique key of your data Object when use detailed or opened detailed. (id recommended) */
    detailKey: {
      type: String,
      default: () => getOption("table.detailKey")
    },
    /** Allow chevron icon and column to be visible */
    showDetailIcon: {
      type: Boolean,
      default: () => getOption("table.showDetailIcon", true)
    },
    /** Icon name of detail action */
    detailIcon: {
      type: String,
      default: () => getOption("table.detailIcon", "chevron-right")
    },
    /** Custom style on details */
    customDetailRow: { type: Boolean, default: false },
    /* Transition name to use when toggling row details. */
    detailTransition: {
      type: String,
      default: () => getOption("table.detailTransition", "slide")
    },
    /** Text when nothing is selected */
    mobileSortPlaceholder: {
      type: String,
      default: () => getOption("table.mobileSortPlaceholder")
    },
    /** Use a unique key of your data Object for each row. Useful if your data prop has dynamic indices. (id recommended) */
    customRowKey: {
      type: String,
      default: () => getOption("table.customRowKey")
    },
    /** Allows rows to be draggable */
    draggable: { type: Boolean, default: false },
    /** Allows columns to be draggable */
    draggableColumn: { type: Boolean, default: false },
    /** Add a horizontal scrollbar when table is too wide */
    scrollable: { type: Boolean, default: void 0 },
    /** Show a sticky table header */
    stickyHeader: { type: Boolean, default: false },
    /** Table fixed height */
    height: { type: [Number, String], default: void 0 },
    /** Add a native event to filter */
    filtersEvent: { type: String, default: "" },
    /** Filtering debounce time (in milliseconds) */
    debounceSearch: {
      type: Number,
      default: () => getOption("table.debounceSearch", void 0)
    },
    /** Show header */
    showHeader: {
      type: Boolean,
      default: () => getOption("table.showHeader", true)
    },
    /** Make the checkbox column sticky when checkable */
    stickyCheckbox: { type: Boolean, default: false },
    /** Adds pagination to the table */
    paginated: {
      type: Boolean,
      default: () => getOption("table.paginated", false)
    },
    /** Rows won't be paginated with Javascript, use with page-change event to paginate in your backend */
    backendPagination: { type: Boolean, default: false },
    /** Total number of table data if backend-pagination is enabled */
    total: { type: Number, default: 0 },
    /** Current page of table data (if paginated), use v-model:currentPage to make it two-way binding */
    currentPage: { type: Number, default: 1 },
    /** How many rows per page (if paginated) */
    perPage: {
      type: [Number, String],
      default: () => getOption("table.perPage", 20)
    },
    /**
     * Pagination position (if paginated)
     * @values bottom, top, both
     */
    paginationPosition: {
      type: String,
      default: () => getOption("table.paginationPosition", "bottom"),
      validator: (value) => ["bottom", "top", "both"].indexOf(value) >= 0
    },
    /** Rounded pagination if paginated */
    paginationRounded: {
      type: Boolean,
      default: () => getOption("table.paginationRounded", false)
    },
    /** Size of pagination if paginated */
    paginationSize: {
      type: String,
      default: () => getOption("table.paginationSize", "small")
    },
    /** Enable simple style pagination if paginated */
    paginationSimple: {
      type: Boolean,
      default: () => getOption("table.paginationSimple", false)
    },
    /**
     * Pagination buttons order if paginated
     * @values centered, right, left
     */
    paginationOrder: {
      type: String,
      default: () => getOption("table.paginationOrder"),
      validator: (value) => ["centered", "right", "left"].indexOf(value) >= 0
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => getOption("table.mobileBreakpoint")
    },
    /** Accessibility label for the pagination next page button. */
    ariaNextLabel: {
      type: String,
      default: () => getOption("table.ariaNextLabel")
    },
    /** Accessibility label for the pagination previous page button. */
    ariaPreviousLabel: {
      type: String,
      default: () => getOption("table.ariaPreviousLabel")
    },
    /** Accessibility label for the pagination page button. */
    ariaPageLabel: {
      type: String,
      default: () => getOption("table.ariaPageLabel")
    },
    /** Accessibility label for the pagination current page button. */
    ariaCurrentLabel: {
      type: String,
      default: () => getOption("table.ariaCurrentLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table */
    tableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when it is empty */
    emptyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row detail */
    detailedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when is bordered */
    borderedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when rows are striped */
    stripedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when rows are narrowed */
    narrowedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when is hoverable */
    hoverableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper when header is sticky */
    stickyHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper when its content is scrollable */
    scrollableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row when selected */
    trSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row when checkable and checked */
    trCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element */
    thClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when component is positioned */
    thPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when component is sticky" */
    thStickyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when is checkable */
    thCheckboxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element currently sorted */
    thCurrentSortClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sortable Table `th` element */
    thSortableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element that is unsortable */
    thUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table sort icon in the header */
    thSortIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element of the detail column of triggers */
    thDetailedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` subheading element */
    thSubheadingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element */
    tdClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when component is positioned */
    tdPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when component is sticky */
    tdStickyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when is checkable */
    tdCheckboxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element that contains the chevron to trigger details */
    tdDetailedChevronClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sortable form wrapper on mobile */
    mobileSortClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table pagination wrapper */
    paginationWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:currentPage", "page-change", "update:selected", "select", "check", "check-all", "update:checkedRows", "sort", "filters-change", "filters-event", "update:openedDetailed", "details-open", "details-close", "click", "dblclick", "contextmenu", "mouseenter", "mouseleave", "cell-click", "dragstart", "dragend", "drop", "dragleave", "dragover", "columndragstart", "columndragend", "columndrop", "columndragleave", "columndragover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const isMobileActive = computed(() => props.mobileCards && isMobile.value);
    const rootRef = ref();
    const slotRef = ref();
    const provider = useProviderParent(slotRef);
    const tableColumns = computed(
      () => provider.sortedItems.value.map((column) => ({
        index: column.index,
        identifier: column.identifier,
        ...toValue(column.data),
        thAttrsData: {},
        tdAttrsData: []
      }))
    );
    const tableData = computed(() => {
      var _a;
      if (!((_a = props.data) == null ? void 0 : _a.length))
        return [...props.data];
      return props.data.map(
        (row) => !props.customRowKey && typeof row === "object" ? Object.assign({ __rowKey: uuid() }, row) : row
      );
    });
    const tableRows = ref(tableData.value);
    const dataTotal = ref(
      props.backendPagination ? props.total : tableData.value.length
    );
    const tableCurrentPage = usePropBinding("currentPage", props, emits, {
      passive: true
    });
    watch(
      () => tableData.value,
      (value) => {
        if (!props.backendFiltering)
          tableRows.value = value.filter((row) => isRowFiltered(row));
        else
          tableRows.value = [...value];
        if (!props.backendSorting)
          sort(currentSortColumn.value, true);
        if (!props.backendPagination)
          dataTotal.value = tableRows.value.length;
      },
      { deep: true }
    );
    watch(
      () => props.total,
      (newTotal) => {
        if (!props.backendPagination)
          return;
        dataTotal.value = newTotal;
      }
    );
    const tableWrapperStyle = computed(() => ({
      height: toCssDimension(props.height)
    }));
    const visibleRows = computed(() => {
      if (!props.paginated)
        return tableRows.value;
      const currentPage = tableCurrentPage.value;
      const perPage = Number(props.perPage);
      if (tableRows.value.length <= perPage) {
        return tableRows.value;
      } else {
        const start = (currentPage - 1) * perPage;
        const end = start + perPage;
        return tableRows.value.slice(start, end);
      }
    });
    const visibleColumns = computed(() => {
      if (!tableColumns.value)
        return [];
      return tableColumns.value.filter(
        (column) => column.visible || column.visible === void 0
      );
    });
    watch([visibleRows, visibleColumns], () => {
      if (visibleColumns.value.length && visibleRows.value.length) {
        for (let i = 0; i < visibleColumns.value.length; i++) {
          const col = visibleColumns.value[i];
          col.thAttrsData = typeof col.thAttrs === "function" ? col.thAttrs(col) : {};
          col.tdAttrsData = visibleRows.value.map(
            (data) => typeof col.tdAttrs === "function" ? col.tdAttrs(data, col) : {}
          );
        }
      }
    });
    const columnCount = computed(() => {
      let count = visibleColumns.value.length;
      count += props.checkable ? 1 : 0;
      count += props.detailed && props.showDetailIcon ? 1 : 0;
      return count;
    });
    const hasSearchablenewColumns = computed(
      () => tableColumns.value.some((column) => column.searchable)
    );
    const isScrollable = computed(() => {
      if (props.scrollable)
        return true;
      if (!tableColumns.value)
        return false;
      return tableColumns.value.some((column) => column.sticky);
    });
    const slots = useSlots();
    const hasCustomSubheadings = computed(() => {
      if (slots.subheading)
        return true;
      return tableColumns.value.some((column) => !!column.subheading);
    });
    function hasCustomFooterSlot() {
      if (slots.footer) {
        const footer = slots.footer();
        if (footer.length > 1)
          return true;
        const tag = footer[0]["tag"];
        if (tag !== "th" && tag !== "td")
          return false;
      }
      return true;
    }
    function onArrowPressed(pos, event) {
      if (!visibleRows.value.length)
        return;
      let index210 = visibleRows.value.indexOf(props.selected) + pos;
      index210 = index210 < 0 ? 0 : index210 > visibleRows.value.length - 1 ? visibleRows.value.length - 1 : index210;
      const row = visibleRows.value[index210];
      if (!props.isRowSelectable(row)) {
        let newIndex = null;
        if (pos > 0) {
          for (let i = index210; i < visibleRows.value.length && newIndex === null; i++) {
            if (props.isRowSelectable(visibleRows.value[i]))
              newIndex = i;
          }
        } else {
          for (let i = index210; i >= 0 && newIndex === null; i--) {
            if (props.isRowSelectable(visibleRows.value[i]))
              newIndex = i;
          }
        }
        if (newIndex >= 0) {
          selectRow(visibleRows.value[newIndex], index210, event);
        }
      } else {
        selectRow(row, index210, event);
      }
    }
    function selectRow(row, index210, event) {
      emits("click", row, index210, event);
      if (props.selected === row)
        return;
      if (!props.isRowSelectable(row))
        return;
      emits("select", row, props.selected);
      emits("update:selected", row);
    }
    function isRowSelected(row, selectedRow) {
      return selectedRow ? getRowKey(row) === getRowKey(selectedRow) : false;
    }
    function getRowKey(row) {
      if (props.customRowKey)
        return row[props.customRowKey];
      if (typeof row === "object")
        return row["__rowKey"];
      return row;
    }
    const filters = ref({});
    watch(
      filters.value,
      (value) => {
        if (props.debounceSearch)
          useDebounce(
            () => handleFiltersChange(value),
            props.debounceSearch
          )();
        else
          handleFiltersChange(value);
      },
      { deep: true }
    );
    function onFiltersEvent(event) {
      emits("filters-event", props.filtersEvent, filters.value, event);
    }
    function handleFiltersChange(value) {
      if (props.backendFiltering) {
        emits("filters-change", value);
      } else {
        tableRows.value = props.data.filter((row) => isRowFiltered(row));
        if (!props.backendPagination) {
          dataTotal.value = tableRows.value.length;
        }
        if (!props.backendSorting) {
          if (currentSortColumn.value && Object.keys(currentSortColumn.value).length > 0) {
            doSortSingleColumn(currentSortColumn.value);
          }
        }
      }
    }
    function isRowFiltered(row) {
      for (const key in filters.value) {
        if (!filters.value[key])
          continue;
        const input = filters.value[key];
        const column = tableColumns.value.filter((c) => c.field === key)[0];
        if (typeof (column == null ? void 0 : column.customSearch) === "function") {
          if (!column.customSearch(row, input))
            return false;
        } else {
          const value = getValueByPath(row, key);
          if (value == null)
            return false;
          if (Number.isInteger(value)) {
            if (value !== Number(input))
              return false;
          } else {
            const re = new RegExp(escapeRegExpChars(input), "i");
            if (Array.isArray(value)) {
              const valid = value.some(
                (val) => re.test(removeDiacriticsFromString(val)) || re.test(val)
              );
              if (!valid)
                return false;
            } else {
              if (!re.test(removeDiacriticsFromString(value)) && !re.test(value)) {
                return false;
              }
            }
          }
        }
      }
      return true;
    }
    const currentSortColumn = ref();
    const isAsc = ref(true);
    onMounted(() => nextTick(() => checkSort()));
    const hasSortablenewColumns = computed(
      () => tableColumns.value.some((column) => column.sortable)
    );
    function isColumnSorted(column) {
      var _a;
      return ((_a = currentSortColumn.value) == null ? void 0 : _a.identifier) === column.identifier;
    }
    function checkSort() {
      if (tableColumns.value.length && !currentSortColumn.value) {
        initSort();
      } else if (tableColumns.value.length) {
        if (currentSortColumn.value && Object.keys(currentSortColumn.value).length > 0) {
          for (let i = 0; i < tableColumns.value.length; i++) {
            if (currentSortColumn.value.field === tableColumns.value[i].field) {
              currentSortColumn.value = tableColumns.value[i];
              break;
            }
          }
        }
      }
    }
    function initSort() {
      if (!props.defaultSort)
        return;
      let sortField = "";
      let sortDirection = props.defaultSortDirection;
      if (Array.isArray(props.defaultSort)) {
        sortField = props.defaultSort[0];
        if (props.defaultSort[1]) {
          sortDirection = props.defaultSort[1];
        }
      } else {
        sortField = props.defaultSort;
      }
      const sortColumn = tableColumns.value.filter(
        (column) => column.field === sortField
      )[0];
      if (sortColumn) {
        isAsc.value = sortDirection.toLowerCase() !== "desc";
        sort(sortColumn, true);
      }
    }
    function sort(column, updateDirection = false, event) {
      if (!column || !column.sortable)
        return;
      if (!updateDirection)
        isAsc.value = isColumnSorted(column) ? !isAsc.value : props.defaultSortDirection.toLowerCase() !== "desc";
      if (currentSortColumn.value)
        emits("sort", column, isAsc.value ? "asc" : "desc", event);
      if (!props.backendSorting)
        doSortSingleColumn(column);
      currentSortColumn.value = column;
    }
    function doSortSingleColumn(column) {
      tableRows.value = sortBy(
        tableRows.value,
        column.field,
        column.customSort,
        isAsc.value
      );
    }
    function sortBy(array, key, fn, isAsc2) {
      let sorted = [];
      if (fn && typeof fn === "function") {
        sorted = [...array].sort((a, b) => fn(a, b, isAsc2));
      } else {
        sorted = [...array].sort((a, b) => {
          let newA = getValueByPath(a, key);
          let newB = getValueByPath(b, key);
          if (typeof newA === "boolean" && typeof newB === "boolean") {
            return isAsc2 ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
          }
          if (!newA && newA !== 0)
            return 1;
          if (!newB && newB !== 0)
            return -1;
          if (newA === newB)
            return 0;
          newA = typeof newA === "string" ? newA.toUpperCase() : newA;
          newB = typeof newB === "string" ? newB.toUpperCase() : newB;
          return isAsc2 ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
        });
      }
      return sorted;
    }
    const newCheckedRows = ref([...props.checkedRows]);
    const lastCheckedRowIndex = ref(null);
    watch(
      () => props.checkedRows,
      (rows) => {
        newCheckedRows.value = [...rows];
      },
      { deep: true }
    );
    const isAllChecked = computed(() => {
      const validVisibleData = visibleRows.value.filter(
        (row) => props.isRowCheckable(row)
      );
      if (validVisibleData.length === 0)
        return false;
      const isAllChecked2 = validVisibleData.some(
        (currentVisibleRow) => indexOf(
          newCheckedRows.value,
          currentVisibleRow,
          props.customIsChecked
        ) < 0
      );
      return !isAllChecked2;
    });
    const isAllUncheckable = computed(() => {
      const validVisibleData = visibleRows.value.filter(
        (row) => props.isRowCheckable(row)
      );
      return validVisibleData.length === 0;
    });
    function isRowChecked(row) {
      return indexOf(newCheckedRows.value, row, props.customIsChecked) >= 0;
    }
    function removeCheckedRow(row) {
      const index210 = indexOf(newCheckedRows.value, row, props.customIsChecked);
      if (index210 >= 0)
        newCheckedRows.value.splice(index210, 1);
    }
    function checkAll() {
      const allChecked = isAllChecked.value;
      visibleRows.value.forEach((currentRow) => {
        if (props.isRowCheckable(currentRow))
          removeCheckedRow(currentRow);
        if (!allChecked) {
          if (props.isRowCheckable(currentRow))
            newCheckedRows.value.push(currentRow);
        }
      });
      emits("check", newCheckedRows.value);
      emits("check-all", newCheckedRows.value);
      emits("update:checkedRows", newCheckedRows.value);
    }
    function checkRow(row, index210) {
      if (!props.isRowCheckable(row))
        return;
      lastCheckedRowIndex.value;
      lastCheckedRowIndex.value = index210;
      if (!isRowChecked(row))
        newCheckedRows.value.push(row);
      else
        removeCheckedRow(row);
      emits("check", newCheckedRows.value, row);
      emits("update:checkedRows", newCheckedRows.value);
    }
    const visibleDetailRows = ref(props.openedDetailed);
    const showDetailRowIcon = computed(
      () => props.detailed && props.showDetailIcon
    );
    watch(
      () => props.openedDetailed,
      (expandedRows) => {
        visibleDetailRows.value = expandedRows;
      }
    );
    function toggleDetails(row) {
      const found = isVisibleDetailRow(row);
      if (found) {
        closeDetailRow(row);
        emits("details-close", row);
      } else {
        openDetailRow(row);
        emits("details-open", row);
      }
      emits("update:openedDetailed", visibleDetailRows.value);
    }
    function openDetailRow(row) {
      const index210 = handleDetailKey(row);
      visibleDetailRows.value.push(index210);
    }
    function closeDetailRow(row) {
      const index210 = handleDetailKey(row);
      const i = visibleDetailRows.value.indexOf(index210);
      if (i >= 0)
        visibleDetailRows.value.splice(i, 1);
    }
    function isVisibleDetailRow(row) {
      const index210 = handleDetailKey(row);
      return visibleDetailRows.value.indexOf(index210) >= 0;
    }
    function isActiveDetailRow(row) {
      return props.detailed && !props.customDetailRow && isVisibleDetailRow(row);
    }
    function isActiveCustomDetailRow(row) {
      return props.detailed && props.customDetailRow && isVisibleDetailRow(row);
    }
    function handleDetailKey(row) {
      const key = props.detailKey;
      return !(key == null ? void 0 : key.length) || !row ? row : row[key];
    }
    const isDraggingRow = ref(false);
    const isDraggingColumn = ref(false);
    const canDragRow = computed(() => props.draggable && !isDraggingColumn.value);
    const canDragColumn = computed(
      () => props.draggableColumn && !isDraggingRow.value
    );
    function handleDragStart(row, index210, event) {
      if (!props.draggable)
        return;
      emits("dragstart", row, index210, event);
    }
    function handleDragEnd(row, index210, event) {
      if (!props.draggable)
        return;
      emits("dragend", row, index210, event);
    }
    function handleDrop(row, index210, event) {
      if (!props.draggable)
        return;
      emits("drop", row, index210, event);
    }
    function handleDragOver(row, index210, event) {
      if (!props.draggable)
        return;
      emits("dragover", row, index210, event);
    }
    function handleDragLeave(row, index210, event) {
      if (!props.draggable)
        return;
      emits("dragleave", row, index210, event);
    }
    function handleColumnDragStart(column, index210, event) {
      if (!canDragColumn.value)
        return;
      isDraggingColumn.value = true;
      emits("columndragstart", column, index210, event);
    }
    function handleColumnDragEnd(column, index210, event) {
      if (!canDragColumn.value)
        return;
      isDraggingColumn.value = false;
      emits("columndragend", column, index210, event);
    }
    function handleColumnDrop(column, index210, event) {
      if (!canDragColumn.value)
        return;
      emits("columndrop", column, index210, event);
    }
    function handleColumnDragOver(column, index210, event) {
      if (!canDragColumn.value)
        return;
      emits("columndragover", column, index210, event);
    }
    function handleColumnDragLeave(column, index210, event) {
      if (!canDragColumn.value)
        return;
      emits("columndragleave", column, index210, event);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-table__root"],
      ["mobileClass", "o-table__wrapper--mobile", null, isMobileActive]
    );
    const tableClasses = defineClasses(
      ["tableClass", "o-table"],
      [
        "borderedClass",
        "o-table--bordered",
        null,
        computed(() => props.bordered)
      ],
      ["stripedClass", "o-table--striped", null, computed(() => props.striped)],
      [
        "narrowedClass",
        "o-table--narrowed",
        null,
        computed(() => props.narrowed)
      ],
      [
        "hoverableClass",
        "o-table--hoverable",
        null,
        computed(
          () => (props.hoverable || props.focusable) && !!visibleRows.value.length
        )
      ],
      [
        "emptyClass",
        "o-table--table__empty",
        null,
        computed(() => !visibleRows.value.length)
      ]
    );
    const tableWrapperClasses = defineClasses(
      ["wrapperClass", "o-table__wrapper"],
      [
        "stickyHeaderClass",
        "o-table__wrapper--sticky-header",
        null,
        computed(() => props.stickyHeader)
      ],
      ["scrollableClass", "o-table__wrapper--scrollable", null, isScrollable],
      ["mobileClass", "o-table__wrapper--mobile", null, isMobileActive]
    );
    const footerClasses = defineClasses(["footerClass", "o-table__footer"]);
    const thBaseClasses = defineClasses(["thClass", "o-table__th"]);
    const tdBaseClasses = defineClasses(["tdClass", "o-table__td"]);
    const thCheckboxClasses = defineClasses([
      "thCheckboxClass",
      "o-table__th-checkbox"
    ]);
    const thDetailedClasses = defineClasses([
      "thDetailedClass",
      "o-table__th--detailed"
    ]);
    const thSubheadingClasses = defineClasses(["thSubheadingClass", "o-table__th"]);
    const tdCheckboxClasses = defineClasses(
      ["tdCheckboxClass", "o-table__td-checkbox"],
      [
        "thStickyClass",
        "o-table__th--sticky",
        null,
        computed(() => props.stickyCheckbox)
      ]
    );
    const detailedClasses = defineClasses(["detailedClass", "o-table__detail"]);
    const tdDetailedChevronClasses = defineClasses([
      "tdDetailedChevronClass",
      "o-table__td-chevron"
    ]);
    const mobileSortClasses = defineClasses([
      "mobileSortClass",
      "o-table__mobile-sort"
    ]);
    const paginationWrapperClasses = defineClasses([
      "paginationWrapperClass",
      "o-table__pagination"
    ]);
    const paginationWrapperRootClasses = computed(
      () => getActiveClasses(paginationWrapperClasses.value)
    );
    const thSortIconClasses = defineClasses([
      "thSortIconClass",
      "o-table__th__sort-icon"
    ]);
    function thClasses(column) {
      const classes = defineClasses(
        [
          "thCurrentSortClass",
          "o-table__th-current-sort",
          null,
          isColumnSorted(column)
        ],
        ["thSortableClass", "o-table__th--sortable", null, column.sortable],
        [
          "thUnselectableClass",
          "o-table__th--unselectable",
          null,
          column.isHeaderUnselectable
        ],
        [
          "thPositionClass",
          "o-table__th--",
          column.position,
          !!column.position
        ],
        ["thStickyClass", "o-table__th--sticky", null, column.sticky]
      );
      return [...thBaseClasses.value, ...classes.value];
    }
    function rowClasses(row, index210) {
      const classes = defineClasses(
        [
          "trSelectedClass",
          "o-table__tr--selected",
          null,
          isRowSelected(row, props.selected)
        ],
        ["trCheckedClass", "o-table__tr--checked", null, isRowChecked(row)]
      );
      const rowClass = props.rowClass(row, index210);
      return [...classes.value, { [rowClass]: true }];
    }
    function tdClasses(row, column) {
      const classes = defineClasses(
        [
          "tdPositionClass",
          "o-table__td--",
          column.position,
          !!column.position
        ],
        ["tdStickyClass", "o-table__td--sticky", null, column.sticky]
      );
      return [...tdBaseClasses.value, ...classes.value];
    }
    return (_ctx, _cache) => {
      var _a, _b;
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "table"
      }, [
        createBaseVNode("div", {
          ref_key: "slotRef",
          ref: slotRef,
          style: { "display": "none" }
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => {
            var _a2;
            return [
              ((_a2 = __props.columns) == null ? void 0 : _a2.length) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(__props.columns, (column, idx) => {
                return openBlock(), createBlock(_sfc_main$23, mergeProps({ key: idx }, column), {
                  default: withCtx(({ row }) => [
                    createTextVNode(toDisplayString(column.field ? row[column.field] : row), 1)
                  ]),
                  _: 2
                }, 1040);
              }), 128)) : createCommentVNode("", true)
            ];
          })
        ], 512),
        isMobileActive.value && hasSortablenewColumns.value ? (openBlock(), createBlock(_sfc_main$32, {
          key: 0,
          "current-sort-column": currentSortColumn.value,
          columns: tableColumns.value,
          placeholder: __props.mobileSortPlaceholder,
          "icon-pack": __props.iconPack,
          "sort-icon": __props.sortIcon,
          "sort-icon-size": __props.sortIconSize,
          "is-asc": isAsc.value,
          "mobile-sort-classes": unref(mobileSortClasses),
          onSort: _cache[0] || (_cache[0] = (column, event) => sort(column, null, event))
        }, null, 8, ["current-sort-column", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size", "is-asc", "mobile-sort-classes"])) : createCommentVNode("", true),
        __props.paginated && (__props.paginationPosition === "top" || __props.paginationPosition === "both") ? renderSlot(_ctx.$slots, "pagination", {
          key: 1,
          current: unref(tableCurrentPage),
          perPage: __props.perPage,
          total: dataTotal.value,
          change: (page) => tableCurrentPage.value = page
        }, () => [
          createVNode(_sfc_main$19, mergeProps(_ctx.$attrs, {
            current: unref(tableCurrentPage),
            "onUpdate:current": _cache[1] || (_cache[1] = ($event) => isRef(tableCurrentPage) ? tableCurrentPage.value = $event : null),
            paginated: __props.paginated,
            "per-page": __props.perPage,
            total: dataTotal.value,
            rounded: __props.paginationRounded,
            size: __props.paginationSize,
            order: __props.paginationOrder,
            simple: __props.paginationSimple,
            "icon-pack": __props.iconPack,
            "aria-next-label": __props.ariaNextLabel,
            "aria-previous-label": __props.ariaPreviousLabel,
            "aria-page-label": __props.ariaPageLabel,
            "aria-current-label": __props.ariaCurrentLabel,
            "root-class": paginationWrapperRootClasses.value,
            onChange: _cache[2] || (_cache[2] = (page) => _ctx.$emit("page-change", page))
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "top-left")
            ]),
            _: 3
          }, 16, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(unref(tableWrapperClasses)),
          style: normalizeStyle(tableWrapperStyle.value)
        }, [
          createBaseVNode("table", {
            class: normalizeClass(unref(tableClasses)),
            tabindex: !__props.focusable ? null : 0,
            onKeydown: [
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => onArrowPressed(-1, $event), ["self", "prevent"]), ["up"])),
              _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => onArrowPressed(1, $event), ["self", "prevent"]), ["down"]))
            ]
          }, [
            _ctx.$slots.caption ? (openBlock(), createElementBlock("caption", _hoisted_214, [
              renderSlot(_ctx.$slots, "caption")
            ])) : createCommentVNode("", true),
            tableColumns.value.length && __props.showHeader ? (openBlock(), createElementBlock("thead", _hoisted_33, [
              renderSlot(_ctx.$slots, "preheader"),
              createBaseVNode("tr", null, [
                showDetailRowIcon.value ? (openBlock(), createElementBlock("th", {
                  key: 0,
                  class: normalizeClass([...unref(thBaseClasses), ...unref(thDetailedClasses)])
                }, null, 2)) : createCommentVNode("", true),
                __props.checkable && __props.checkboxPosition === "left" ? (openBlock(), createElementBlock("th", {
                  key: 1,
                  class: normalizeClass([...unref(thBaseClasses), ...unref(thCheckboxClasses)])
                }, [
                  renderSlot(_ctx.$slots, "check-all", {
                    isAllChecked: isAllChecked.value,
                    isAllUncheckable: isAllUncheckable.value,
                    checkAll
                  }, () => [
                    __props.headerCheckable ? (openBlock(), createBlock(_sfc_main8, {
                      key: 0,
                      "model-value": isAllChecked.value,
                      autocomplete: "off",
                      variant: __props.checkboxVariant,
                      disabled: isAllUncheckable.value,
                      "onUpdate:modelValue": checkAll
                    }, null, 8, ["model-value", "variant", "disabled"])) : createCommentVNode("", true)
                  ])
                ], 2)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleColumns.value, (column, index210) => {
                  var _a2;
                  return openBlock(), createElementBlock("th", mergeProps({
                    key: column.identifier + ":" + index210 + "header"
                  }, column.thAttrsData, {
                    class: thClasses(column),
                    style: isMobileActive.value ? {} : column.style,
                    draggable: canDragColumn.value,
                    onClick: withModifiers(($event) => sort(column, null, $event), ["stop"]),
                    onDragstart: ($event) => handleColumnDragStart(column, index210, $event),
                    onDragend: ($event) => handleColumnDragEnd(column, index210, $event),
                    onDrop: ($event) => handleColumnDrop(column, index210, $event),
                    onDragover: ($event) => handleColumnDragOver(column, index210, $event),
                    onDragleave: ($event) => handleColumnDragLeave(column, index210, $event)
                  }), [
                    ((_a2 = column.$slots) == null ? void 0 : _a2.header) ? (openBlock(), createBlock(unref(OSlotComponent), {
                      key: 0,
                      component: column.$el,
                      name: "header",
                      tag: "span",
                      props: { column, index: index210 }
                    }, null, 8, ["component", "props"])) : (openBlock(), createElementBlock("span", _hoisted_5, [
                      createTextVNode(toDisplayString(column.label) + " ", 1),
                      withDirectives(createBaseVNode("span", {
                        class: normalizeClass(unref(thSortIconClasses))
                      }, [
                        createVNode(_sfc_main, {
                          icon: __props.sortIcon,
                          pack: __props.iconPack,
                          both: "",
                          size: __props.sortIconSize,
                          rotation: !isAsc.value ? 180 : 0
                        }, null, 8, ["icon", "pack", "size", "rotation"])
                      ], 2), [
                        [
                          vShow,
                          column.sortable && isColumnSorted(column)
                        ]
                      ])
                    ]))
                  ], 16, _hoisted_42);
                }), 128)),
                __props.checkable && __props.checkboxPosition === "right" ? (openBlock(), createElementBlock("th", {
                  key: 2,
                  class: normalizeClass([...unref(thBaseClasses), ...unref(thCheckboxClasses)])
                }, [
                  __props.headerCheckable ? renderSlot(_ctx.$slots, "check-all", {
                    key: 0,
                    isAllChecked: isAllChecked.value,
                    isAllUncheckable: isAllUncheckable.value,
                    checkAll
                  }, () => [
                    createVNode(_sfc_main8, {
                      "model-value": isAllChecked.value,
                      autocomplete: "off",
                      variant: __props.checkboxVariant,
                      disabled: isAllUncheckable.value,
                      "onUpdate:modelValue": checkAll
                    }, null, 8, ["model-value", "variant", "disabled"])
                  ]) : createCommentVNode("", true)
                ], 2)) : createCommentVNode("", true)
              ]),
              hasSearchablenewColumns.value ? (openBlock(), createElementBlock("tr", _hoisted_6, [
                showDetailRowIcon.value ? (openBlock(), createElementBlock("th", {
                  key: 0,
                  class: normalizeClass([...unref(thBaseClasses), ...unref(thDetailedClasses)])
                }, null, 2)) : createCommentVNode("", true),
                __props.checkable && __props.checkboxPosition === "left" ? (openBlock(), createElementBlock("th", _hoisted_7)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleColumns.value, (column, index210) => {
                  var _a2;
                  return openBlock(), createElementBlock("th", mergeProps({
                    key: column.identifier + ":" + index210 + "searchable"
                  }, column.thAttrsData, {
                    class: thClasses(column),
                    style: isMobileActive.value ? {} : column.style
                  }), [
                    column.searchable ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      ((_a2 = column.$slots) == null ? void 0 : _a2.searchable) ? (openBlock(), createBlock(unref(OSlotComponent), {
                        key: 0,
                        component: column.$el,
                        name: "searchable",
                        tag: "span",
                        props: { column, index: index210, filters: filters.value }
                      }, null, 8, ["component", "props"])) : (openBlock(), createBlock(_sfc_main2, mergeProps({
                        key: 1,
                        modelValue: filters.value[column.field],
                        "onUpdate:modelValue": ($event) => filters.value[column.field] = $event,
                        type: column.numeric ? "number" : "text"
                      }, { [toHandlerKey(__props.filtersEvent)]: onFiltersEvent }), null, 16, ["modelValue", "onUpdate:modelValue", "type"]))
                    ], 64)) : createCommentVNode("", true)
                  ], 16);
                }), 128)),
                __props.checkable && __props.checkboxPosition === "right" ? (openBlock(), createElementBlock("th", _hoisted_8)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true),
              hasCustomSubheadings.value ? (openBlock(), createElementBlock("tr", _hoisted_9, [
                showDetailRowIcon.value ? (openBlock(), createElementBlock("th", {
                  key: 0,
                  class: normalizeClass([...unref(thBaseClasses), ...unref(thDetailedClasses)])
                }, null, 2)) : createCommentVNode("", true),
                __props.checkable && __props.checkboxPosition === "left" ? (openBlock(), createElementBlock("th", _hoisted_10)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(visibleColumns.value, (column, index210) => {
                  var _a2;
                  return openBlock(), createElementBlock("th", {
                    key: column.identifier + ":" + index210 + "subheading",
                    style: normalizeStyle(isMobileActive.value ? {} : column.style),
                    class: normalizeClass([...unref(thBaseClasses), ...unref(thSubheadingClasses)])
                  }, [
                    ((_a2 = column.$slots) == null ? void 0 : _a2.subheading) ? (openBlock(), createBlock(unref(OSlotComponent), {
                      key: 0,
                      component: column.$el,
                      name: "subheading",
                      tag: "span",
                      props: { column, index: index210 }
                    }, null, 8, ["component", "props"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(column.subheading), 1)
                    ], 64))
                  ], 6);
                }), 128)),
                __props.checkable && __props.checkboxPosition === "right" ? (openBlock(), createElementBlock("th", _hoisted_11)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(visibleRows.value, (row, index210) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: getRowKey(row) + "row"
                }, [
                  createBaseVNode("tr", {
                    class: normalizeClass(rowClasses(row, index210)),
                    draggable: canDragRow.value,
                    onClick: ($event) => selectRow(row, index210, $event),
                    onDblclick: ($event) => _ctx.$emit("dblclick", row, index210, $event),
                    onMouseenter: ($event) => _ctx.$emit("mouseenter", row, index210, $event),
                    onMouseleave: ($event) => _ctx.$emit("mouseleave", row, index210, $event),
                    onContextmenu: ($event) => _ctx.$emit("contextmenu", row, index210, $event),
                    onDragstart: ($event) => handleDragStart(row, index210, $event),
                    onDragend: ($event) => handleDragEnd(row, index210, $event),
                    onDrop: ($event) => handleDrop(row, index210, $event),
                    onDragover: ($event) => handleDragOver(row, index210, $event),
                    onDragleave: ($event) => handleDragLeave(row, index210, $event)
                  }, [
                    showDetailRowIcon.value ? (openBlock(), createElementBlock("td", {
                      key: 0,
                      class: normalizeClass([
                        ...unref(tdBaseClasses),
                        ...unref(tdDetailedChevronClasses)
                      ])
                    }, [
                      __props.hasDetailedVisible(row) ? (openBlock(), createBlock(_sfc_main, {
                        key: 0,
                        icon: __props.detailIcon,
                        pack: __props.iconPack,
                        rotation: isVisibleDetailRow(row) ? 90 : 0,
                        role: "button",
                        clickable: "",
                        both: "",
                        onClick: withModifiers(($event) => toggleDetails(row), ["stop"])
                      }, null, 8, ["icon", "pack", "rotation", "onClick"])) : createCommentVNode("", true)
                    ], 2)) : createCommentVNode("", true),
                    __props.checkable && __props.checkboxPosition === "left" ? (openBlock(), createElementBlock("td", {
                      key: 1,
                      class: normalizeClass([
                        ...unref(thBaseClasses),
                        ...unref(tdCheckboxClasses)
                      ])
                    }, [
                      createVNode(_sfc_main8, {
                        "model-value": isRowChecked(row),
                        autocomplete: "off",
                        variant: __props.checkboxVariant,
                        disabled: !__props.isRowCheckable(row),
                        "onUpdate:modelValue": ($event) => checkRow(row, index210)
                      }, null, 8, ["model-value", "variant", "disabled", "onUpdate:modelValue"])
                    ], 2)) : createCommentVNode("", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(visibleColumns.value, (column, colindex) => {
                      return openBlock(), createBlock(unref(OSlotComponent), mergeProps({
                        key: column.identifier + index210 + ":" + colindex
                      }, column.tdAttrsData[index210], {
                        component: column.$el,
                        name: "default",
                        tag: "td",
                        class: tdClasses(row, column),
                        style: isMobileActive.value ? {} : column.style,
                        "data-label": column.label,
                        props: {
                          row,
                          column,
                          index: index210,
                          colindex,
                          toggleDetails
                        },
                        onClick: ($event) => _ctx.$emit(
                          "cell-click",
                          row,
                          column,
                          index210,
                          colindex,
                          $event
                        )
                      }), null, 16, ["component", "class", "style", "data-label", "props", "onClick"]);
                    }), 128)),
                    __props.checkable && __props.checkboxPosition === "right" ? (openBlock(), createElementBlock("td", {
                      key: 2,
                      class: normalizeClass([
                        ...unref(thBaseClasses),
                        ...unref(tdCheckboxClasses)
                      ])
                    }, [
                      createVNode(_sfc_main8, {
                        "model-value": isRowChecked(row),
                        autocomplete: "off",
                        variant: __props.checkboxVariant,
                        disabled: !__props.isRowCheckable(row),
                        "onUpdate:modelValue": ($event) => checkRow(row, index210)
                      }, null, 8, ["model-value", "variant", "disabled", "onUpdate:modelValue"])
                    ], 2)) : createCommentVNode("", true)
                  ], 42, _hoisted_122),
                  createVNode(Transition, { name: __props.detailTransition }, {
                    default: withCtx(() => [
                      isActiveDetailRow(row) ? (openBlock(), createElementBlock("tr", {
                        key: getRowKey(row) + "detail",
                        class: normalizeClass(unref(detailedClasses))
                      }, [
                        createBaseVNode("td", { colspan: columnCount.value }, [
                          renderSlot(_ctx.$slots, "detail", {
                            row,
                            index: index210
                          })
                        ], 8, _hoisted_132)
                      ], 2)) : createCommentVNode("", true)
                    ]),
                    _: 2
                  }, 1032, ["name"]),
                  isActiveCustomDetailRow(row) ? renderSlot(_ctx.$slots, "detail", {
                    key: 0,
                    row,
                    index: index210
                  }) : createCommentVNode("", true)
                ], 64);
              }), 128)),
              !visibleRows.value.length ? (openBlock(), createElementBlock("tr", _hoisted_142, [
                createBaseVNode("td", { colspan: columnCount.value }, [
                  renderSlot(_ctx.$slots, "empty")
                ], 8, _hoisted_152)
              ])) : createCommentVNode("", true)
            ]),
            _ctx.$slots.footer ? (openBlock(), createElementBlock("tfoot", _hoisted_162, [
              createBaseVNode("tr", {
                class: normalizeClass(unref(footerClasses))
              }, [
                hasCustomFooterSlot() ? renderSlot(_ctx.$slots, "footer", {
                  key: 0,
                  columnCount: columnCount.value,
                  rowCount: (_a = visibleRows.value) == null ? void 0 : _a.length
                }) : (openBlock(), createElementBlock("th", {
                  key: 1,
                  colspan: columnCount.value
                }, [
                  renderSlot(_ctx.$slots, "footer", {
                    columnCount: columnCount.value,
                    rowCount: (_b = visibleRows.value) == null ? void 0 : _b.length
                  })
                ], 8, _hoisted_172))
              ], 2)
            ])) : createCommentVNode("", true)
          ], 42, _hoisted_119),
          renderSlot(_ctx.$slots, "loading", { loading: __props.loading }, () => [
            createVNode(_sfc_main16, {
              "full-page": false,
              active: __props.loading
            }, null, 8, ["active"])
          ])
        ], 6),
        __props.checkable && _ctx.$slots["bottom-left"] || __props.paginated && (__props.paginationPosition === "bottom" || __props.paginationPosition === "both") ? renderSlot(_ctx.$slots, "pagination", {
          key: 2,
          current: unref(tableCurrentPage),
          perPage: __props.perPage,
          total: dataTotal.value,
          change: (page) => tableCurrentPage.value = page
        }, () => [
          createVNode(_sfc_main$19, mergeProps(_ctx.$attrs, {
            current: unref(tableCurrentPage),
            "onUpdate:current": _cache[5] || (_cache[5] = ($event) => isRef(tableCurrentPage) ? tableCurrentPage.value = $event : null),
            paginated: __props.paginated,
            "per-page": __props.perPage,
            total: dataTotal.value,
            rounded: __props.paginationRounded,
            size: __props.paginationSize,
            order: __props.paginationOrder,
            simple: __props.paginationSimple,
            "icon-pack": __props.iconPack,
            "aria-next-label": __props.ariaNextLabel,
            "aria-previous-label": __props.ariaPreviousLabel,
            "aria-page-label": __props.ariaPageLabel,
            "aria-current-label": __props.ariaCurrentLabel,
            "root-class": paginationWrapperRootClasses.value,
            onChange: _cache[6] || (_cache[6] = (page) => _ctx.$emit("page-change", page))
          }), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "bottom-left")
            ]),
            _: 3
          }, 16, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var index24 = {
  install(app) {
    registerComponent(app, _sfc_main28);
    registerComponent(app, _sfc_main$23);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/tabs.mjs
var _hoisted_1$16 = ["aria-orientation"];
var _hoisted_215 = ["aria-controls", "aria-selected"];
var _sfc_main$110 = defineComponent({
  ...{
    isOruga: true,
    name: "OTabs",
    configField: "tabs"
  },
  __name: "Tabs",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("tabs.variant")
    },
    /**
     * Tab size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("tabs.size")
    },
    /** Show tab in vertical layout */
    vertical: {
      type: Boolean,
      default: () => getOption("tabs.vertical", false)
    },
    /**
     * Position of the tabs
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (value) => ["left", "centered", "right"].indexOf(value) >= 0
    },
    /**
     * Tab type
     * @values boxed, toggle
     */
    type: { type: String, default: () => getOption("tabs.type", "default") },
    /** Tabs will be expanded (full-width) */
    expanded: { type: Boolean, default: false },
    /** Destroy tabItem on hide */
    destroyOnHide: { type: Boolean, default: false },
    /** Tab will have an animation */
    animated: {
      type: Boolean,
      default: () => getOption("tabs.animated", true)
    },
    /**
     * Transition animation name
     * @values [next, prev], [right, left, down, up]
     */
    animation: {
      type: Array,
      default: () => getOption("tabs.animation", [
        "slide-next",
        "slide-prev",
        "slide-down",
        "slide-up"
      ]),
      validator: (value) => value.length === 2 || value.length === 4
    },
    /** Apply animation on the initial render */
    animateInitially: {
      type: Boolean,
      default: () => getOption("tabs.animateInitially", false)
    },
    /** Show tab items multiline when there is no space */
    multiline: { type: Boolean, default: false },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when when is vertical and its position changes */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when vertical */
    verticalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when multiline */
    multilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Tabs component nav tabs */
    navTabsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Size of the navigation */
    navSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Tabs component nav position */
    navPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Type of the navigation */
    navTypeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab content when transitioning */
    transitioningClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item wrapper */
    itemWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "change"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = ref();
    const provideData = computed(() => ({
      activeValue: vmodel.value,
      type: props.type,
      vertical: props.vertical,
      animated: props.animated,
      animation: props.animation,
      animateInitially: props.animateInitially,
      destroyOnHide: props.destroyOnHide
    }));
    const { sortedItems } = useProviderParent(rootRef, {
      data: provideData
    });
    const items = computed(
      () => sortedItems.value.map((column) => ({
        index: column.index,
        identifier: column.identifier,
        ...toValue(column.data)
      }))
    );
    const vmodel = useModel(__props, "modelValue");
    watch(
      () => props.modelValue,
      (value) => {
        if (vmodel.value !== value)
          performAction(value);
      }
    );
    const activeItem = computed(
      () => isDefined(vmodel.value) ? items.value.find((item) => item.value === vmodel.value) || items.value[0] : items.value[0]
    );
    const activeIndex = computed(() => activeItem.value.index);
    function isActive(item) {
      return item.value === activeItem.value.value;
    }
    const isTransitioning = computed(
      () => items.value.some((item) => item.isTransitioning)
    );
    function itemClick(item) {
      if (vmodel.value !== item.value)
        performAction(item.value);
    }
    function next() {
      const newIndex = mod(activeIndex.value + 1, items.value.length);
      clickFirstViableChild(newIndex, true);
    }
    function prev() {
      const newIndex = mod(activeIndex.value - 1, items.value.length);
      clickFirstViableChild(newIndex, false);
    }
    function homePressed() {
      if (items.value.length < 1)
        return;
      clickFirstViableChild(0, true);
    }
    function endPressed() {
      if (items.value.length < 1)
        return;
      clickFirstViableChild(items.value.length - 1, false);
    }
    function clickFirstViableChild(startingIndex, forward) {
      const direction = forward ? 1 : -1;
      let newIndex = startingIndex;
      for (; newIndex !== activeIndex.value; newIndex = mod(newIndex + direction, items.value.length)) {
        if (items.value[newIndex].visible && !items.value[newIndex].disabled)
          break;
      }
      itemClick(items.value[newIndex]);
    }
    function performAction(newId) {
      const oldId = vmodel.value;
      const oldItem = activeItem.value;
      const newItem = items.value.find((item) => item.value === newId) || items.value[0];
      if (oldItem && newItem) {
        oldItem.deactivate(newItem.index);
        newItem.activate(oldItem.index);
      }
      nextTick(() => {
        vmodel.value = newId;
        emits("change", newId, oldId);
      });
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-tabs"],
      [
        "positionClass",
        "o-tabs--",
        computed(() => props.position),
        computed(() => props.position && props.vertical)
      ],
      [
        "expandedClass",
        "o-tabs--fullwidth",
        null,
        computed(() => props.expanded)
      ],
      ["verticalClass", "o-tabs--vertical", null, computed(() => props.vertical)],
      [
        "multilineClass",
        "o-tabs--multiline",
        null,
        computed(() => props.multiline)
      ]
    );
    const itemWrapperClasses = defineClasses([
      "itemWrapperClass",
      "o-tabs__nav-item-wrapper"
    ]);
    const navClasses = defineClasses(
      ["navTabsClass", "o-tabs__nav"],
      [
        "navSizeClass",
        "o-tabs__nav--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "navPositionClass",
        "o-tabs__nav--",
        computed(() => props.position),
        computed(() => props.position && !props.vertical)
      ],
      [
        "navTypeClass",
        "o-tabs__nav--",
        computed(() => props.type),
        computed(() => !!props.type)
      ]
    );
    const contentClasses = defineClasses(
      ["contentClass", "o-tabs__content"],
      [
        "transitioningClass",
        "o-tabs__content--transitioning",
        null,
        isTransitioning
      ]
    );
    function itemHeaderClasses(childItem) {
      const classes = defineClasses(
        ["itemHeaderClass", "o-tabs__nav-item"],
        ["itemHeaderTypeClass", "o-tabs__nav-item-", props.type, !!props.type],
        [
          "itemHeaderActiveClass",
          "o-tabs__nav-item-{*}--active",
          props.type,
          isActive(childItem)
        ],
        [
          "itemHeaderDisabledClass",
          "o-tabs__nav-item-{*}--disabled",
          props.type,
          childItem.disabled
        ]
      );
      const headerClass = { [childItem.headerClass || ""]: true };
      return [headerClass, ...classes.value];
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootRef",
        ref: rootRef,
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "tabs"
      }, [
        createBaseVNode("nav", {
          class: normalizeClass(unref(navClasses)),
          role: "tablist",
          "aria-orientation": __props.vertical ? "vertical" : "horizontal"
        }, [
          renderSlot(_ctx.$slots, "start"),
          (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (childItem) => {
            return withDirectives((openBlock(), createElementBlock("div", {
              key: childItem.value,
              class: normalizeClass(unref(itemWrapperClasses)),
              role: "tab",
              "aria-controls": `${childItem.value}-content`,
              "aria-selected": isActive(childItem) ? "true" : "false"
            }, [
              childItem.$slots.header ? (openBlock(), createBlock(unref(OSlotComponent), {
                key: 0,
                component: childItem,
                tag: childItem.tag,
                name: "header",
                class: normalizeClass(itemHeaderClasses(childItem)),
                onClick: ($event) => itemClick(childItem),
                onKeydown: [
                  withKeys(($event) => itemClick(childItem), ["enter"]),
                  withKeys(withModifiers(prev, ["prevent"]), ["left"]),
                  withKeys(withModifiers(next, ["prevent"]), ["right"]),
                  withKeys(withModifiers(prev, ["prevent"]), ["up"]),
                  withKeys(withModifiers(next, ["prevent"]), ["down"]),
                  withKeys(withModifiers(homePressed, ["prevent"]), ["home"]),
                  withKeys(withModifiers(endPressed, ["prevent"]), ["end"])
                ]
              }, null, 8, ["component", "tag", "class", "onClick", "onKeydown"])) : (openBlock(), createBlock(resolveDynamicComponent(childItem.tag), {
                key: 1,
                role: "button",
                tabindex: 0,
                class: normalizeClass(itemHeaderClasses(childItem)),
                onClick: ($event) => itemClick(childItem),
                onKeydown: [
                  withKeys(($event) => itemClick(childItem), ["enter"]),
                  withKeys(withModifiers(prev, ["prevent"]), ["left"]),
                  withKeys(withModifiers(next, ["prevent"]), ["right"]),
                  withKeys(withModifiers(prev, ["prevent"]), ["up"]),
                  withKeys(withModifiers(next, ["prevent"]), ["down"]),
                  withKeys(withModifiers(homePressed, ["prevent"]), ["home"]),
                  withKeys(withModifiers(endPressed, ["prevent"]), ["end"])
                ]
              }, {
                default: withCtx(() => [
                  childItem.icon ? (openBlock(), createBlock(_sfc_main, {
                    key: 0,
                    "root-class": unref(getActiveClasses)(childItem.headerIconClasses),
                    icon: childItem.icon,
                    pack: childItem.iconPack,
                    size: __props.size
                  }, null, 8, ["root-class", "icon", "pack", "size"])) : createCommentVNode("", true),
                  createBaseVNode("span", {
                    class: normalizeClass(childItem.headerTextClasses)
                  }, toDisplayString(childItem.label), 3)
                ]),
                _: 2
              }, 1064, ["class", "onClick", "onKeydown"]))
            ], 10, _hoisted_215)), [
              [vShow, childItem.visible]
            ]);
          }), 128)),
          renderSlot(_ctx.$slots, "end")
        ], 10, _hoisted_1$16),
        createBaseVNode("section", {
          class: normalizeClass(unref(contentClasses))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ], 2);
    };
  }
});
var _hoisted_120 = ["data-id", "tabindex", "role"];
var _sfc_main29 = defineComponent({
  ...{
    isOruga: true,
    name: "OTabItem",
    configField: "tabs",
    inheritAttrs: false
  },
  __name: "TabItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Item value (it will be used as v-model of wrapper component) */
    value: { type: [String, Number], default: () => uuid() },
    /** Item label */
    label: { type: String, default: void 0 },
    /** Item will be disabled */
    disabled: { type: Boolean, default: false },
    /** Icon on the left */
    icon: {
      type: String,
      default: () => getOption("tabs.icon")
    },
    /** Icon pack */
    iconPack: {
      type: String,
      default: () => getOption("tabs.iconPack")
    },
    /** Show/hide item */
    visible: { type: Boolean, default: true },
    /** Tabs item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => getOption("tabs.itemTag", "button")
    },
    /** Role attribute to be passed to the div wrapper for better accessibility. */
    ariaRole: {
      type: String,
      default: () => getOption("tabs.ariaRole", "tab")
    },
    /** Sets a class to the item header */
    headerClass: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the tab item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header when active */
    itemHeaderActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header when disabled */
    itemHeaderDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header type */
    itemHeaderTypeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header icon */
    itemHeaderIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header text */
    itemHeaderTextClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["activate", "deactivate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const providedData = computed(() => ({
      ...props,
      $slots: slots,
      headerIconClasses: headerIconClasses.value,
      headerTextClasses: headerTextClasses.value,
      isTransitioning: isTransitioning.value,
      activate,
      deactivate
    }));
    const { parent, item } = useProviderChild({
      data: providedData
    });
    const transitionName = ref();
    const isActive = computed(() => isEqual(props.value, parent.value.activeValue));
    const isTransitioning = ref(false);
    const nextAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 2 : 0;
      return parent.value.animation[idx];
    });
    const prevAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 3 : 1;
      return parent.value.animation[idx];
    });
    function activate(oldIndex) {
      transitionName.value = item.value.index < oldIndex ? nextAnimation.value : prevAnimation.value;
      emits("activate");
    }
    function deactivate(newIndex) {
      transitionName.value = newIndex < item.value.index ? nextAnimation.value : prevAnimation.value;
      emits("deactivate");
    }
    function afterEnter() {
      isTransitioning.value = true;
    }
    function beforeLeave() {
      isTransitioning.value = true;
    }
    const elementClasses = defineClasses(["itemClass", "o-tab-item__content"]);
    const headerIconClasses = defineClasses([
      "itemHeaderIconClass",
      "o-tabs__nav-item-icon"
    ]);
    const headerTextClasses = defineClasses([
      "itemHeaderTextClass",
      "o-tabs__nav-item-text"
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        css: unref(parent).animated,
        name: transitionName.value,
        appear: unref(parent).animateInitially,
        onAfterEnter: afterEnter,
        onBeforeLeave: beforeLeave
      }, {
        default: withCtx(() => [
          !unref(parent).destroyOnHide || isActive.value && __props.visible ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            ref: "rootRef"
          }, _ctx.$attrs, {
            class: unref(elementClasses),
            "data-id": `tabs-${unref(item).identifier}`,
            "data-oruga": "tabs-item",
            tabindex: isActive.value ? 0 : -1,
            role: __props.ariaRole,
            "aria-roledescription": "item"
          }), [
            renderSlot(_ctx.$slots, "default")
          ], 16, _hoisted_120)), [
            [vShow, isActive.value && __props.visible]
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["css", "name", "appear"]);
    };
  }
});
var index25 = {
  install(app) {
    registerComponent(app, _sfc_main$110);
    registerComponent(app, _sfc_main29);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/taginput.mjs
var _sfc_main30 = defineComponent({
  ...{
    isOruga: true,
    name: "OTaginput",
    configField: "taginput",
    inheritAttrs: false
  },
  __name: "Taginput",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Array, default: () => [] },
    /** Items data */
    data: { type: Array, default: () => [] },
    /** Property of the object (if data is array of objects) to use as display text */
    field: { type: String, default: "value" },
    /** Property of the object (if `data` is array of objects) to use as display text of group */
    groupField: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as key to get items array of each group */
    groupOptions: { type: String, default: void 0 },
    /**
     * Vertical size of the input control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => getOption("taginput.size")
    },
    /**
     * Color of the each item
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("taginput.variant")
    },
    /** Limits the number of items, plus item counter */
    maxitems: { type: [String, Number], default: void 0 },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: [String, Number], default: void 0 },
    /** Show counter when maxlength or maxtags props are passed */
    counter: {
      type: Boolean,
      default: () => getOption("taginput.counter", true)
    },
    /** Opens a dropdown with choices when the input field is focused */
    openOnFocus: { type: Boolean, default: false },
    /** Keep open dropdown list after select */
    keepOpen: {
      type: Boolean,
      default: () => getOption("autocomplete.keepOpen", false)
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: false },
    /** Same as native input disabled */
    disabled: { type: Boolean, default: false },
    /**
     * Array of keys
     * (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
     * which will add a item when typing
     */
    confirmKeys: {
      type: Array,
      default: () => getOption("taginput.confirmKeys", [",", "Tab", "Enter"])
    },
    /** Array of chars used to split when pasting a new string */
    separators: {
      type: Array,
      default: () => getOption("taginput.separators", [","])
    },
    /** The first option will always be pre-selected (easier to just hit enter or tab) */
    keepFirst: { type: Boolean, default: false },
    /** When autocomplete, it allow to add new items */
    allowNew: { type: Boolean, default: false },
    /** Allows adding the same item multiple time */
    allowDuplicates: { type: Boolean, default: false },
    /** Add autocomplete feature (if true, any Autocomplete props may be used too) */
    allowAutocomplete: { type: Boolean, default: false },
    /** Allow removing last item when pressing given keys, if input is empty */
    removeOnKeys: {
      type: Array,
      default: () => getOption("taginput.removeOnKeys", ["Backspace"])
    },
    /** Function to validate the value of the item before adding */
    beforeAdding: {
      type: Function,
      default: () => true
    },
    /** Function to create a new item to push into v-model (items) */
    createItem: {
      type: Function,
      default: (item) => item
    },
    /** Makes the component check if list reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => getOption("taginput.checkScroll", false)
    },
    /** Add close/delete button to the item */
    closable: {
      type: Boolean,
      default: () => getOption("taginput.closable", true)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => getOption("taginput.iconPack")
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => getOption("taginput.icon")
    },
    /** Icon name of close icon on selected item */
    closeIcon: {
      type: String,
      default: () => getOption("taginput.closeIcon", "close")
    },
    /** Accessibility label for the close button */
    ariaCloseLabel: {
      type: String,
      default: () => getOption("taginput.ariaCloseLabel")
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => getOption("taginput.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => getOption("taginput.teleport", false)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input container */
    containerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input container size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the entered item variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button of entered item */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the entered item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the counter element */
    counterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the underlying autocomplete component
     * @ignore
     */
    autocompleteClasses: {
      type: Object,
      default: () => getOption("taginput.autocompleteClasses", {})
    }
  }, {
    "modelValue": { default: () => [] },
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "input", "add", "remove", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const autocompleteRef = ref();
    const items = useModel(__props, "modelValue");
    const { setFocus, onFocus, onBlur, onInvalid } = useInputHandler(
      autocompleteRef,
      emits,
      props
    );
    const newItem = ref("");
    const isComposing = ref(false);
    const valueLength = computed(() => newItem.value.trim().length);
    const itemsLength = computed(() => items.value.length);
    const hasInput = computed(
      () => props.maxitems == null || itemsLength.value < Number(props.maxitems)
    );
    watchEffect(() => {
      if (!hasInput.value)
        onBlur();
    });
    const separatorsAsRegExp = computed(
      () => props.separators.length ? new RegExp(
        props.separators.map(
          (s) => s ? s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : null
        ).join("|"),
        "g"
      ) : null
    );
    function getNormalizedItemText(item) {
      if (typeof item === "object")
        item = getValueByPath(item, props.field);
      return `${item}`;
    }
    function addItem(item) {
      item = item || newItem.value.trim();
      if (item) {
        if (typeof item === "string") {
          const reg = separatorsAsRegExp.value;
          if (reg && item.match(reg)) {
            item.split(reg).map((t) => t.trim()).filter((t) => t.length !== 0).map(addItem);
            return;
          }
        }
        const itemToAdd = props.createItem(item);
        const add = !props.allowDuplicates ? items.value.indexOf(itemToAdd) === -1 : true;
        if (add && props.beforeAdding(item)) {
          items.value = [...items.value, itemToAdd];
          emits("add", itemToAdd);
        }
      }
      requestAnimationFrame(() => {
        newItem.value = "";
        emits("input", newItem.value);
      });
    }
    function removeItem(index210, event) {
      const item = items.value.at(index210);
      items.value = items.value.toSpliced(index210, 1);
      emits("remove", item);
      if (event)
        event.stopPropagation();
      if (props.openOnFocus && autocompleteRef.value)
        setFocus();
    }
    function onSelect(option) {
      if (!option)
        return;
      addItem(option);
      nextTick(() => newItem.value = "");
    }
    function onKeydown(event) {
      var _a;
      if (props.removeOnKeys.indexOf(event.key) !== -1 && !((_a = newItem.value) == null ? void 0 : _a.length) && itemsLength.value > 0) {
        removeItem(itemsLength.value - 1);
      }
      if (props.allowAutocomplete && !props.allowNew)
        return;
      if (props.confirmKeys.indexOf(event.key) >= 0) {
        if (event.key !== "Tab")
          event.preventDefault();
        if (event.key === "Enter" && isComposing.value)
          return;
        addItem();
      }
    }
    function onInput(value) {
      emits("input", String(value).trim());
    }
    function handleOnBlur(event) {
      if (!props.allowAutocomplete)
        addItem();
      onBlur(event);
    }
    const attrs = useAttrs();
    const autocompleteRootClasses = defineClasses([
      "autocompleteClasses.rootClass",
      "o-taginput__autocomplete"
    ]);
    const autocompleteInputClasses = defineClasses([
      "autocompleteClasses.inputClasses.inputClass",
      "o-taginput__input"
    ]);
    const autocompleteBind = computed(() => ({
      ...attrs,
      "root-class": getActiveClasses(autocompleteRootClasses.value),
      "input-classes": {
        "input-class": getActiveClasses(autocompleteInputClasses.value)
      },
      ...props.autocompleteClasses
    }));
    const rootClasses = defineClasses(
      ["rootClass", "o-taginput"],
      [
        "expandedClass",
        "o-taginput--expanded",
        null,
        computed(() => props.expanded)
      ]
    );
    const containerClasses = defineClasses(
      ["containerClass", "o-taginput__container"],
      [
        "sizeClass",
        "o-taginput__container--",
        computed(() => props.size),
        computed(() => !!props.size)
      ]
    );
    const itemClasses = defineClasses(
      ["itemClass", "o-taginput__item"],
      [
        "variantClass",
        "o-taginput__item--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    const closeClasses = defineClasses(["closeClass", "o-taginput__item__close"]);
    const counterClasses = defineClasses(["counterClass", "o-taginput__counter"]);
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "taginput",
        class: normalizeClass(unref(rootClasses))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(containerClasses)),
          onFocus: _cache[7] || (_cache[7] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onBlur: _cache[8] || (_cache[8] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args))
        }, [
          renderSlot(_ctx.$slots, "selected", {
            items: items.value,
            removeItem
          }, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (item, index210) => {
              return openBlock(), createElementBlock("span", {
                key: getNormalizedItemText(item) + index210,
                class: normalizeClass(unref(itemClasses))
              }, [
                createBaseVNode("span", null, toDisplayString(getNormalizedItemText(item)), 1),
                __props.closable ? (openBlock(), createBlock(_sfc_main, {
                  key: 0,
                  class: normalizeClass(unref(closeClasses)),
                  clickable: "",
                  pack: __props.iconPack,
                  icon: __props.closeIcon,
                  "aria-label": __props.ariaCloseLabel,
                  both: "",
                  onClick: ($event) => removeItem(index210, $event)
                }, null, 8, ["class", "pack", "icon", "aria-label", "onClick"])) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]),
          withDirectives(createVNode(_sfc_main5, mergeProps({
            ref_key: "autocompleteRef",
            ref: autocompleteRef,
            modelValue: newItem.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => newItem.value = $event)
          }, autocompleteBind.value, {
            data: __props.data,
            field: __props.field,
            icon: __props.icon,
            "icon-pack": __props.iconPack,
            maxlength: __props.maxlength,
            size: __props.size,
            disabled: __props.disabled,
            autocomplete: __props.autocomplete,
            "open-on-focus": __props.openOnFocus,
            "keep-first": __props.keepFirst,
            "keep-open": __props.keepOpen,
            "group-field": __props.groupField,
            "group-options": __props.groupOptions,
            "has-counter": false,
            "use-html5-validation": __props.useHtml5Validation,
            "check-scroll": __props.checkScroll,
            teleport: __props.teleport,
            "confirm-keys": __props.confirmKeys,
            placeholder: __props.placeholder,
            "validation-message": __props.validationMessage,
            expanded: __props.expanded,
            onInput,
            onFocus: unref(onFocus),
            onBlur: handleOnBlur,
            onInvalid: unref(onInvalid),
            onKeydown,
            onCompositionstart: _cache[1] || (_cache[1] = ($event) => isComposing.value = true),
            onCompositionend: _cache[2] || (_cache[2] = ($event) => isComposing.value = false),
            onSelect,
            onScrollStart: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("scroll-start")),
            onScrollEnd: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("scroll-end")),
            onIconClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("icon-click", $event)),
            onIconRightClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("icon-right-click", $event))
          }), createSlots({ _: 2 }, [
            _ctx.$slots.header ? {
              name: "header",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "header")
              ]),
              key: "0"
            } : void 0,
            _ctx.$slots.default ? {
              name: "default",
              fn: withCtx((props2) => [
                renderSlot(_ctx.$slots, "default", {
                  option: props2.option,
                  index: props2.index,
                  value: props2.value
                })
              ]),
              key: "1"
            } : void 0,
            _ctx.$slots.empty ? {
              name: "empty",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "empty")
              ]),
              key: "2"
            } : void 0,
            _ctx.$slots.footer ? {
              name: "footer",
              fn: withCtx(() => [
                renderSlot(_ctx.$slots, "footer")
              ]),
              key: "3"
            } : void 0
          ]), 1040, ["modelValue", "data", "field", "icon", "icon-pack", "maxlength", "size", "disabled", "autocomplete", "open-on-focus", "keep-first", "keep-open", "group-field", "group-options", "use-html5-validation", "check-scroll", "teleport", "confirm-keys", "placeholder", "validation-message", "expanded", "onFocus", "onInvalid"]), [
            [vShow, hasInput.value]
          ])
        ], 34),
        __props.counter && (__props.maxitems || __props.maxlength) ? (openBlock(), createElementBlock("small", {
          key: 0,
          class: normalizeClass(unref(counterClasses))
        }, [
          __props.maxlength && valueLength.value > 0 ? renderSlot(_ctx.$slots, "counter", {
            key: 0,
            items: valueLength.value,
            total: __props.maxlength
          }, () => [
            createTextVNode(toDisplayString(valueLength.value) + " / " + toDisplayString(__props.maxlength), 1)
          ]) : __props.maxitems ? renderSlot(_ctx.$slots, "counter", {
            key: 1,
            items: itemsLength.value,
            total: __props.maxitems
          }, () => [
            createTextVNode(toDisplayString(itemsLength.value) + " / " + toDisplayString(__props.maxitems), 1)
          ]) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
var index26 = {
  install(Vue) {
    registerComponent(Vue, _sfc_main30);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/timepicker.mjs
var index27 = {
  install(app) {
    registerComponent(app, _sfc_main13);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/tooltip.mjs
var index28 = {
  install(app) {
    registerComponent(app, _sfc_main24);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/upload.mjs
var _hoisted_121 = ["multiple", "accept", "disabled"];
var _sfc_main31 = defineComponent({
  ...{
    isOruga: true,
    name: "OUpload",
    configField: "upload",
    inheritAttrs: false
  },
  __name: "Upload",
  props: mergeModels({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Object, Array],
      default: void 0
    },
    /** Same as native, also push new item to v-model instead of replacing */
    multiple: { type: Boolean, default: false },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => getOption("upload.variant")
    },
    /** Same as native disabled */
    disabled: { type: Boolean, default: false },
    /** Same as native accept */
    accept: { type: String, default: void 0 },
    /** Accepts drag & drop and change its style */
    dragDrop: { type: Boolean, default: false },
    /** Upload will be expanded (full-width) */
    expanded: { type: Boolean, default: false },
    /** Replace last chosen files every time (like native file input element) */
    native: { type: Boolean, default: true },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => getOption("useHtml5Validation", true)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when draggable */
    draggableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when hovered */
    hoveredClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: mergeModels(["update:modelValue", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const inputRef = ref();
    const vmodel = useModel(__props, "modelValue");
    const { checkHtml5Validity, onFocus, onBlur, isValid, setFocus } = useInputHandler(inputRef, emits, props);
    const dragDropFocus = ref(false);
    watch(vmodel, (value) => {
      if (!value || Array.isArray(value) && value.length === 0)
        inputRef.value.value = null;
      if (!isValid.value && !props.dragDrop)
        checkHtml5Validity();
    });
    function onFileChange(event) {
      if (props.disabled)
        return;
      if (props.dragDrop)
        updateDragDropFocus(false);
      const value = event.target.files || event.dataTransfer.files;
      if (value.length === 0) {
        if (!vmodel.value)
          return;
        if (props.native)
          vmodel.value = null;
      }
      if (props.multiple) {
        const values = props.native || !vmodel.value || !Array.isArray(vmodel.value) ? [] : [...vmodel.value];
        for (let i = 0; i < value.length; i++) {
          const file = value[i];
          if (checkType(file))
            values.push(file);
        }
        vmodel.value = values;
      } else {
        if (props.dragDrop && value.length !== 1)
          return;
        else {
          const file = value[0];
          if (checkType(file))
            vmodel.value = file;
          else if (vmodel.value) {
            vmodel.value = null;
            clearInput();
          } else {
            clearInput();
            checkHtml5Validity();
            return;
          }
        }
      }
      if (!props.dragDrop)
        checkHtml5Validity();
    }
    function clearInput() {
      inputRef.value.value = null;
    }
    function updateDragDropFocus(focus) {
      if (!props.disabled)
        dragDropFocus.value = focus;
    }
    function checkType(file) {
      if (!props.accept)
        return true;
      const types = props.accept.split(",");
      if (types.length === 0)
        return true;
      for (let i = 0; i < types.length; i++) {
        const type = types[i].trim();
        if (type) {
          if (type.substring(0, 1) === ".") {
            const extension = file.name.toLowerCase().slice(-type.length);
            if (extension === type.toLowerCase())
              return true;
          } else {
            if (file.type.match(type))
              return true;
          }
        }
      }
      return false;
    }
    function onClick(event) {
      if (props.disabled)
        return;
      if (!props.dragDrop) {
        event.preventDefault();
        inputRef.value.click();
      }
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-upl"],
      ["expandedClass", "o-upl--expanded", null, computed(() => props.expanded)],
      ["disabledClass", "o-upl--disabled", null, computed(() => props.disabled)]
    );
    const draggableClasses = defineClasses(
      ["draggableClass", "o-upl__draggable"],
      [
        "hoveredClass",
        "o-upl__draggable--hovered",
        null,
        computed(() => !props.variant && dragDropFocus.value)
      ],
      [
        "variantClass",
        "o-upl__draggable--hovered-",
        computed(() => props.variant),
        computed(() => props.variant && dragDropFocus.value)
      ]
    );
    __expose({ focus: setFocus });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass(unref(rootClasses)),
        "data-oruga": "upload"
      }, [
        !__props.dragDrop ? renderSlot(_ctx.$slots, "default", {
          key: 0,
          onclick: onClick
        }) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(unref(draggableClasses)),
          role: "button",
          tabindex: "0",
          onMouseenter: _cache[0] || (_cache[0] = ($event) => updateDragDropFocus(true)),
          onMouseleave: _cache[1] || (_cache[1] = ($event) => updateDragDropFocus(false)),
          onDragover: _cache[2] || (_cache[2] = withModifiers(($event) => updateDragDropFocus(true), ["prevent"])),
          onDragleave: _cache[3] || (_cache[3] = withModifiers(($event) => updateDragDropFocus(false), ["prevent"])),
          onDragenter: _cache[4] || (_cache[4] = withModifiers(($event) => updateDragDropFocus(true), ["prevent"])),
          onDrop: withModifiers(onFileChange, ["prevent"])
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 34)),
        createBaseVNode("input", mergeProps(_ctx.$attrs, {
          ref_key: "inputRef",
          ref: inputRef,
          type: "file",
          "data-oruga-input": "file",
          multiple: __props.multiple,
          accept: __props.accept,
          disabled: __props.disabled,
          onChange: onFileChange,
          onFocus: _cache[5] || (_cache[5] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onBlur: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args))
        }), null, 16, _hoisted_121)
      ], 2);
    };
  }
});
var index29 = {
  install(app) {
    registerComponent(app, _sfc_main31);
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/index.mjs
var plugins = Object.freeze(Object.defineProperty({
  __proto__: null,
  Autocomplete: index,
  Button: index2,
  Carousel: index3,
  Checkbox: index4,
  Collapse: index5,
  Datepicker: index6,
  Datetimepicker: index7,
  Dropdown: index8,
  Field: index9,
  Icon: index10,
  Input: index11,
  Loading: index12,
  Menu: index13,
  Modal: index14,
  Notification: index15,
  Pagination: index16,
  Radio: index17,
  Select: index18,
  Sidebar: index20,
  Skeleton: index19,
  Slider: index21,
  Steps: index22,
  Switch: index23,
  Table: index24,
  Tabs: index25,
  Taginput: index26,
  Timepicker: index27,
  Tooltip: index28,
  Upload: index29
}, Symbol.toStringTag, { value: "Module" }));
var plugin = {
  install(app, options = {}) {
    app.use(OrugaConfig, options);
    for (const componentKey in plugins) {
      registerPlugin(app, plugins[componentKey]);
    }
    registerComponentProgrammatic(app, "config", ConfigProgrammatic);
  }
};
export {
  index as Autocomplete,
  index2 as Button,
  index3 as Carousel,
  index4 as Checkbox,
  index5 as Collapse,
  OrugaConfig as ConfigPlugin,
  ConfigProgrammatic,
  index6 as Datepicker,
  index7 as Datetimepicker,
  index8 as Dropdown,
  index9 as Field,
  index10 as Icon,
  index11 as Input,
  index12 as Loading,
  LoadingProgrammatic$1 as LoadingProgrammatic,
  index13 as Menu,
  index14 as Modal,
  ModalProgrammatic$1 as ModalProgrammatic,
  index15 as Notification,
  NotificationProgrammatic$1 as NotificationProgrammatic,
  _sfc_main5 as OAutocomplete,
  _sfc_main6 as OButton,
  _sfc_main$12 as OCarousel,
  _sfc_main7 as OCarouselItem,
  _sfc_main8 as OCheckbox,
  _sfc_main9 as OCollapse,
  _sfc_main12 as ODatepicker,
  _sfc_main14 as ODatetimepicker,
  _sfc_main$1 as ODropdown,
  _sfc_main4 as ODropdownItem,
  _sfc_main15 as OField,
  _sfc_main as OIcon,
  _sfc_main2 as OInput,
  _sfc_main16 as OLoading,
  _sfc_main$14 as OMenu,
  _sfc_main17 as OMenuItem,
  _sfc_main18 as OModal,
  _sfc_main$15 as ONotification,
  _sfc_main20 as OPagination,
  _sfc_main21 as ORadio,
  _sfc_main10 as OSelect,
  _sfc_main23 as OSidebar,
  _sfc_main22 as OSkeleton,
  _sfc_main25 as OSlider,
  _sfc_main$17 as OSliderTick,
  _sfc_main26 as OStepItem,
  _sfc_main$18 as OSteps,
  _sfc_main27 as OSwitch,
  _sfc_main29 as OTabItem,
  _sfc_main28 as OTable,
  _sfc_main$23 as OTableColumn,
  _sfc_main$110 as OTabs,
  _sfc_main30 as OTaginput,
  _sfc_main13 as OTimepicker,
  _sfc_main24 as OTooltip,
  _sfc_main31 as OUpload,
  plugin as Oruga,
  OrugaConfig,
  index16 as Pagination,
  index17 as Radio,
  index18 as Select,
  index20 as Sidebar,
  SidebarProgrammatic$1 as SidebarProgrammatic,
  index19 as Skeleton,
  index21 as Slider,
  index22 as Steps,
  index23 as Switch,
  index24 as Table,
  index25 as Tabs,
  index26 as Taginput,
  index27 as Timepicker,
  index28 as Tooltip,
  index29 as Upload,
  plugin as default,
  useOruga
};
/*! Bundled license information:

@oruga-ui/oruga-next/dist/esm/helpers.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/config-C1k5NuG7.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/defineClasses-D0J9_rOy.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Icon.vue_vue_type_script_setup_true_lang-BiTdOP-d.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/fieldInjection-B9PE5wx6.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/unrefElement-DtCqBtLW.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/ssr-BtcosYqY.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useInputHandler-CIYFU5no.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Input.vue_vue_type_script_setup_true_lang-Bvc5alcQ.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/PositionWrapper.vue_vue_type_script_setup_true_lang-CiXmKQFF.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/trapFocus-D3wF5u_Q.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useEventListener-DXZDse6S.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useMatchMedia-C64GX8hs.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useParentProvider-CVABNV-7.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useClickOutside-DcbY7k0a.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/DropdownItem.vue_vue_type_script_setup_true_lang-Dpj7m-LI.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useDebounce-Bl5cEME3.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Autocomplete.vue_vue_type_script_setup_true_lang-D7a3Rjfy.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/autocomplete.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Button.vue_vue_type_script_setup_true_lang-BMN4deA8.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/button.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/usePropValue-pUJCuQ_7.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/carousel.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Checkbox.vue_vue_type_script_setup_true_lang-QleomGq0.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/checkbox.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/collapse.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Select.vue_vue_type_script_setup_true_lang-CL_yS9EM.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/utils-4B4N5qTH.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Datepicker.vue_vue_type_script_setup_true_lang-2qtpILMI.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/datepicker.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Timepicker.vue_vue_type_script_setup_true_lang-B7TreYFS.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/datetimepicker.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/dropdown.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Field.vue_vue_type_script_setup_true_lang-wrMEoJ1V.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/field.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/icon.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/input.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/useProgrammatic-C7Risz_2.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Loading.vue_vue_type_script_setup_true_lang-eJaXDfED.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/InstanceRegistry-gfFoD3QZ.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/loading.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/menu.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/modal.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/notification.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Pagination.vue_vue_type_script_setup_true_lang-DOjx2YR8.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/pagination.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/radio.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/select.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/skeleton.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/sidebar.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/Tooltip.vue_vue_type_script_setup_true_lang-C1GHI2GD.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/slider.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/steps.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/switch.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/SlotComponent-DVvAAvO3.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/table.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/tabs.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/taginput.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/timepicker.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/tooltip.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/upload.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)

@oruga-ui/oruga-next/dist/esm/index.mjs:
  (*! Oruga v0.8.12 | MIT License | github.com/oruga-ui/oruga *)
*/
//# sourceMappingURL=@oruga-ui_oruga-next.js.map
